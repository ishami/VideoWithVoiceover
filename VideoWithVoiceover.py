# Standard library
import json, atexit
import os
import sys
import gc
import warnings
import time
import asyncio
import threading
import subprocess
import tempfile
import uuid
import base64
import pickle
import re
import shutil
import textwrap
import webbrowser
import traceback
from io import BytesIO
from collections import Counter
import builtins
import datetime
import platform

# Third-party libraries
import cv2
import numpy as np
import nltk
from nltk.corpus import stopwords
import requests
import tiktoken
import vlc
import openai
from openai import OpenAI
from pydub import AudioSegment
from PIL import Image
from bs4 import BeautifulSoup
from transformers import pipeline

# MoviePy (video/audio editing)
import moviepy.editor as mp
from moviepy.config import change_settings
from moviepy.editor import (
    VideoFileClip, concatenate_videoclips, CompositeVideoClip,
    AudioFileClip, TextClip, ImageClip, CompositeAudioClip
)
from moviepy.video.VideoClip import VideoClip
from moviepy.video.fx.all import resize
from moviepy.audio.AudioClip import concatenate_audioclips

# Text-to-speech
import edge_tts
from edge_tts import Communicate, list_voices

# Google APIs
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from googleapiclient.http import MediaFileUpload

# URL parsing
from urllib.parse import urlparse

# PyQt5 (GUI)
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QDialog, QFrame, QSplashScreen,
    QDialogButtonBox, QVBoxLayout, QHBoxLayout, QGridLayout,
    QStackedWidget, QTabWidget, QLabel, QLineEdit, QPlainTextEdit,
    QTextEdit, QRadioButton, QButtonGroup, QComboBox, QToolButton,
    QPushButton, QFileDialog, QMessageBox, QInputDialog, QFormLayout,
    QDateEdit, QCheckBox, QProgressBar, QProgressDialog, QGroupBox,QDateTimeEdit,
    QSlider, QSizePolicy, QListWidget, QTableWidget, QTableWidgetItem,
    QHeaderView, QAbstractItemView, QLayout, QStyle, QStyledItemDelegate,
    QStyleOptionViewItem, QToolTip, QDesktopWidget, QProgressDialog, QTabBar
)
from PyQt5.QtMultimedia import QMediaPlayer, QMediaContent
from PyQt5.QtMultimediaWidgets import QVideoWidget
from PyQt5.QtCore import (
    Qt, QUrl, QThread, pyqtSignal, QTimer, QSize, QDate, QDateTime,
    QObject, QEvent, QMimeData, QPoint, QStandardPaths, QCoreApplication
)
from PyQt5.QtGui import (
    QPixmap, QIcon, QImage, QDesktopServices, QCursor,
    QColor, QBrush, QDrag, QFont, QPainter, QFontMetrics, QMovie
)
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from langdetect import detect, DetectorFactory
from PyQt5.QtMultimedia import QMediaPlayer, QMediaContent
from PyQt5.QtCore import QUrl


# --------- Buttons Style Sheets -----------------------------------

os.environ["BROWSER"] = "true"      # makes webbrowser.open() a no-op
BTN_STYLE = """
QPushButton {
    background-color: #5d8aa8; /* Base color */
    color: white;
    font-weight: bold;
    font-size: 12px;
    border: 2px solid #4a739b; /* Darker border for depth */
    border-radius: 5px;
    padding: 5px 10px;
    min-width: 80px;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3); /* Shadow for 3D effect */
}
QPushButton:pressed {
    background-color: #4a739b; /* Darker shade when pressed */
    border: 2px solid #3b5a7b;
    box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.3); /* Inset shadow for pressed effect */
}
QPushButton:hover {
    background-color: #6b9ec1; /* Lighter blue on hover */
}
"""

BTN_LF_STYLE = """
QPushButton {
    background-color: #5d8aa8; /* Base color */
    color: white;
    font-weight: bold;
    font-size: 18px;
    border: 2px solid #4a739b; /* Darker border for depth */
    border-radius: 5px;
    padding: 5px 10px;
    min-width: 80px;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3); /* Shadow for 3D effect */
}
QPushButton:pressed {
    background-color: #4a739b; /* Darker shade when pressed */
    border: 2px solid #3b5a7b;
    box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.3); /* Inset shadow for pressed effect */
}
QPushButton:hover {
    background-color: #6b9ec1; /* Lighter blue on hover */
}
"""
# --------------------- Variables and Parameters Setting ------------------------

SPLASH_GIF = "splash.gif"  # Will be replaced with your actual GIF file later.
APP_LOGO = "logo.png"  # Will be replaced with your actual PNG file later.
FAQ_LINK = "https://ai-videocreator.com/faq"  # The link to your FAQ.
SUPPORT_EMAIL = "support@ai-videocreator.com"  # Destination for support tickets.

SMTP_SERVER = "smtp.hostinger.com"  # Your SMTP server address
SMTP_PORT = 587  # Common port for TLS
FROM_EMAIL = "System@ai-videocreator.com"
EMAIL_PASSWORD = "SyS2025$"  # NEVER hardcode in production!
DetectorFactory.seed = 0  # for consistent results from langdetect
COUNTER_FILE = "sr_counters.json"
issue_counter = 1
enh_counter = 1
com_counter = 1

sys.setrecursionlimit(1500)  # Increase limit, but use with caution
# Override the built-in print function.
global target_lang
default_voice = "en-US-AvaMultilingualNeural"

PLATFORMS = ["facebook", "youtube", "youtube_shorts", "instagram", "tiktok", "720p"]
ALTERNATIVE_PLATFORMS = {
    "facebook": ["youtube", "720p"],
    "youtube": ["facebook", "720p"],
    "720p": ["facebook", "youtube"],
    "youtube_shorts": ["tiktok", "instagram"],
    "tiktok": ["youtube_shorts", "instagram"],
    "instagram": ["youtube_shorts", "tiktok"],
}
YOUTUBE_SCOPES = ["https://www.googleapis.com/auth/youtube.upload"]
CLIENT_SECRETS_FILE = "client_secret.json"  # Place your downloaded file here

#font = "Cairo Bold"
arabic_font = "Cairo Bold"

font = "Arial Black"  # Default
#font = "Almarai-ExtraBold.ttf"
#arabic_font = "Arial Black"
#arabic_font = "Almarai-ExtraBold.ttf"
font_weight = "bold"

#english_font = "Segoe-UI-Black"
english_font = "DejaVu-Sans-Bold"
# Global configuration flags:
PRINT_ENABLED = True  # Set to False to disable console output
LOG_ENABLED = False # Set to False to disable logging calls

# Global variables to store the current log file object and path.
global_log_file = None
global_log_file_path = None

# Save the original print function.
_original_print = builtins.print

# Base64 encoded strings for your icons
video_icon_base64 = "iVBORw0KGgoAAAANSUhEUgAABAAAAAQACAMAAABIw9uxAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAAlwSFlzAAJOjQACTo0BQHqWvAAAAe9QTFRFR3BM50w850w850w8z0Ey1EIz50w8yj4v50w850w85ks750w85ks730c450w850w850w8yj0v50w850w8yDwuzkAxxjst50w850w850w84Eg44Uk550w850w850w850w850w8zj8wwDkrxTstzT8wxzwu50w840o65Us70kEz50w840o650w8xDssyT0vxDosyj4v50w85ks7xzwuzD4w50w8xDssyDwu0UEywjos50w80kEywzos50w850w8yT0u50w850w850w850w850w80UEy40o650w850w850w810M050w800Iz50w81kM0yDwu0EEy50w820Y25Eo65Eo650w82kU2yD0uxzwuwTkrwTkrwTkrxTstwTkrwDkr50w8wDkrwzoswTkr50w800Iz50w8wDkr1kM01UM0zj8x0EEy50w850w84Uk5zkAxz0Ax0EEy1EIz00Iz2EQ140o60UEy50w80kIzzD4wwjos0EAxwDkr20Y3wDkrwTkryj4vwDkr3Ec31UM03kg4wzst00IzwTkr50w850w850w81EIzwDkr50w87PDx6YV6z3hv7O/wwTkr6HBk6rGr5009w0Q369DOyFtQ2qOe4sfF7Obm6ZCH0X5251pLwzos6ODg6eHh51lK6qCZ6YqB68vJLGcftQAAAIt0Uk5TAP7sDJICBOGoWA4gSBLc6Ykm+/b7B/prmS8aKb5Bts9U7zgX0v4YOhxSsRXA/Osg5WIm+Pny6++Pstea/oEyMeHTzFo9eiuhdPFDqW2EhfS5Zgs2RsdQk9XmLPdr0553j5jcoNmS/KnCxp1vbiO9faZlWW8xu5XI3fGscn1Wr6zyes9WiWDGe9p+TFzEGNoAACAASURBVHja7N3PThtXG8Dh2patYAy2bEVgYgMrqAwbI7FBAvFPIQixgDTfNguUVcKuyi2klXzRTdooX9KkLdjvAc2c57mBszjv/JgZZsY//QQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADyyp1u3/dPW+hwUwnrrtH+79dSRO6Pmy3Fn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"

"""
    <base64 string for video_icon.png>
"""

music_icon_base64 = "/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAUDBAQEAwUEBAQFBQUGBwwIBwcHBw8LCwkMEQ8SEhEPERETFhwXExQaFRERGCEYGh0dHx8fExciJCIeJBweHx7/2wBDAQUFBQcGBw4ICA4eFBEUHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh7/wAARCAQ4B4ADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6VooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooqOSaGM4eWNT6FgDQBJRVf7dZg4N1CCOxcD+tIb+zA3faIyPY5P5U0n2CxZoqmNStD9yQvz0VCSPyFSxXUcpxHHcMfQQOT+WKOV9h2ZPRULzhD80NyvGeYHHr7e1M+3W2cF2Uj+8jD+Yo5WFmWaKgF3akZ8+MfU4P5GlF1bHpPF/30KGn2ETUU1XRvuup+hB/z1FO60gCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKYZBhtoaQr1CjOOcdeg/E1HLOELIWiVhgAFtzEn2XP86tQk+g0myekJCgliAB1JOAKRLe8uNwhtrhwSMM2IlHqecn/ACahv2srHc2p6xp1hkj5QRJJgdhk/wAqfIo/Ey4UpzdopsmDbs7EaQqOQqk9ffp+tJMzxbTIIogx4Msyr+PUnFc5qHjTwlAzIP7T1Vj3Y7E/IkfyrNk+I9jFj7B4XtEI+60r5P5Af1rCWJw8N2epRyPHVfhpv8vzOyMim48kXkOSOBFE8p/MAA81JFaTTFlEepyDsVjWIevUkn9K87uvid4jkBFutnbDt5cPI/Mmsi78ZeKLr/W61dAHsjBP/QQKxeY0Vsj0qXCeNn8Vl8z15NIlMR82yjGOjXN4zZ/AAAVH9n02KMrNe+HIhn+NFbB9AWavDbm8vLnP2m7nnz18yQtn8yahPPWsnmnaJ6FPg2T+Op+B7i97o0DFj4p0OPHQRxx9fzNMXxBoMRCv41iyBgCKBBj6YBrxD6Clqf7Tm/snRHg2n1qv7j2qbxT4WIxL4tvjgfwRf4JVO48W+E4yGHiDW5VA5CFxn8sflXkNFT/aNTsbLg/DdZv8P8j1yLxd4TmYEa7rsAz0cuf55/lVy38UeFAQYvFupKT3eI/1SvF6T601mFTsD4PwvSb/AA/yPbz4j0Sb5YvG4yP4ZbdCOfqgpVvdLnbJ8aaNIBxtkgi6+/zA14hRirWYS7GEuDqfSr+B7wv2N1/daz4YnPU/ulB9ez1JHp14Fd0s9NuS33fs948efzBHrXgYUZzxn1xUkUkkTEwyyRk85Rip/PNWsf3Rzz4Nn9mp+B7obW9hhdptM1WNh0ETxzj9CDUE9zHbWweeaeFyfu3FlIuM+pAIryW18R+IbYjyNc1BPQGdm/QkjHtWrbfELxjDjGqrKB2lgQj8wAf1rRYuD3RwVeEsZC/K0z0mOfzCREYZzjIWGVWbHfKkg9aGuokIEu6E4/5aKVHUg8ng9PWuJh+JE07Z1jw9pt6cY8yMeW4/Ehv5itfTfGfhGQRRltZ0cqeFDGWLOD2y3H4DtWqq05dTy6+SY6j8VN28tTpEZXAZWDA9CDkUtZ9nLpWoKBp/iDRrx2kyFmTyZRk8j5SDnr1XrVq40/U4EdxZXYVcFTBMlwrZ6jDYb+fXjNWrPZnmSpyg7STXqTUVWa6WOURTBo3xnEqNER07OACckDAJNThxkA5UnoGGCfpnrQ0yB1FFFIAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooqCS6iU7VJkbHCqCSeMjpTSb2QE9RPcRJIIzIC/90cn1zgc1KtpdSxmabFtCoyXkbYAPzycfUD2rC1PxJ4U0gMDcvqU3eO34TPHU5wR70ScKavUlY6aGErYiXLSi2azyTOwSCMsxGAANx+mBx6dSKfPEbSAXGq3lvYxdC0zjJ9Pl6Z9ufSvPdY+JGrXCmLS4YdNhP/PMbnI9yR+uAa4+8u7q8lMt3cSzyHq0jFj+v1rhqZpShpTVz6fB8I4irrWfKvvZ6jfeM/CVoCkf27VXGBgfLH+pAx9Aaxbz4m3ygppOk2ViueCRvb+nP51wNFcFTMq8+tj6XDcL4GjZyXM/M2tU8VeIdSyLvVrllPVEbYv5LisYnJJJJOck56mkorklUlJ6s9yjhaNBWpxSCiilFJI2YClooqkhBRRRTSAKKKKtIAoooqkguFFFGKpIVwFKKBj1FFUkMKUCgCnAVaQmxKUUUVSRLYUoFAFLVJAIQGGCAR71d0/U9T08n7BqV7aj0jmZV/75zj9KqYpatNrY56uGpVVapFM6uw+Inie3Pl3cttqducBo7qEcjuMrjn6g1vad408NXYCXlre6JKSSzW582EsRgkrg8dD938fXzalxW8a00eLiuGsFXvyx5X5Hs1j5t3EZdKvrDVosgZtpQkgzkElCSMjg4yKDfxxOI7tXtXOflnUx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VlKiuh9Lg+Lq1Oyrxuj5yor1bXfhpZzbpNKna3c8+W/zKfYHqP1rgdb8Naxo7H7ZaN5eeJEG5T+I6fjWLptH12BzvB4yyhKz7MyAKWiikkercKQbllSaN3iljOUljYq6H1BHIP0paKaInTjUXLJXTOu0vxw8kUdp4ptW1CFOEvYPkuYvfjG4euCDxyDXXWVw01mL3S7ka3p3/PWEDz485OHTgkgEdAD1JFeSCpLG5vNOuxeabdy2V0BgSxnBI64YHhhnHBBFbRk+p8nmXDVKpeeHdn26HsVpcwXUIlt5VkX1HUE84IPIOCODzU1cJp3jCwvZVHiBG0q+bganZKfLc4wPNTnA6ZJBHuoFdcLt7cxLfGLy5j+4uoW3QzAjIIbkKSM8E844JzV+h8VicJWw0+WrGxdoo60UjnCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooppLM4ihQySngKD09z6D3ppXegBI6xqWY4HYDqT6Ad6q6xfWGkWX23W5THGR+6tV5klP9O3oBWZ4o8U6f4c3xRMl/q/YZzHb/XHf2HP04J8r1XUb3Vb57y/uHnmfqWPQegHQAegrixWYQw94w1l+R9Pk3DlXG2qVtIfmbninxrqmtq1rGfsNh0W3hOAR/tH+L9B7VzOPagc0o6V8/VrTqy5ps/R8Lg6OEgoUo2QUE0EgikqEjp82FKASRjk9ABXReFvB2s6+4a3hMNvn5ppAQuPbufwr13wp4A0XRFWV4xeXQ5Msg4B9hXdh8FUq62sjwMz4jwuBvG/NLsjyzwv4C1zWyspi+x2x/5ayjBP0HWvU/DXw/0LRwsjxfbLgc+ZKM4+g7V1yqFGAMCl7V7FHB06Xmz8/wAx4ixmNbXNyx7IRVVVAVQABwAMUpopK60jwG7hRRRTEFFBpM0ABNFFFABRRSE0ALmkNIaKACiiigApDQTmigAooooAKKSg0ABNJRRQAUUUhNACmkNJRQAUUUtACUuaSimkAUUUUwCiik60AB+tNdEdSroGUjBBGQfwp1FA02ndHIeIfAOkaiGktV+xTHPKD5T9R/8AqrzfxD4T1jRmZpYDNAP+WsYJH49x+Ne7011VwVYAjGCCMg1nKmnqe/l/EeKwjSk+aPmfNgBz6Ypa9j8S+A9N1LdNZgWdwc8qPkb6j/CvM9f8PanospW7tz5ecLKvKn8e30NZuDR9zgM9w2NVou0uzMjmlpPrS89qaR6MpiHBBBAII5BrS8O67qOgFobYJd6dIf32nznMbc5JU/wN15AwTyQTg1nDjmjOelUkcOLw9LEwcKiPUPD+oWmo2rT6FJLcxxL++0+U/wCk2/f5QT8y44HJ6AAk5A1raeK4j3wuGGcEdCD6EHkH2NeNRPLb3Ud3azSW9zEcxzRnDKfr3B6EHgjIINdro3i2z1CeOPXJE0zVOAmoRriG47bZV6KccZOOmQRwKpo+GzHJqmGblT1idrRVVLiaG5Wz1CIQXBBKEHdHKAeSjdDwQcHkZ6VapNdzxAooopAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRQSMEngdSTVW4u7aKze+u5vs9jGMvIeC/sO/NUlpd6IuEJTkoxV2yfJdHk8xYII8mWdyAqgdcE9T2rhfFvjoLFJpvhwvHE2RNeEYkkPt6D3/l3w/Gniu616UW0ObbTYiRFAp6/7TY6n88e/OeaArxcbmbl+7o7dz9AyThiNNKtild9v8xSSzFmJJJyTnJNLg0AUHpXjn2iSWiCkPWl5yAATmu28E/D7UNaKXd8HtLLqCR8z/QelbUqM6jtE5MZjqGCp+0rSsjldG0q/1e7W10+3eeUnt0A9SegFeueDPhlZ2G261ordXHB8sfcX/E12mhaJp2i2i22n2yxKByerN7k9zWkM969vD4CFO0p6s/OM24pr4tuFD3Y/iNiijhjEcSKigcKowKfQKQnFeifKN31YpptFFMlsKKKKACgmkJooADzRRRQAUUUhoACe1JRRQAUUUGgA6UhOaDRQAUUUUAFJmgmkOKACiiigAo470HpmkNAAfakoooAKKKDQAUGk60UAKKKBRVAFBoJpKACiiigAoopCaAAnNJRRQAVFcwQ3MLQzxrJGwwVYZyPxqWkJpMcZOLunZnnfiv4eJJuudFbYx5MDHg/Q9voa86vLW4s7hre6iaKRTyrDBr6IrK8QaDp2tW5ju4RvA+WRQAy/Q1LSufT5dxFVo2hX1X4ngvfml610finwlqGiOZQpntSfllUdB6Edq5wDiqSPrqWKp14c9N3QUOgdCrKCpGCCMg0uKM1aQpO5q+GvEVzo8S6bfiXUNEJ4hJ3SWvo0ZPOB/dz9Mcg+hWV2iRQyLdpeadcAG0vVPDDpsk/uuDkc4zgjggivKBV/QNYvNCndrZFuLSY/6TZucJJ6kdlb3xzgZBwMS4aHzeZZTGbdSktex60MEcHiisPSNRtmsvtunzSXOkk8hx++s26mNx1288H+YwTtxsroHRgykAgg5BB71m0fLyi4tpqzFooopCCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKRmVFLMwAA5JOMUO6ohdmCqByScAVga3rVpY2/2u/JABPkW4PzSn1PoP88nFGkVzSdkbYfD1MRNQpq7L2pajaWdmb/UZGitFPyoOHmbPQD04/nnpx5b4r8R3niC73y4htY+ILdT8qD+pqrr2r3utXpubuTIHEca8LGPQD+veqArwMbj5V/chpE/TskyCngYqpUV5/kFKOKB0oJGK81I+juBqfT7O5v7tLa0heWVzhVUZJrQ8L+HdR8Q3ot7KI7c/PIR8qD1z/SvdvB3hPTvDloFgQSXLD95Mw+Zv8BXfhcHKs7vY+eznP6OXRcY6z7f5nN+BPhzbad5d7rKrcXXVYiMoh9/U16IiqgCqAB2ApSM/WivfpUYUo2ij8vxuPr42o6laVxaKTNGa1scVxKKKKYgoooNABSE0uaSgAooooAKOlJkUGgANJRRQAUUUmaAFJx0pDzRRQAUUUUAFITQTSUAFFFFABRkd6DgdDTaAFNJRRQAUUvakNAAT6UlFFABSikopoBaQ9aKKYBRRRQAUhoJ9KSgA60UUUAFFFNzzSbAU0UUUhhRRSGgY2VI5YykiKykYKkZBHuK888Y+BAd97oqgHlmg7H/AHf8K9ENFNNo6sJjKuFnzQZ87SxyQytHIhR1OCrDBH1pgr2fxd4Ss9biaaMLBdgfK4HDex9frXkmrabeaXdtbXkTRuDwSOCPUHuK0i0z7PBZnTxcdNH2KlFJxRxVpHY2T6ZfX2k34v8ATJhHPgK6MCY5l/uuO49+o7EGu88OavaX0U1zpCeWEO670wnL27Z5aMn7yEnOMdTxgkgee9aSNri2vIr+xmaC8gOY5F7+oI6EEZBB4IJpSp32PIx+AjXXNHc9lt5oriFZYXDIw4I/l7GpK5Xw7rkN9BJqEEQikQZ1G0Xkx/8ATVB1KnuO3PXGa6iN0kRZEYMrDKsDkEHpg1zNWZ8tOEoScWh1FFFIgKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKCQBnOAKKxfEGrQ2kEm6XaiDMjDHHoB7nt9aata72RrRozrTUIK7IPEOr21pbm5nJMURIRBkGR+w/Q/QZ/Dy3V9QudUvnvLp9ztwAOijsoHYD/69Ta9qk+q3plf5YkyIoweFH9Se5/+tVACvnsfjXXlyx+FH6nkeSwwFNSkvfYgzSijoKDXnpHv3AnnrXUeBPB174kug7BobJD88xHX2FXPh14Jn16dby8DRWCHk4wZPYe3qa9ysLO2sbWO2tIljijGFVRgCvUweBc7TnsfHZ/xIsLehh3efft/wSvoWj2OjWKWdjAsUajk45b3NaAPOAKDnFHbivcUVFWR+bTnKpJym7ti0GikqkjNsSiiimIKKKDQAGkozRQAUUUUAFITQTSUAFFFFABRR0pDzQAE5ooooAKKKTNAAaCaQ80UAFFFHHegApCaD7UlABRRRQAUUHpSUABooooAKKKQ0ALRSClppAFFFIaYC0hNJmigAooooAKKCab160mwSFooopFBRSUhNACk0maKKACiijNAAelZfiHRLLWrQwXSDcASjgfMp9Qa06SmnbYqE5U5c0XqeGeJdBvdDuzFcIWiYnZKBww/ofasj8a+gNU0611Kze1u4hJGwxyOQfUHsa8f8XeGrnQrkkAyWrnKSAfofQ1vTmnufV4DM1XShPSRgdKXBNAFHSt0j0mxbae5sb2K/wBPmMN3CfkbnDDurDuD3H4jmu80DWoZrRr+zhZIFIN/ZDlrRjkmRAOsZIJIA4wSBwQOB9alsbu706+j1Cwl8u5jyASMq6nqjDPKnAyPYEEEAjKrS5tUebjsHGsrrc9gikjmiWWJ1eNwGVlOQQeQQe4p9cr4e1m1ltWv7FDHab8XdoTlrOQ9SPVCckEYB5IwQQOpRg6hlIKkZBHQiuNqx8zKLi2mhaKKKQgooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKp6repY2xkJG48KM9SaaVyoRc2kt2VNf1RLOFkVwH25Ynoq9ya8t8QatJqU+1WIt0Pyqf4j3Y+pP6fnVnxTq8t5cPbJLujDZkZeA7Dt7gdP19KwgOPSvEzDG879lT2/M/TeH8ljhKaq1F7zFAo6UE8UleSkfUBXcfDbwTNrs6318rR6ejA8jmQjsPb3/yIvht4Ol8QXgurpWSwiYbj03kfwj+pr3e1t4bW3S3t41jijUKqqMACvWwOC5/fnsfF8R8Q/V08Ph37z3fb/giWlvDa26W9vGscSABVUYAAqftSDpR1Ne3a2iPzdycndu7FpM0E0lNEsKKKKYgoopCaAFzSUUUAFFFGeKADpSGg0lABRRRQAUGg0lAAaKKKACiikzQAE0lFFABRRSE0ALSZopKACiiigAoJoNJQAUUUUAFFFIaAAmkoooAKUUlL0NNABOKTrRn3opgFFMkljjBMjqoHUkgAVl3viXQrPIuNTt1I6gOGP5DNTdLqbU8PVq6Qi2a9ITXF33xI0GEEQC4uCOPlTAP4kisO++KE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oAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACszX777Hak7wvBJJ7YHX6Y5/AVouwRCxOABXmfxA1gzzmzjfOSC/PRew9iTyfbFZ1qyoQc2erk+XyxuJULaLc53Vb+W/ujI5byxkIpPQZ6n3PU1TPWgmkr5ec5Tk5M/XqNKNKChFbBUlrBLc3EdvAhkkkYKqgZJJOMVHXrnwc8J+VENev4/3j/wDHujD7o/vVthqDrTUVscObZnDL8O6kt+nqdT8PPC0Ph3SFDgNeTANM/of7ua6rvRRkZzX0sIKEVFH43icTUxNWVWo9WLSUlFaHM2FFFFABQaCaTNABRRRQAUUUmaAAmkoooAKKKCcdKAA0ho60UAFFFFABSZoJFJQAH2ooooAKKKQ+9AAaSoLq9s7VS1xdQxDHJdwP51g6h468M2ed2opKwOCsQ3fqKlzjHdnTRwWIrP8Adwb+R0tFedX/AMVtNjyLPT55z2LkKP0ya5/UPilrc+RaW9tbDtkbiPxJrGWKpx6nr0OGMwq/Yt6nspOB1xVe5vbS2UtcXMMQHXe4H9a8C1Dxf4ivcibVJ1U/wodg/TFYs8807FpppJGPUsxJP51jLHLoj2aHBVWWtWpb0Pe77xv4Zswd+ppIw/hiBc/pXP3/AMVNLjJFnY3Ex7FiFH9TXkPU0AVk8XUex7NDg/A0/jbkzv7/AOKOsSgi1tbe3HbILH+lYF/4y8SXv+t1SZVP8MeEH6YNYA60uKzdWb3Z69HJ8FQ+GmiWe4uLg5nnklPcuxJP51FiilFSrvc9CMIxWisApRRSgVSRVxBTqKAKaQgpcCgUVaQmFKKAMUvWqSJbEFKKXAoqkiQpQKBS1SQBRR1pRirSE3YTHtS8DtR0oFWkZSmJS0dqUDOOapI55z0PcfAqbfC1iP8AY7fWtusnweNvhqx7ZiBx9a1a1Wx+R4x3xE35sOtFFFBzBRQeKQkUABoNJRQAUUUE0AFcr8QPDq6vZG5tkH2uEfKQOXA6g/0rqaCM9aunNwkmi6dSVOSlE+dpAyOVcEMpIIPUGmGu++KHhzyJTrFnHiNj++UD7pPf6GvPiRX1OEca0FKJ9DTrqrFSQpPvTYbiaxvYtQtUWSWE/NG2CssZ4ZGBBBBHqDg4I5FITzTc5r0XhY1YOEloRNqSaPVfB1/HPbJBC5ktHQS2UhUgmPOChOSNyHgjOcY4GDXQ1494R1I2Worp5dY1uJd9pIwJEdxjG0kEHa44I5GcYGSTXq+l3qX9os6KUYfLIjAhkcHDKQQCCD6j0PevicZhZ4aq6cjyKsOSRaooorlMwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooqOeQRxFm4Ayc+gpoaTbstzG8XarHYafIzEZAIAzgtnoB9Tx9Aa8juJnuJ3nlYs7nJJ9TW14z1c6lqbRo37mE7Rg8FuhP4dB+J71g18/j8R7WfKtkfq3DuWLB4dSkveYUUVNZW015dxWtuheWVgqrjk5OK4opt2R785qEXKTskdJ8NfDTeIdbXzVP2KA75jjg+i/jX0FDEkMSxxgBVAAA7CsbwVoMHh/Q4bOPBlI3Stj7zd63M56V9JhMOqUPNn4/n+avMMS2n7q2/zEooorrPBCiiigANITQaKACiiigAozSE0lACmkoooAKKDxSE5oACc0UUUAFFFIaAFpCaCaSgAooo470AIzKoJY4AGSTwAK4rxJ8R9H0uZre1U306/eCHCj23d/wrn/i34vlE76FpspVVGLh1PJz/AAg15eSScnrXn4jF8r5YH3OR8LRr01XxWz2R3+ofFLWZifsttb247HBY/mf8K53UPF/iO9J87VZ1U/wodg/TFYVFcUq9SW7PsqGT4GhbkpIkmnnmcvNNJIx5JZiT+ZqPNFAFRq9z0IwjHRKwAUoooppF2ClFApRVJA2IBSgUuKKpIlsBRSilxVJCExS0Clq0hXDilopRVJCuIBS0UoGapIVxBzSilxjtQKpIlsBS0UtUkISlApQKKaQBRQOaXpVpEuSDFB6Yo96B9K0SMZTD0paB1oPQ1SRhKQv4UIMsPcgCk7U+P76+uRWiic9Seh7t4ZXZoFiP+mK/yrSqnoi7NItF9IV/kKuUH5RXd6sn5hR0pCcUGgyA0lFFABRRSE0AKT6UnfNFFABRRSE0ARXcEVzbSW86ho5FIYEcHIrw3xlosmh6vJbHJiY7omI6gn+Y6V7sa57x3oS63ozoqj7TEN8R7k45H416eV4v2FVKWzOjDV3TlboeHE0hNLMrxSNE6lXUkEHggjqKjJ4r9ApU09Uem5jLlFmiaM5AIwCDgj0IPYg13fgLxD56me5kVZVK2+ojLAB8YjmAwQAw4PQZHTAzXCFqLG7TTNXiv5sm1dTb3qgDmJyAW6HlThhgZ4OOteXn2WqvQ9pFe9H8jnqJSR79RWV4Zu3uLA29w+64tW8uQnOXAAKvzzhlIOfXPpWrX56cTVtAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArlfiDqhstKaOJiJZvlXBwQO5/mfyrp5WCoSTgYyT6Ad/yryHxrqR1LWpNpBihJRQOnuf6fhXLjK3sqb11Z9Bw5l/1vFptaR1MMCiiivnbH6ulYCa9V+Cnhrcz69dx8D5bcEdfVq888MaVNretW+nwg/vG+ZgPuqOSa+k9Ms4dPsYbO3ULFEgVQB6V6eX4fmlzyWiPjeLc19hRWGg9Zb+n/BLNFFFe4fmQUUUUABpKKKACiig8UAFITQTSUAFFFFABQaCcUnWgAJooooAKKKQ0AGaSiigAoooJAFABVfUJHjsp5EwGWNiM+oBqeoNQ5sLgesbfypS2NKVnON+6PmnUpXn1C4mkYszysSSck8mq9OnyZpDjBLEnH1pteA9Wz92pJKnFLsFGKAKWhIsBRRS9aaQ9hKUCjApatITYAUoooqkhNhSgZoApapITYUoFAFLVJCCjFAFLVJCbDFFKKUCrSE2IBSigdaWmkS2AFFFOFUkIQCl6UUDmrSE3YKUetHsaD+lWkRKQfSj86BilHWrt2MJSEpffFB4pe3NWkYSkH6UnelxS9KtRMJTExkU+EZlQerD+dNqWzXddRD/AGwP1q0jmqztFnvmnDbYQL6Rj+lT5qO2GLaIccIOhz2p/WoZ+YVHeTfmFFFFIkKM0GkoAKKKKACiimmgBSaSiigAoPNFFAHknxa0D7FfLq1smILg/vQOiv6/j/SuAJ96+i9e02HVtKnsZwCsinBx0PYj3Br591Sym0/UJrSdcSRMVI+nev0Dh7H+3o+yk/ej+R20Kl42ZWxSOquhRgCCDkEZBzS9aBX0TV1ZmzZ1vw11hoFjinY7rMraXBIxuhYnyZDgAfKcqSSTjJr1KvALe7TTdTg1CVd1uQYLxQOsLnBPQ8qcMMDsa9p8MXr3NgYJ33XFsRFIx6uMAq/POGUg59c+lfl+c4H6niZRWz1Rz1F1NaiiivKMgooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKbIdqE5APYntQBg+N9UGnaNKytiWQeWgB5ye/wCf8jXkXXrznrXRePdUOoawYY2JhgGwDPBPc/575rna8HHVfaVLLofq/DeA+qYVSa1lqFHHeitTwrpUmta7a6fGCQ7jefRRyT+VcsIuTUV1Pcr1Y0acqktkeo/BTQPsmnPrNxHiW54iz1CD/P8AKvSahs7eK0tYraFQqRqFUD0AqavpqNP2cFE/EsyxssbiZVpdQoopCa1OEU0lFFABRRSE0ALSGg0lABRRRQAUGkJooAKKKKACikNBOaADNIeaKKACiikJ4xQAE0GkooAKivB/okw9Ub+VS1Hdf8eso/2D/Kk9jSl8cfVHzFcD9/J/vn+ZpgqW6GLuYf7ZH6mo68FrU/dqesF6C9qSilAppGmwCloHpS4qkiWxAKUUUuD3qkgbClAxRSgVaQmxBTqKAKpIQUooFFUkJsKUUAUvNUkS2FApQKKpIlsKUCjFLVJAAFFFAFWkJuwD60vAFH+c0Ae9WkZSmH1o7cUdTS1aRhKQCjPPFL1FGKtRMJSACigDmlAFaJWOeUwxxR16UYo4qkjCUwFWdMG7UbYDvIo/UVX61d0Fd+s2i+syj9RVpWRy15+4z3eIfIv0p1IgIUZGOBSk4rnPzl7hSE0E0UAFFFFABSE0E0lAAaKKKACiiigAozSE0lACk15l8YtD5j1mBMZ+SbA/In+VemVV1exi1LTZ7OYArKhU57Hsa78txbwmIjUWxUJOMkz5zxSMDVvU7OWw1Ga0mBDxOVOR1wev0NVjj0ya/UITU4qS2Z3XvqRSIskbIwBVgQQehyK6n4Ya1JCYbedjutZVsJyc4aNgTC5wAMggoSTnn6VzIFGmutrr8TsxWO+Q2kjbSwViQY2wCOQ4HPoTXg8RYP2+G9olrH8upm2noe/UVR0G9/tHSbe6ZdsjLiRcY2uDhhg8jBBq9X52YhRRRQAUUUUAFFFFABRRRQAU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WfrWh6fqtq0E9vGGI+V1UBlPqDTVRdjljn6crSjZHhfpSgY+tanifRpdE1NrSRhIpGUYDqD0/GsuuqNmro9VVozipRFJ9a3fAS7/ABTZ8Zw2fyBrBBro/hwufFVufQMf0NVKNos5cVP91L0PYqKKaa84+PFJpKKKACiiigAoopMmgANJSnmkoAKKKKACiiigAoNITRQAHnOe9eKfEfSzp3iSUquIpx5inGB7j869rriPi5p/2jRI75R81u/zY7g9f1xXt5DivYYtJvSWg07Hk3UYplPphHNfoqYpS6lLUZFs5bbUim5baUGVdgYtEwKuMH1UnntjPavafAN21x4djhkYtJaO1sxII4U/L15+6V5rx+4jE1vJE2cOpU49CK7X4Makzo1jMzb5IA4DEEl4yY3PA7gKeTnHtXw/FOG5asay6mtKXNBrselUUUV8oMKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopHOxGbGcDP5UAcH8T7v8AcR24I+d+R6gf/XArga6Hx9c+frPlBsiJcY9z1/kK56vDxkuaqz9a4dw/sMBDTfUKu6DZNqOr21mgJ82QKcdhnk/lVKu7+CunfavE73bAlLaMnp3PT9Aazow55pHdmeJWFwk6vZHtVnAlvaxQIoVY1CgDtipqKK+i20PxGUnJtvdhRmkJHakpkhRRRQAUv1pKQ0ABooooAKKKQ0ABpKKKACiig8UAFIaDSUAFFFFABQaCaSgAooooAKKKQmgAzSN900UHofoaBx+I+cvEI/4n18B/z3f+ZqgK0vEoA8Q34z/y3f8AmazgM15LWrP3LCv9xD0ClpaKaRuFKKBRVJCbClxQBSjmqSJbCgClAxRVJEhSgUYpeM4FUkK4Cip7azu7kgQW8spPQKhP8q2LLwd4iu8FNOkQHvIQo/XmrUWc1XGUKK9+aRgijHpXc2Xw21NwDdXcEI7hcsf6D9a27L4babGQbq8nmPcKAo/qa0UGeRX4jwNPRTv6HlfWnxQyynbFG7nsFUk/pXtll4P8PWoBXTo5D6yEt/M1sW9na24CwW0UQHACoB/KtFE8evxbSX8ODZ4hZeGddu8GHTZ8Huy7R+ZxW3ZfDvWpgDPJb24PYsWI/ACvWuB2FIaaSR5FbifFTvypI4Cy+GtsADd6hJIe4RQo/M5rasvBHh+3wWtGmI7yOSD+AwK6WimeZVzXF1fimynaaXp1qALaxt4sdCqAGrYAHQAfQUtB9M0HDKpKT95sQ0h5oooJCiiigApCaDmigDzH4trjVLdsDlM/y/wriDXc/F4g6hZgEZ8s59eoxXC5r0qEbwR9Rgm/YRDPpXU/DAZ8UIf7qMf0rlc9a674VKT4gZhztib+YrerG1NseLl+5kermiiivGPlUFFFFAwoNITRmgANJRRQAUUUUAFFFBoAKQmjrRQAUUUUAFUtbtFvtJubVhkSRkDpxxweau0daunNwkpLoB86XMLwXMkDghkYqR9DUTgYrpPiJYfYfE04VcLLhx+PU/nXOkcEV+p4Wsq1KM11RzynZkYHPNWfAl4ul+LowfkjNypOHIyJQUJIJxgOqnI9frVY1Qv3eDUbWeNljeQNCGI5DEbkwccHco+uea83iCh7XBtrpqVhan7yz6n0TRVPRr1dR0m1vo1KrPEsm0nJXIBIPuDx+FXK/ODsCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoo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Tix+Kli5bAmdcjoTuR0AB9zt/QV77X5fmdP2eLqR8z6ihPnpQl5f8AKKKK4DQKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvKviHMZNUVeDgE4HbJr1OVisbMOoBIz9K8d8WyF9akUnIRQAa5sU7Uz6Thanz49PsmZFFFAryUj9SPRPgXbh9du7kg/u4dvTjk/8A1q9lrzH4DQbbLUJ/7zqgP0Gf616ceK9rCxtTR+RcT1efMZrtYDSZo60V0HzwUUUUAFIaCfSk60AFFFFABRnAxSE0lAC0lFFABR0opDQApNJRRQAUUUmaAA0lFFABRRRQAUhoNFABRRRQAUUUUDW54H44yPFeoD/pqaxwK3PHgx4u1D/rqf5CsOuGS1Z+05frhafogPpXrPwbI/sCf184/wAhXk4FesfBv/kBXH/Xb+grWkvePG4p/wBwfqjuaKKK6T8wCig0maAAmkoooAKKKCaAAmkoooAKKKQ0ALSGjNJQAUUUGgAoJpCfSigA75ooooAKSgnFJQAGiiigAoooPSgDxv4nPv8AFc/sigY9hXLGuk+JQI8W3XfgY/KuayRX2eDp/uYs+gou1NATXqPwcXGlXb+suP0ryxuv1r1n4QJjw/K3rMf5Css2VsKc+Nl+7Z2tFFFfInjhRRQaAA0maKKACiiigAooooAKKKQ0ABNJRRQAUUUUAFFFFABXknxNh8rxQ74wJEVv6f0r1ok9682+LUONQtZ8DDIVJ+h4/rXucP1OXF27o4cev3TZwzDg/SoQOKnxmoSOTX30WfN1Khgas/2Xxbo91gk7wcg4+46sPr0J9+lfSCk7RnqQM181eN/k+wTgEkSsoweeUY4HvkCvpCyk820hkOMvGrHByMkA9e9fnnEEOXGyfex9Tlc+fCR+ZNRRRXineFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAEN5gWk24gDY2Sfoa8Y19i2sXJPOH/lXsmpkiwmOcEL1rxbVWDalcN6vXJjPgR9fwfG+Kk/IrCl6UUvavOSP0bY9p+CMQTwxLIOsk5P0xx/Su9rkPhCir4NhK8Euc115Fe1RVqaPxbOp8+PqvzCiiitTyxDSZoPNFABRRR2zQAUhPGKDSUAFFFFABQTig0lAAeaKKKACg0U2gBSQRSUUUAFFFFAAfakpaKdgEopcCmniiwC0UUUhpBRRSE0DR4X8QRjxdf/AO/n9BWEK6H4ij/irr33YH9BXPVyyXvM/Zstf+yU/RfkB6V6t8G/+QHcf9dj/IV5V2r1T4N4/sW6/wCu5/kKumrM8jih/wCwv1R3dITQfakrc/MAooooAKKCaSgAJOfaiiigAoopDQAGkoooAKKKCaAA0nWiigAoooPFABTTQaKACiiigAoooNAAaQ0ZpKYHifxEcnxXecg4PGPpXOZNbfjh9/ii+JOcPgfkKxM/pX3+Dp/uY+h7lN+4kBOOK9g+Ey48L5x96U/0rx0nFe0fC5AvhKHAwC5P61xZ6uXCr1OXGP3DqaKDSV8YeaKTSUUUAFFFFABRRR0oAKQmg0lABRRRQAUUUUAFFFITQAppDzRRQAVwfxajzb2cuOAxXp7V3lcb8VkLaLA+OBN/MGvTyeXLjIHFj/4EmeZD2qFhhj9asAVA4w5wO9fosdz4ypUOb8eqTYWjDI23KgcdMggH9T+dfQPhiUz+G9MnYYaS0icj0ygOP1rwLx2QuiI5z8tzEQO2dw6/hmvcfh5IZPA2iszBmFnGpIHHCgYGfp17+g6V8LxIrYpPyPrchnzYT5v9Deooor549kKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAKetEjTJ/90DrjuK8WvDuvJmH98/zr2rWf+QXcf7hrxa7GLuUejn+dcmLXuo+y4Ot7efoRAUuKAKU9K4kj9BbPfPhUmzwVZ9s7j9ea6muc+Gwx4L073jz+ddEa9mn8CPxPM3fGVH5sQ0lOpDV2OASijFFIApDQelJQAUUUUAL2zSE0EZpKACiiigApD0paKaQCE5pKKKQBRR0oppAFFFFMAooJpKTYWA0UUUigoopDQAZFIaKKAPEviOMeLrvPqD+grnRXS/EsY8X3f/Af5Cua5JrC12fr+Wz/ANjp+iDnpXqfwcP/ABJrof8ATb+gryz2r1L4OcaRd/8AXb+gq4rU8niWV8C/kd3RRRWh+bBQTSGigAooooAKQ0pNNNAB1ooooAKKDSEkmgAJooooAKKKaaAFJpKKKACiiigAoopDQAE0lFFABQelFB4+g5prcDwTxex/4SS/zx++YfkcVkk89K0fFUgfxDfNgAmdgceoJFZZOR6V+mYSn+6j6HswfuoUn3r3D4cLt8I2h7sCf1NeGk817v4CXb4TsB/0zz+ZNeTxIuXDR9TkxTvFG6eaKKK+IOEKKKKACiikJoAWk60lFABRRRQAUUUUAFHSgmkoAD9aKKKACiiigArlPifz4fXjgSj8/wDOa6uuY+JYB8NsSORIuPzruyx2xUPU48f/ALtP0PKhUMn+sNT45qNx85r9Ii9T8+q1NDm/iASvhid/7joSPXDD+uK9m+FEgk+H2kMGz+5xnOejEf0rx7x4oPhi5zn7yAY9S4H9a9h+FChPh5oyhQP9HDEAY5JJP8/zzXxXEv8AvEfQ+x4ZnzYWX+L9DqKKKK+bPogooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAq6qCdOuAM/6s9OvSvF70D7bKD13HP1r2vUf+PCfpyjA5Ge1eMakAL+X03VzYle6j6/g9/wC0z9CtSigDNLXGj9DZ778NGDeDLDHZMHn0rpK5b4Vkf8Ibac55b8OcY/SupPWvXp/Cj8UzRWxlRebFpDQaTrVnAKTSUUUABptO6Uh60mAh9qKOlFCQBR1ooJpgIRRRRSsAUUUhpgB4pKCSTRSsAUUUUwCgmkNFJsaQlLRRSGFIeKDSZoAM0UUUAFFBpCaAPGPiaP8Air7r3C/yFcx9K6n4oDHi2f3Vf5CuY5rNrU/Vstn/ALHT9EJ0r1D4N/8AIJvPaYfyFeYH9a9O+DhI0u9/67D+VWlZHmcRSvgpfI70mkoopn54FFFB4oAKQkUGkoAKKKKACg0hNFABRRRQAUfWkJpKAA0UUUAFFFFABQaM0hoADzSUUUAFFFFABQ3KntkH+VFNmbbE7f3VJ/SqjrIEfPWvMW1m7OSczNyTknk1RJ496saq5bUbhvWVj+pqoSScV+s4eCVOPoereyQuckfXmvf/AAcNvhqxXp+6HGMdRmvAUHzAepr6E8Nrt0GyX0hX+VfN8VS/dQXmcmIldaGjRRRXxByhRSE0hoAUmkoooAKKKKACiig0AFIaMmigAooooAKKKKACikpKAFJrmfiT/wAi0/rvXH510tcr8TTjQVGOso5/Wu7LdcVD1ODMpcuFm/I8yAyKik++e1WAM1C4+c1+jRep+ZVamhzvxAOPDEoGAWkix7/vFr2j4bIsfgLQ1XO37FGwyecFQRn35rxP4iHGgKOxuIvx+YH/AOv+Fe4+AU8vwToqHtZRf+giviuJH/tK9D7vhR3wcn/e/RG5RRRXzp9OFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAEd1/wAe0oPPyH+RrxfVlxqMw9GOBXtbAMpX1BrxzxDEY9WnU/3j/OsK6vA+o4Tny41rujOpQKKWuNI/Sj274Qyb/CKDJO2Rh9Oc12JrgPgrPu0G4hz9yX+grvq9Sl8CPxrO4OGPqLzA89aKKK0PKCikJxSd80AKaSiigAooNBOe1AAaSiigAoopCaADNJRRQAUUUZoAKTNB5opNjSCiiikMKQ9KCc0lABRRRQAUGg02gAooooA8e+KY/wCKrl/3EP6VyuO1dZ8VR/xVT+8S/wBa5TFNI/TMun/slP0Qn0r074O4/s69/wCuo/lXmXHrXpvwe/5B97/10X+VU1ZHn59K+EfyO8oopCag+DAnFGaTrRQAUUUGgANIeaKKACiikoAWmmg0UAFFFFABRRQTQAHikPSg0lABRRRQAUUUUAFFBpKAAn0pk5xBIf8AZJ/Sn1Bfttsp29EJ/Srpq80gPna/Ie9mYEEFyQQMZ59KiA9qkmy0zEkkliST9aQD0r9bhpBHTOrZWHQKDKgJ6sB+tfQukLt0u1XGMRKMfgK+frRN1zEPVwP1r6FsV2WUKnsi5/IV8nxVL3aa9Tlc+Zk9ITQaSvjRhRRRQAUUUUAFFFISe9AATRRRQAUUUUAFFFFABSEjtRntSUAFFFFABXI/FBsaRbJn702ceuAa66uI+KcmUsovdmI/IV6WUR5sXA8nO58mCmzgwM1Ewy5+tWDgdKrNyT9a/QIs/K6s2zlfiT/yDLVRyDcLkDqcAn+lfQXh5DHoOnxnGVto1ODkcKBXz549DTz6TYoCZJrn5T6HG38ssPyr6OgjEUEcSgBVUKABgAAYr4fiCSeKsfpfCkWsAvVj6KKK8I+lCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAryjxzCIddmGCMsSOOoPP8AWvV682+JsQTV0kxgOoOR64x/Ss6qvA9rh+r7PHw8zlRzSgUCiuNI/Vrnp3wPnIOoW5PGFYD06gmvT68a+DVx5XiaSE9JYDx9K9lrvov3D8p4opcmYSfewUhNBpK2PnQooooAKDQaTNAAaKKKACikNJQApNJ0oooAKKKTJpNgKTSUUUXGkFFFIaQwNBpOtFABRRRmgApCaCaSgAooooAKCaCaSgDyP4rA/wDCUk9zCp/nXJcmuu+K/wDyM4z3hX+tcj0rWKuj9Cy+f+yw9Ba9L+D3Nhff9dF/ka8z/GvSvg9/x433++v8jVSWhxZ1K+FaO+PXFJRRWB8UFFFITmgAJooooAKKKQmgAJpDRRQAUUUUAFFFJmgANJRRQAUUUUAFFFBoAKCcUZpKACiiigAqprLbNJu29IWP6GrdZvidgnh6/bOMQN/I1th1erFCeiueBSD962BgZ4/OkApx5Jx60oFfq62OapV8yxpilr+AY5Mg/nX0DCAIUA6bR/KvA9DTdrFoPWZf5ivfUwEUYwAP6V8dxQ/egvUMPLmuLRRRXyZ1BRRRQAUGkNFAAeaKKKACiiigAoopD7UABpKKKACiiigAooooAK88+J0obVbaLP3Ysn8Sf8K9CJry3x9N5viWYA8Iir+Q5/nXtZDDmxV+yPnOJ6vJgrd2YLnAJqv1GalkPymoc19zE/Mqj1MIxf2h8UfDljtyIpRK3POAwbj14jNfQleE/DqE3/xpkk4K2NsSBnkfKB/7UP6Cvdq/PM4qc+LkfrvD9L2eApryCiiivMPZCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArhfipDlbWfpg4PHXB9fxruq5r4jWv2jw8zgZMTAj8aT1TR1YKr7HEQn2Z5kOnFKKSI5QEjBIH4U4Vx2sfscZKUU0b3w/uvsniyylJwGfyyc9m4/rXvZJJ9q+bLKY297BOvBRww/Ag19HWUyz2kUynKugYH8K6qGzR+fcY0bVYVV10JaKKOldB8WFBpDRQAUUUUAFIaCaSgA60UUUAFBNBOKSk2FgNFFFIoKKKaTQAuaSiigAoopCaAFNNo75ooAKKKCaACkNB65ooAKKKQ0AeUfFn/AJGSM+sA/ma4+uy+LYz4hiOOsA/ma4zvXTBaI+5wErYWHoB6V6V8Hv8Ajzvv99f5GvNu2K9J+D/Frff7y/yNOovdOTNpXwzR3tBNBNJXKfIh1ooooAKSgmkoACaKKKACiiigAooPSm0AKetJRRQAUUUUAFFFITjgUAKaTrRRQAUUUUAFFFFABWP40fZ4X1A5x+5I/pWuTXNfEmcQ+FbgZGZCEx65NdWBjzYiC80RUdotnjA604DmgD0p2K/UjxalU0PDCbtfswOvnKQPxr3Y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6tgIfP8AMKKKK8w9oKKKKACikzSUAKaSiigAooooAKKKMigApDRRQAUUUUCMTxpqAsNDmKkCSUbF55GeuPoM15OTXTfELU/tur/ZkbMVuNvXgseSf6VzBNfeZNhfYYZN7vU/JuJsw+tYxqL0jp/mNbk89Ko61eLY6bNccFlXCAnGWPAH5kVcJyao2tj/AMJF4x0/QlwYYj591xkBR2Ppkcf8CFduPxCw9CU2eblGCljsXCl56+h6J8IdCOi+EopZlH2q9P2iViBk5GVBPsDnHqTXZUiqFUKoAAHAHTFLX5rOTk3J7s/b6cFTiox0SCiiipLCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigDkPifpZutKTUYR+9szk4HJQkZB9v/r1wMTCSNXA4YD8K9qniSeB4ZAGSRSrAjqCMGvGL+zfSdbutLkJwjExE/wASnkfpj9aaR9Pw5jfZzdCT3EqexuJLS7iuYjh42DKR9c1D+FFWon1tRqUWnsz3/QNQj1XSbe9jIIdRuA7EdR+dXzXl3wm1vyLqTSZ3+SX5osngMOo/H+leodaGrM/M8xwrwteUOnQKKKKRwhQaCR2ptACkkmkoooAKKCcUhNAAaKKKACijpSGgANJRXLeMvFsGjoba2xLekcDqE9z7+1VGLk7I0o0Z1ZcsTe1PUrLTYDNe3CRKBxk9fYDqa4fWviLgtHpVsMdBLL/MAf1NcNqV/eajcm4vJ2ldieSeAPQDsKq11U6C6nvUMspwV56s1dT8Q6xqLE3N5IQRgqpwv5CspmLHLEk+5zSZ5oPX+tdkKSXQ7lGMNEgJpCTQetNJPrXV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bN7CH60hrSstC1W8YeRZS7SfvMu0D8TXRaX4Encq9/crEOpRBkn8elcdbMMPQXvyO3DZVi8S0oQZxsMUk0ixxRs7scBVGSTXbeGfBrFlutWGAOVhB5P+8f6V1ek6Lp2mJi1t1VyOXblj+Jq+TXzmOzydVOFHRH2GWcMQotVMQ+Z9ugiIsaBEUKqjgAYApc0ZpK+fbvqz6xJJWQUUUUhhRRRQAUUUhoAUmkoooAKKKKACiikJoADQeaSigArk/iDrYs7P7Bbv+/mHzkHlV/8Ar1v61qMOl6fJdzEYUfKO7N2FeQaleTX97JdTsWeQkn2HYD2Fe9kmX+3qe1mvdR8jxVnCwtH2FN+9L8EQU09falOe9IemSQB619utD8rbuUtYvl0+xecgGTpGpONznoP89ACa9B+E/h9tJ0H7ddLm+vsSSMRyF5IHtnJP4gdhXH+BNE/4SfxCdRuU3aVYnEanpI/rjuD/AC/3q9jGAOBxXw2eY/29T2cHoj9Y4Tyf6nQ9vUXvS/IKKKK8A+wCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAqhr+lW2s6XLYXSjbIPlbAJVuxHuKv0UbBseJmC4sbyXTL1Ss8Bxk5w69mH14qT8K734h+H21KyGo2Sf6faglQP407qfU+n/ANevPradZ4g44PRlPVSOoNdtKakj6jAY320OWW6Ja634deIv7MvRZXTn7LO3BJ4RjwD9D3rkiaAcHNaOKkrHTiKUa0HCR9DAggEEEEZBHcUtcN8N/EwuoF0q9cCaMfumJ+8o7fUV3BOa45RcXY+Or0JUZuEg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AAkGrW7C0hOLWFxwxB5JH1Az6kAdjn1io7aGK2gjghjWOJFCqqjAAHQCpK/OsRiJ4io6kz9twWDp4OjGlTWiCiiisDqCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigClrel2mr6dLY3iBo5BwR1U9iD2INeR3trdaLqbaVqAyRkwy9pEzwfr7f5PtNYvjDQLfxBpbW0mEnTLQygco3+B7itaVRwfkdOGxEqErrY8wPFITVbdc2d7JpmooYruI4IPRwP4ge+etS7s172HhGcU0e6qsZxumaWgazdaNqC3dsxxn50J4Ydwa9n8PaxaazYLc2rDOPnQnlT3BrwQmtLw7rl3od+tzbMSpOHQnhh6H/ABrTEZf7aN47nBjMOqqutz3ukJ/Oszw9rVnrdgtzauM4G9CeVPoa0q+enCUJOMlY8Npp2aCiiioEFFFGaACmSokqGORQyEYKkZBHuKd1pKadtUBwnib4e210zXGkyC3kOSYmyUJ9j2rz7VvD+r6Y5F3ZSqo/jUblI9iK98pHRXUq4DAjBBGRXsYTOq1BJS95HTTxU4qzPm48Eg8EHkYppr32+8M6DeEtPpluW6llXafzGKzpfAXh1jkWzKPQN/k17lLiPD296LRt9bi+h4lnmkJxwa9oHw98OKSfJmJPrIcCpo/AnhtSCbIuR6uf/rV0/wCsuES2YniYniABJ55qzaWN3cttt7WWUk/wISf0r3a18NaDbEGLS7YEYwWQMf1rTihhiULFEiAdAqgD9K5avFUbfu4GMq7Z4xpXgTXrwAvbi2UjrKcH8utdnofw60y0Ky38rXjjHy42oD9OpruKK8XE59i691ey8jBtsjtoIbaJYreJIkXgKoAAH0FSUUhNeNKTbu3diAmkoopAFFFFABRRRQAUmaCfSigAooooAKKKKACikJpDzQApNJRRQAUUUUAFFFITQAtITSUUAFFFFABRRRQAUGg0lAAaKKKACiiigAoopCaAAn0pKKKACiiigAoorM8Q6zbaPaGWUhpGB2Rg8t/9b3rSlSnVkoQWpjiMRTw9N1KjskHiLWbfR7MyysGkIxGgPLH/AAryjU7651G8e5uXLMxyBngDsB7U7VtRudTvGurp9zMeB2UdgKpk191lmWRwkOZ/Ez8iz/Pp5lU5Y6QWy/UMikpaqsl5qV8ukaShe6k++46RL3JPY4/L34z6FfEQw8HOb0PHwWDq4ysqVJXbIo4bvX9WXRNMyQTi4lAOFHcZHt1PoQByRXs2g6TaaLpkdhZR7Y0GSSBlm7k47/yAAHAqp4Q8OWPhzTFtbZd0rfNNKR8znv8AhnPH4nJJNbVfnuYY+eMqOT2P2nJcopZZh1CPxdWFFFFcB7AUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQBz/jPwxa+IbMciG9jH7mcDkH0PqK8skW6s72TTtRjMV3GcYPRx2YHuDXudYHjLwzaeIbIBj5V3ECYZ1HKn39QfSu3B4uWHnrsb0K7pPyPLCccmmE0ydLqwv5NN1KIxXUfr0cdmU9wf89wAmvuMJyVoKcNj0faKWqNPQNZvdEv1urSQjBwyE/Kw9CK9n8LeIbLX7MTW7hZlH7yInlT/AFHvXgZbNWNK1O70u9S7s5WjkQ5yDwfYjuKnH5NHFwvHSSOSvSVRX6n0bRXLeCvGFnr0AhkKwXqj5oycBvUr/hXUE18NiMPUw83TqKzPNlFxdmBNJRRWAgooooAKKKDQAUhNFFABRRRQAUUUUAFGaQnFJQAppKKKACiiigAoopMigBTSZoooAKKKKACiikNAC0hNGTSUAFFFFABRRRQAUHikJoJoADSUUUAFFFFABRRQTQAGkNBooAKKKKACiijjvQAUhoJpKADNFFFABRRRQAUUdOtc34r8TwaWhgtyst2RwAchPc/4Vvh8PUxE+SmtTkxmNo4Ok6lWVkXPEuvW2j2x3EPOw+SMHk+59BXluqX9zqN21zcuXdunoB2AHYUy8up7u4a4uJGkkc5JJ/zxUGTX3OXZZDBxvvI/JM8z6rmU7bQWy/zAmgdaKozTXd5fJpOjwm4vpOCQMrEOMlj0GMg4/Gu+vXhQg5zeh5GEwlXF1VSpK7Y+R7q8vY9K0pPNvZTjIGRGD/EfTjnn0ya9S8FeGrXw5p3lIfNupDunmPJY9wCecZ/PrTfBXhi18O2IHE17IMzznkse4BPIGfz/ACA6GvgczzKeMn/dP2PIcip5XS7ze7CiiivLPoAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAOf8Z+GLXxHY7HIhu4+YZwOVPofUHuK8k1K21DR9ROnatAY5efLkHKSAdwa97rP17R7DW7BrPUIFkjI+U9GQ9iD2Nell2Z1MFO61XY0hUcH5HiJb8aQe9aHibw9qHhm423O6409z+6uQDheeFf0Pv3/lnA5AIwR1yO9fo+BxtLGU1OmzpU1LYlt5pbedJoJGjkQgqynBB+tep+B/HsV0sdjrDLHN91Jj91vQH0PvXlI4605etRj8uo42HLNa9zOpFSWp9KKysAykEEZBByCKWvG/Bvji80hltL7dcWeQBk5ZB7HuPavWdK1Gy1S0W5sp1ljYZ4PI9iOxr8/zDK62Cl7y07nFKDiy3RRSE15hIZooooAKKKKACiikJoAWkNGaSgAooooAKKKKACg0GkoACc0UUUAFFFFABRSUE0AGaQ80UUAFFFFABRRRQAUhNBpKACiiigAooooAKKM0hoAUmkoooAKKKKACiikJoACaCaSigAooooAKKKOlABTXZUUszAADkk4Aqtqeo2mnWxnu5ljUDgZ5b2A715v4m8UXeqs0MO6C1zwoPLe5P9K9LAZbVxctFZdzw83z3D5bD3neXY2/FfjAKHs9LYFujTDoPZf8a4V2Z3LuxZieSTkmk7cU2vt8HgaWEhywR+T5nm2IzGpz1Xp27Cn36UE/gKbI6ohd2CoASSTgAetM0HT7/wAV3XkaeHh09Tia6YEAj0X8Px5zwOaeLxlLCw55sjLcsr5jVVOivn2I7SG/1zUP7M0ZSWzia5IykIzgnPQkc/jxyeK9U8JeGtP8O2AhtU3zsMzTsMvI3Uknrjk8fzq3oGkWGiafHY2EQjjQDLYG5j6kjqa0K+Dx+Y1MZO727H7Hk2SUMrpcsFeXVhRRRXnHtBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQBDd20F3bPb3MSSxSAqyOAQfqDXlXjLwZd6I73+kLJdadyzwgZeHnJI/vAZ+o/WvW6DjBzyDXVhMZWwlRTpsak4vQ+fYZY5k3xOGXuQe9SA4r0Xxh4Ct7931DRWWzvjktHyIpfXIHQ9OR+IrzqeO5s7trLULZ7a6TqjdCPUHuPcV+gZZndHGLllpLsaqaHDpk9a0dE1jUNGuxcWU7Ic/Mucq3sR3rNpwPrxXrVKcakeWSuiJSPZ/Cnjaw1cLBdFbW7IAKscKx9if5V1gwRnqK+b14IIJBHQiuv8LeOdQ0sLb3ubu19z86j2Pf6GvkMx4d3nhvuOeSSeh7DRWbomuabrEAksrlWOPmQnDL9RWlXylSlKnJxmrMQUUUhqAAmkoooAKKKKACiigmgApDQaKACiiigAooooAKSgmkoAKKKKACiiigAoopDQAE0GkooAKKKKACiig0AFBpM0UAFFFFABRRRQAUn1oNJQApNJRRQAUUUUAFFFZ2sazYaXEXupgGxwgOWP0FXTpSqS5YK7Ma1enQhz1JWRosQASeMdSa5jxH4utNPDQWhFzcc5wflX6nufYVyviDxXfaluigJtrbptU/Mw9z/QVznUnPWvqMBkFmp4j7j4HOOMb3pYP/wL/ItanqF3qNwZ7uVpG7AngD0HpVWg0V9PCEYRSitD4CrVnVlzTd2wJqC8uobSIyzPtGeB1LH0A6k1FJdSTXYsNNga8vW4WNOi+7Htxz/PA5rufCPgSK2kXU9dK3d8VBERAMcWewHQkfl9TzXk5jnFLCrljrI+kyPhjEZjJVKnu0+/f0OZ8O+DtS8TSrdawJLHSlIaOEHDzdCCfb9PTPUer6fZ2un2kdpaRLFDGMKo9PUnqT7mrAAAxjAFFfEYnFVMTPnqM/WMDl9DA0lToxsgooornO0KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKyvEegaZr9p9n1C3DEZKSLw6H1BHP4dD3rVoppuLugPE/E/h3VvDTmScG808sdtygyUGeA4A4+vSsyCWOZN8bh1I4IOa99kRJY2jkRXRgQysMg57EHrXA+JvhvazPJe+HpV0+6PzGEjMLn0x1X8OPavqct4jnStDEarv1FJNnCZI6dKcDmmXsV7pl19j1a1e0nzgFh8j47q3Qj8aX3FfY0MTSxEeenK6Oeo3EtWdzcWcyz20zxSKchlJyK77w38RJECwazH5g4HnIMEe5Hf8ACvOlPY8inrz0rDF4Chio2qR17nO6tmfQOnajZajCJrO5jmU/3TyPYjqKtV8/6ffXlhOJrO4khkHdTjP1Heu50D4huoWLV4dw6GWMc/Uj/Cvkcbw9WpXlR95fiXHER2Z6PRVLS9V0/U4xJZXUcoxyAcMPw6irtfPzpyg7SVjdNNaBRQaTNQMUnFIaKKACiiigAoopDQAGgmkooAKKKKACiiigAoJxSGkoAXNJRRQAUUUUAFFBoJz2oACaSiigAooooAKKKQmgBelJmk60UAFFFFABRRVLU9V0/TYy15cpGccLnLH6Ac1cKcqkkoq5lVrU6MeapJJF2quo6jZ6fEZLudIh2BPJ+g6muK1nxzNIGi0yERKePNcZY+4HQfjXIXd1cXcpluZnlcnlmPNe9g8gq1LSraL8T4/M+MaFFOGGXM+/Q63XvG80u6HS0MSn/lowyx+g7VyFxNLPK0s0jO7HlmOTTM0n1r6nDYKjho2po/P8fmuJx0+atK/l0DrRk0hPGScD3qvayXWpXQs9FtXvZ84ZlH7tBnGS3A456HqMZFaV8RToR5qjsc+EwVfGTVOjG7JJ54oIjJPIsajqScfh7mnaRomveJ5FFmjafpjH57pxhnHcIOv+eorsfDXgG3t5VvdelXUbrqqEfuoz7A9fx/HPWu3RVRAqqFUAAADGMdgK+SzDPp1LwoaLufpOS8G0sO1VxXvS7dP+CY/hTw1pnhyyFvYxEu3Mkz8u57knsPYcfjzWzRRXzjbk7vc+4jFRSSVkgooopFBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAFXU9OsdTtWtr+1iuIj1V1Bx7g9QfcV5t4j+H2oafuufD8jXcAyWtZWG8f7rd/of1r1OiunDYuthp81OVhSipKzPn6K6Xz2trhHtrlDhoZQVYH0x+FWRntXsWv+HdH1yIpqNlHI2MCQDDj6MOe9cDrPw/1fTwZdGuf7QgHIgmIWQewbp+eK+uwPE1OVo4hWfc4auFlvBnPK5HXJqRSDVZ5Hgn+z3kEtpcDrHMu0n3GeoqXtX0lOrTrR5qbujy6jlDSSLVvPPbyiSCV4nHRlJGPyrrdF8eanaBY71Vu4xwSeGH49/wAa4pXYe4qRGX6GufE4KjiFapG5h9ZlB+6z2TSPF+jajtT7R9nkP8MvH4A9DW+jKyhkYMD0IOQa8AFaOma1qmnMDaXciAfwk5X8jxXzuJ4ci9aMvvOmnm1tJo9vorzvS/iDOm1NRtVkGcF4zg/XBrp9N8V6LegAXQhcjJWQbcH0yeK8KvleJofFG53UsfQqbSN2imRyRyIHjdXXGQVIIP5U4mvPaadmdiaaugJpKKKQwooooAKKKQmgBaTNJRQAUUUUAFFFFABQTigmkoADRRRQAUUUUAFFITSUAKTSUUyWWOJC0sixr3LEAfrTScnZEykoq7dkPorC1DxZotoCBc+ew42xDPI9+lc1qPjy7lBWxtkgH95zuP5dK9DD5Viq+0bep4uM4hwGFT5p3flqegO6xqXd1Ve5JAx+dYOq+LtIsSUWU3Mg/hjwQD7npXnGoapqF+xN3dSSDOdpOFH4DiqZzXu4bh2C1rSv6HyeO42qSvHDQt5s6bV/Gmp3eUtttrGePl5b8Sen4Vzcskk0hkldpHJ5LEkn8TTM+lGTXvUMLSw6tTjY+OxeY4nFy5q02wzRnNHbnpVGXU4WuRaWiyXt0TgQwDcQTwMnoPxNaVa0KS5puyMKGGrYmXJSjdl7pVSa8Hni1tYpLu6JwIYRuIJ6ZPQfjXQaL4G1nVAJtcuBp9sefs0BzI3szdvoMV3+iaHpeiwCHTrOOEY5YDLN7k9TXzmN4ihH3aCv5n3OVcE1J2ni3ZdluefaL4C1XVnWfxFP9ktOCLSAnc3QgM35gj9O9ej6RplhpNotpp9tHbxL0VRjJ9SepPuauUV8tiMTVxEuapK5+g4PAYfBQUKMLIKKKKwOwKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAKWraVp2q25g1C0iuI8YAYcj3B6g+4NcHrfw5uoCZvDuoDb1+y3RJX6Kw5H0I/GvSaK6MPi62HfNTlYzqUoVFaSPCr2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+nkBjcbB1BdWUfmQK6oYvDz+Ga+882pgMZT+Km/uNMOPf8qN6/5FZ6alYP8AcvIGz6OKmS5t35WeM57hhWynB7M5ZU6sd4v7i1vXsRQSvqKriaI9JU/BhSl1zjIz2561V49zK0+xMWX1FJkdelRFhjORn60nmJnl1BHXJFO67k2n2JSwo3cVA9zBGMvPGB7sKgk1PT48772BfXLipdSC3aBUqsnpF/cXSw96C3es8atYnGycyZOAURmB9uAasQS3NwA1rpWozg91t2wPrnHqKxnjMPD4pr7zenlmNq/DSl9xPu96TJP0qaLSPE9wuYdBmUnHEzhDz7VYTwf4ynHTTrQkj7zFyM9eQccfSuSpnWDh9q56FLhfM6uvs7erRRHPekd0jBZ3VQOpJAFdDZfDa/fB1TxFKw7rbRhB16Z4PStux+Hvhq3ZXmtZLyQD708pbJ45xn275rgq8S0Y/BFs9ehwNiZfxZpL7/8AI84fVbEOVWYTN/diUuf/AB0GrFvB4gviP7N8PXcikjDzYjXkZzk5P6CvYLPTNOsgBa2FvDg5ykYB65znGetXK8ytxFiJ6QSR7uG4JwVOzqty/A8w07wF4hvBu1XUoLFM8pbLuYj0LHp+H0710elfD/w9ZyLNNDJfTDq1y5cE/Q8Y9q6yivIr46vXfvzufR4XKsHhV+6ppEdvBBbRhIIY4lHQIoA/SpKKK5T0AooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAQqpyCoPrkVBNZWUxLS2kEh6ktGCT+YqxRQKxmS+H9Dlx5mj2J5z/qFGfrgc1BJ4U8OSEbtFsgR0xEBj8q2qKrmkhcifQ52XwR4XcYOj24HooI/rUf/AAgXhPGF0lF91lcfyaumoqvazXVkewpv7K+45geAfCIJ/wCJNET3Jkcn8y1TL4K8LKoU6LbEe4J/rXQ0Ue1qd2HsKX8q+4xk8K+G0ORotke3MQP86nj0DQ4yTHo9gvOeLdQB9Bjj8K0qKnmbLUIrZEENlZwgiG1gjHUhYwM/kKmGAMcAe1LRUlWCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/9k="

"""
    <base64 string for music_icon.png>
"""

# Set ImageMagick path
#os.environ["IMAGEMAGICK_BINARY"] = r"C:\Program Files\ImageMagick-7.1.1-Q16-HDRI\magick.exe"
#change_settings({"IMAGEMAGICK_BINARY": r"C:\Program Files\ImageMagick-7.1.1-Q16-HDRI\magick.exe"})



# Download stopwords from nltk
nltk.download('stopwords')

# Configure API Keys
OPENAI_API_KEY = 'sk-proj-rjJGSlP9rRzc4jNMpt0BT3BlbkFJLMLQHqpdBOaoSow6zM7d'
PIXABAY_API_KEY = '44812949-ba98a63acdbb20b31f0281193'
PEXELS_API_KEY = 'e4agaHhuOEpih3K562pmje6YJiy2jSQ37bYJU1nm5nw6NmeualG8afvG'
UNSPLASH_API_KEY = 'ATMcaMHzCfB789pGt8m6L5Z3YyvdgndRqiBNaxwmbf8'
openai.api_key = OPENAI_API_KEY
client = OpenAI(api_key="sk-proj-rjJGSlP9rRzc4jNMpt0BT3BlbkFJLMLQHqpdBOaoSow6zM7d")  # This uses your OPENAI_API_KEY from env automatically
# Define directories
video_image_folder = r'D:\New Laptop\YouTube Channels\RelaxFlow\Media\CurrentVideo\InVidFiles'
output_directory = r'D:\New Laptop\YouTube Channels\RelaxFlow\Media\CurrentVideo\OutFiles'
music_folder = r'D:\New Laptop\YouTube Channels\RelaxFlow\Media\CurrentVideo\InMusicFiles'
voiceover_directory = r'D:\New Laptop\YouTube Channels\RelaxFlow\Media\CurrentVideo\OutFiles'

output_settings = {
    'youtube': {'codec': 'libx264', 'resolution': (1920, 1080), 'fps': 24},
    'youtube_shorts': {'codec': 'libx264', 'resolution': (1080, 1920), 'fps': 30},
    'tiktok': {'codec': 'libx264', 'resolution': (1080, 1920), 'fps': 30},
    'facebook': {'codec': 'libx264', 'resolution': (1920, 1080), 'fps': 24},
    'instagram': {'codec': 'libx264', 'resolution': (1080, 1920), 'fps': 30},
    '720p': {'codec': 'libx264', 'resolution': (1280, 720), 'fps': 24}

}

def _set_imagemagick_path():
    """
    Pick the right ImageMagick binary for the current OS and
    tell MoviePy about it only once.
    """
    if platform.system() == "Windows":
        path = r"C:\Program Files\ImageMagick-7.1.1-Q16-HDRI\magick.exe"
    else:  # Linux, macOS, WSL, …
        # Prefer 'magick' (IM7) if present, else fall back to 'convert'
        path = shutil.which("magick") or shutil.which("convert")
        if path is None:
            raise FileNotFoundError(
                "ImageMagick binary not found. Install 'imagemagick' "
                "or set IMAGEMAGICK_BINARY manually."
            )

    os.environ["IMAGEMAGICK_BINARY"] = path
    change_settings({"IMAGEMAGICK_BINARY": path})

# ------------ End of Variables and Parameters settings
def _load_counters():
    """Call this once during start-up."""
    global issue_counter, enh_counter, com_counter
    if not os.path.isfile(COUNTER_FILE):
        return   # first run – keep defaults

    try:
        with open(COUNTER_FILE, "r", encoding="utf-8") as fh:
            data = json.load(fh)
        issue_counter = int(data.get("issue_counter", issue_counter))
        enh_counter   = int(data.get("enh_counter",   enh_counter))
        com_counter   = int(data.get("com_counter",   com_counter))
    except Exception as exc:
        print(f"WARNING: Could not load {COUNTER_FILE}: {exc}")


def _save_counters():
    """Write current values to disk."""
    data = dict(
        issue_counter=issue_counter,
        enh_counter=enh_counter,
        com_counter=com_counter,
    )
    try:
        with open(COUNTER_FILE, "w", encoding="utf-8") as fh:
            json.dump(data, fh)
    except Exception as exc:
        print(f"WARNING: Could not save {COUNTER_FILE}: {exc}")


# Automatically load at import time and save on exit
_load_counters()
atexit.register(_save_counters)

def try_delete_file(file_path, attempts=3, delay=1):
    """
    Attempts to remove file_path up to `attempts` times,
    waiting `delay` seconds between each attempt if locked.
    """
    for i in range(attempts):
        try:
            os.remove(file_path)
            # print(f"Deleted {file_path}")
            return True
        except PermissionError as e:
            # File is in use by another process; wait and try again
            # print(f"Attempt {i+1}/{attempts}: {file_path} locked: {e}")
            time.sleep(delay)
        except Exception as e:
            # Some other unexpected error
            print(f"Could not delete {file_path}: {e}")
            return False
    print(f"Could not delete {file_path} after {attempts} attempts.")
    return False

class MediaDraggableWidget(QWidget):
    def __init__(self, media_path, parent=None):
        super().__init__(parent)
        self.media_path = media_path
        layout = QHBoxLayout(self)
        layout.setContentsMargins(2, 2, 2, 2)
        layout.setSpacing(5)

        self.checkbox = QCheckBox(self)
        self.checkbox.setFocusPolicy(Qt.NoFocus)

        self.iconLabel = QLabel("⇅", self)
        font = QFont()
        font.setPointSize(20)
        self.iconLabel.setFont(font)
        self.iconLabel.setAlignment(Qt.AlignCenter)
        self.iconLabel.setMinimumWidth(20)
        self.iconLabel.setCursor(Qt.OpenHandCursor)
        self.iconLabel.setStyleSheet("""
            QLabel {
                color: #666;
                padding: 2px 5px;
                border-radius: 3px;
            }
            QLabel:hover {
                color: #000;
                background-color: #e0e0e0;
            }
        """)

        layout.addWidget(self.checkbox)
        layout.addWidget(self.iconLabel)
        layout.addStretch()
        self.setLayout(layout)

    def getMediaPath(self):
        return self.media_path

    def isChecked(self):
        return self.checkbox.isChecked()

    def setChecked(self, checked):
        self.checkbox.setChecked(checked)

class MediaTableReorder(QTableWidget):

    def __init__(self, main_window, *args, **kwargs):

        """

        main_window: your VideoCreatorGUI instance,

        which must have .target_language_input and .populate_clip_table()

        """

        super().__init__(main_window, *args, **kwargs)

        self.main_window = main_window


        # Table setup

        self.setDragEnabled(True)

        self.setAcceptDrops(True)

        self.setSelectionBehavior(QAbstractItemView.SelectRows)

        self.setDragDropMode(QAbstractItemView.InternalMove)

        self.viewport().setAcceptDrops(True)

        self.setDropIndicatorShown(True)


        # State

        self.drag_source_row = None

        self.dragging = False

        self.drop_indicator_row = -1

        self.last_scroll_position = 0


        # Progress dialog & timer refs

        self.progress = None

        self._flash_timer = None


    def show_progress(self, message: str) -> QProgressDialog:

        """

        Create, style, and show a frameless, on‐top, modal QProgressDialog

        with a flashing label. Returns the dialog so you can close it.

        """

        # First clean up any old dialog/timer

        self._cleanup_progress()


        # Grab localized title

        texts = get_texts_for_current_language(

            self.main_window.target_language_input

        )

        title = texts.get(

            "processing_title",

            DEFAULT_STRINGS["processing_title"]

        )


        dlg = QProgressDialog(message, None, 0, 0, self)

        dlg.setWindowModality(Qt.ApplicationModal)

        dlg.setWindowTitle(title)

        dlg.setCancelButton(None)

        dlg.setMinimumDuration(0)

        dlg.setWindowFlags(

            dlg.windowFlags()

            | Qt.FramelessWindowHint

            | Qt.WindowStaysOnTopHint

        )


        # YOUR new rich stylesheet:

        dlg.setStyleSheet("""

            QProgressDialog {

                background-color: rgba(240, 240, 240, 220);

                border-radius: 10px;

                padding: 20px;

            }

            QLabel {

                color: black;

                font-size: 12px;

                font-weight: bold;

            }

        """)


        dlg.setLabelText(message)

        dlg.show()

        dlg.setValue(0)

        QApplication.processEvents()


        # Grab the QLabel to enable HTML + word‐wrap + flashing

        lbl = dlg.findChild(QLabel)

        if lbl:

            lbl.setTextFormat(Qt.RichText)

            lbl.setWordWrap(True)


        # Prepare flashing

        orig  = message

        flash = f'<font color="#5d8aa8">{message}</font>'

        state = [False]


        timer = QTimer(dlg)

        timer.setInterval(500)


        def _flash():

            state[0] = not state[0]

            lbl.setText(flash if state[0] else orig)


        timer.timeout.connect(_flash)

        timer.start()


        # Keep refs so cleanup can stop them

        self.progress     = dlg

        self._flash_timer = timer

        return dlg


    def _cleanup_progress(self):

        """Stop & delete any existing flash‐timer and dialog."""

        if getattr(self, "_flash_timer", None):

            self._flash_timer.stop()

            self._flash_timer.deleteLater()

            self._flash_timer = None


        if getattr(self, "progress", None):

            self.progress.close()

            self.progress.deleteLater()

            self.progress = None


    def dropEvent(self, event):

        texts = get_texts_for_current_language(

            self.main_window.target_language_input

        )


        if not event.isAccepted() and event.source() == self:

            # compute target row

            drop_row = self.rowAt(event.pos().y())

            if drop_row < 0:

                drop_row = self.rowCount() - 1


            rows = sorted(set(item.row() for item in self.selectedItems()))

            if not rows:

                return

            source_row = rows[0]


            # no–op if dropping onto itself

            if source_row == drop_row:

                event.ignore()

                return


            print(f"Moving row {source_row} → {drop_row}")

            try:

                # 1) Show our styled progress

                msg = texts.get(

                    "moving_media_message",

                    DEFAULT_STRINGS["moving_media_message"]

                )

                self.show_progress(msg)


                # 2) Do the actual list re‐ordering

                self.last_scroll_position = self.verticalScrollBar().value()

                clips = getattr(self.main_window, "media_clips", None)

                if clips is None or source_row >= len(clips):

                    raise IndexError("Invalid source_row or no media_clips")


                final = drop_row - (1 if drop_row > source_row else 0)

                clip = clips.pop(source_row)

                clips.insert(min(final, len(clips)), clip)


                event.accept()

                self.dragging = False


                # 3) Refresh table (and close progress) after a tiny delay

                QTimer.singleShot(1, lambda: self._refresh_after_drop(final))

                print("Drop completed successfully")


            except Exception as e:

                print(f"Error during drop operation: {e}")

                self._cleanup_progress()

                event.ignore()

                self.dragging = False


    def _refresh_after_drop(self, target_row):

        """

        Re‐populate the table via parent.populate_clip_table(),

        restore scroll & selection, then clean up the dialog.

        """

        try:

            self.blockSignals(True)

            self.main_window.populate_clip_table()

            self.verticalScrollBar().setValue(self.last_scroll_position)

            if 0 <= target_row < self.rowCount():

                self.selectRow(target_row)

        except Exception as e:

            print(f"Error during refresh: {e}")

        finally:

            self.blockSignals(False)

            self._cleanup_progress()

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            item = self.itemAt(event.pos())
            if item:
                if self.columnAt(event.pos().x()) == 0:
                    widget = self.cellWidget(item.row(), 0)
                    if isinstance(widget, MediaDraggableWidget):
                        widget_pos = widget.mapFrom(self, event.pos())
                        if widget.iconLabel.geometry().contains(widget_pos):
                            self.drag_source_row = item.row()
                            self.selectRow(self.drag_source_row)

                            # Start drag immediately
                            drag = QDrag(self)
                            mimeData = QMimeData()
                            mimeData.setText(str(self.drag_source_row))
                            drag.setMimeData(mimeData)

                            pixmap = self.grab(self.visualItemRect(item))
                            drag.setPixmap(pixmap)
                            drag.setHotSpot(event.pos() - self.visualItemRect(item).topLeft())

                            # Execute drag
                            result = drag.exec_(Qt.MoveAction)
                            return
        super().mousePressEvent(event)

    def dragEnterEvent(self, event):
        if event.source() == self:
            event.accept()
            self.dragging = True
        else:
            event.ignore()

    def dragMoveEvent(self, event):
        if event.source() == self:
            event.accept()
            self.drop_indicator_row = self.rowAt(event.pos().y())
        else:
            event.ignore()

    def mouseReleaseEvent(self, event):
        if not self.dragging:
            super().mouseReleaseEvent(event)
        self.drag_source_row = None
        self.dragging = False
        self.drop_indicator_row = -1


class VLCVideoWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        # Initialize state variables
        self.current_media_path = None
        self.is_paused = False
        self.is_seeking = False
        self.is_player_ready = False
        self.last_seek_time = 0
        self.seek_cooldown = 0.2  # 200ms cooldown between seeks
        self.seek_queue = []
        self.seek_lock = threading.Lock()
        self.minimum_seek_interval = 250  # ms
        self.last_successful_seek = 0
        self.player_ready_retries = 0
        self.max_ready_retries = 100  # 5 seconds maximum wait

        # Initialize timers
        self.seek_timer = QTimer()
        self.seek_timer.setSingleShot(True)
        self.seek_timer.timeout.connect(self.process_seek_queue)

        self.player_ready_timer = QTimer(self)
        self.player_ready_timer.setInterval(50)  # Check every 50ms
        self.player_ready_timer.timeout.connect(self.check_player_ready)

        # Create a frame to host the VLC video
        self.videoFrame = QFrame(self)
        self.videoFrame.setStyleSheet("background-color: black;")
        self.videoFrame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        # Create timeline slider
        self.timelineSlider = QSlider(Qt.Horizontal, self)
        self.timelineSlider.setMinimum(0)
        self.timelineSlider.setMaximum(100)
        self.timelineSlider.setValue(0)
        self.timelineSlider.setMaximumHeight(30)
        self.timelineSlider.sliderReleased.connect(self.seek_video)

        # Create time label
        self.timeLabel = QLabel("00:00 / 00:00", self)
        self.timeLabel.setAlignment(Qt.AlignCenter)
        self.timeLabel.setMaximumHeight(20)

        # Set up layout
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(self.videoFrame, stretch=10)
        layout.addWidget(self.timelineSlider, stretch=0)
        layout.addWidget(self.timeLabel, stretch=0)
        self.setLayout(layout)

        # Create VLC instance with error handling options
        vlc_args = [
            '--quiet',
            '--no-xlib',
            '--no-video-title-show',
            '--file-caching=1000',
        ]
        self.instance = vlc.Instance(vlc_args)
        self.player = self.instance.media_player_new()

        # Set up error handling
        self.event_manager = self.player.event_manager()
        self.event_manager.event_attach(vlc.EventType.MediaPlayerEncounteredError,
                                        self.handle_player_error)

        # Set platform-specific output
        self.set_platform_specific_output()

        # Skip duration in seconds
        self.skip_duration = 10

        # Update timer
        self.timer = QTimer(self)
        self.timer.setInterval(500)
        self.timer.timeout.connect(self.update_timeline)

        # State tracking timer
        self.state_timer = QTimer(self)
        self.state_timer.setInterval(100)
        self.state_timer.timeout.connect(self.check_player_state)
        self.state_timer.start()

    def set_time(self, time_value):
        """Set playback position."""
        try:
            if self.is_player_ready and self.player:
                # Ensure the time value is an integer
                time_value = int(time_value)
                # Add boundary check
                media_length = self.get_length()
                if media_length > 0:
                    time_value = max(0, min(time_value, media_length - 100))
                return self.player.set_time(time_value)
            return False
        except Exception as e:
            print(f"Error setting time: {str(e)}")
            return False

    def check_player_ready(self):
        """Check if player is ready and handle pending operations."""
        try:
            if self.player and self.player.is_playing():
                state = self.player.get_state()
                if state in [vlc.State.Playing, vlc.State.Paused]:
                    self.is_player_ready = True
                    self.player_ready_timer.stop()
                    self.player_ready_retries = 0
                    # Process any pending seek operations
                    if self.seek_queue and not self.is_seeking:
                        self.process_seek_queue()
                else:
                    self.player_ready_retries += 1
                    if self.player_ready_retries >= self.max_ready_retries:
                        print("Player failed to become ready, resetting...")
                        self.player_ready_timer.stop()
                        self.reset_player()
            else:
                self.player_ready_retries += 1
                if self.player_ready_retries >= self.max_ready_retries:
                    self.player_ready_timer.stop()
                    self.reset_player()
        except Exception as e:
            print(f"Error checking player ready state: {str(e)}")
            self.player_ready_timer.stop()
            self.reset_player()

    def check_player_state(self):
        """Monitor player state."""
        try:
            if self.player:
                state = self.player.get_state()
                self.is_player_ready = state in [
                    vlc.State.Playing,
                    vlc.State.Paused,
                    vlc.State.NothingSpecial
                ]
        except Exception as e:
            print(f"Error checking player state: {str(e)}")
            self.is_player_ready = False

    def handle_player_error(self, event):
        """Handle VLC player errors."""
        print("VLC player encountered an error. Attempting recovery...")
        self.reset_player()

    def process_seek_queue(self):
        """Process pending seek operations."""
        if not self.seek_queue:
            self.is_seeking = False
            return

        if not self.is_player_ready:
            print("Player not ready, waiting...")
            self.player_ready_timer.start()
            return

        try:
            with self.seek_lock:
                operation = self.seek_queue.pop(0)
                current_time = self.get_time()
                media_length = self.get_length()

                if current_time < 0 or media_length <= 0:
                    print("Invalid time values, skipping seek operation")
                    return

                if operation == 'forward':
                    new_time = min(current_time + (self.skip_duration * 1000), media_length - 100)
                else:  # backward
                    new_time = max(0, current_time - (self.skip_duration * 1000))

                # Additional boundary check
                if new_time < 0 or new_time >= media_length:
                    print(f"Seek target {new_time} out of bounds [0, {media_length}]")
                    return

                success = self.safe_seek(new_time)
                if not success:
                    print("Seek operation failed")
                    if len(self.seek_queue) > 0:
                        self.seek_queue.clear()  # Clear pending seeks if one fails
                    return

        except Exception as e:
            print(f"Error processing seek queue: {str(e)}")
            self.seek_queue.clear()
        finally:
            if self.seek_queue:
                self.seek_timer.start(100)
            else:
                self.is_seeking = False

    def safe_seek(self, target_time):
        """Safely perform seek operation with additional safety checks."""
        if not self.player or not self.is_player_ready:
            return False

        try:
            with self.seek_lock:
                media_length = self.get_length()
                if media_length <= 0:
                    return False

                # Ensure target_time is within valid bounds with some margin
                target_time = max(0, min(target_time, media_length - 100))

                # Store playing state
                was_playing = self.player.is_playing()

                # Pause before seeking
                if was_playing:
                    self.player.pause()
                    time.sleep(0.05)  # Small delay to ensure pause takes effect

                # Perform seek
                result = self.player.set_time(int(target_time))

                # Resume if was playing
                if was_playing:
                    time.sleep(0.05)  # Small delay before resuming
                    self.player.play()

                return result == 0

        except Exception as e:
            print(f"Error during safe seek: {str(e)}")
            return False

    def forward(self):
        """Forward seek operation."""
        if not self.is_player_ready:
            print("Player not ready for forward operation")
            return

        current_time = time.time()
        if current_time - self.last_seek_time < self.seek_cooldown:
            return

        try:
            media_length = self.get_length()
            current_pos = self.get_time()

            # Check if we're already near the end
            if current_pos >= media_length - (self.skip_duration * 1000):
                print("Already near end of media")
                return

            # Calculate new position
            new_pos = current_pos + (self.skip_duration * 1000)
            new_pos = min(new_pos, media_length - 100)  # Keep some margin from the end

            print("DEBUG: Performing forward seek")
            result = self.player.set_time(int(new_pos))
            if result != 0:
                print("Forward seek failed")
            self.last_seek_time = current_time

        except Exception as e:
            print(f"❌ Error during forward: {str(e)}")

    def backward(self):
        """Backward seek operation."""
        if not self.is_player_ready:
            print("Player not ready for backward operation")
            return

        current_time = time.time()
        if current_time - self.last_seek_time < self.seek_cooldown:
            return

        try:
            current_pos = self.get_time()

            # Check if we're already near the start
            if current_pos <= self.skip_duration * 1000:
                print("Already near start of media")
                return

            # Calculate new position
            new_pos = max(0, current_pos - (self.skip_duration * 1000))

            print("DEBUG: Performing backward seek")
            result = self.player.set_time(int(new_pos))
            if result != 0:
                print("Backward seek failed")
            self.last_seek_time = current_time

        except Exception as e:
            print(f"❌ Error during backward: {str(e)}")

    def play(self, media_path=None):
        """Play media file or resume from pause."""
        try:
            self.is_player_ready = False
            if media_path is not None and media_path != self.current_media_path:
                self.current_media_path = media_path
                # Stop any existing playback
                self.player.stop()
                # Clear any pending operations
                self.seek_queue.clear()
                self.is_seeking = False

                # Create new media
                media = self.instance.media_new(media_path)
                self.player.set_media(media)
                self.set_platform_specific_output()
                self.is_paused = False
            elif self.is_paused:
                self.is_paused = False

            # Start playback
            result = self.player.play()
            if result == -1:
                print("Error starting playback")
                self.reset_player()
                return

            # Start timers
            self.timer.start()
            self.player_ready_timer.start()
            self.player_ready_retries = 0

        except Exception as e:
            print(f"Error during play: {str(e)}")
            self.reset_player()

    def set_platform_specific_output(self):
        """Set platform-specific video output."""
        try:
            if sys.platform.startswith('win'):
                self.player.set_hwnd(int(self.videoFrame.winId()))
            elif sys.platform.startswith('linux'):
                self.player.set_xwindow(int(self.videoFrame.winId()))
            else:
                self.player.set_nsobject(int(self.videoFrame.winId()))
        except Exception as e:
            print(f"Error setting platform output: {str(e)}")

    def reset_player(self):
        """Reset VLC player after errors."""
        with self.seek_lock:
            try:
                self.is_player_ready = False
                self.timer.stop()
                self.state_timer.stop()
                self.player_ready_timer.stop()
                self.seek_timer.stop()

                if hasattr(self, 'player'):
                    self.player.stop()
                    self.player.release()
                if hasattr(self, 'instance'):
                    self.instance.release()

                self.seek_queue.clear()
                self.is_seeking = False

                # Reinitialize VLC instance
                self.instance = vlc.Instance('--quiet')
                self.player = self.instance.media_player_new()
                self.set_platform_specific_output()

                if self.current_media_path:
                    media = self.instance.media_new(self.current_media_path)
                    self.player.set_media(media)
                    self.player.play()

                self.timer.start()
                self.state_timer.start()
                self.player_ready_timer.start()
                self.player_ready_retries = 0

            except Exception as e:
                print(f"Error resetting player: {str(e)}")

    def cleanup(self):
        """Clean up resources."""
        with self.seek_lock:
            try:
                self.is_player_ready = False
                self.timer.stop()
                self.state_timer.stop()
                self.player_ready_timer.stop()
                self.seek_timer.stop()
                self.seek_queue.clear()

                if hasattr(self, 'player'):
                    self.player.stop()
                    self.player.release()
                if hasattr(self, 'instance'):
                    self.instance.release()
            except Exception as e:
                print(f"Error during cleanup: {str(e)}")

    def pause(self):
        """Pause playback."""
        if self.is_player_ready:
            self.player.pause()
            self.is_paused = True

    def stop(self):
        """Stop playback."""
        if self.is_player_ready:
            self.player.stop()
            self.timer.stop()
            self.timelineSlider.setValue(0)
            self.timeLabel.setText("00:00 / 00:00")
            self.is_paused = False
            self.current_media_path = None

    def get_time(self):
        """Get current playback time with safety check."""
        try:
            if self.is_player_ready and self.player:
                time = self.player.get_time()
                return max(0, time)  # Ensure we never return negative time
            return 0
        except Exception as e:
            print(f"Error getting time: {str(e)}")
            return 0

    def get_length(self):
        """Get media length with safety check."""
        try:
            if self.is_player_ready and self.player:
                length = self.player.get_length()
                return max(0, length)  # Ensure we never return negative length
            return 0
        except Exception as e:
            print(f"Error getting length: {str(e)}")
            return 0

    def update_timeline(self):
        """Update timeline slider and label."""
        if not self.is_player_ready:
            return

        total_duration = self.get_length()
        if total_duration > 0:
            self.timelineSlider.setMaximum(total_duration)
        else:
            total_duration = 0

        current_time = self.get_time()
        self.timelineSlider.blockSignals(True)
        self.timelineSlider.setValue(current_time)
        self.timelineSlider.blockSignals(False)
        self.timeLabel.setText(f"{self.format_time(current_time)} / {self.format_time(total_duration)}")

    def seek_video(self):
        """Seek to slider position."""
        if self.is_player_ready:
            try:
                new_time = self.timelineSlider.value()
                return self.safe_seek(new_time)
            except Exception as e:
                print(f"Error during slider seek: {str(e)}")
                return False

    def format_time(self, ms):
        """Format time string."""
        seconds = ms // 1000
        hrs = seconds // 3600
        mins = (seconds % 3600) // 60
        secs = seconds % 60
        if hrs > 0:
            return f"{hrs:d}:{mins:02d}:{secs:02d}"
        else:
            return f"{mins:02d}:{secs:02d}"

    def closeEvent(self, event):
        """Handle widget closure."""
        self.cleanup()
        super().closeEvent(event)


def close_log_file():
    global global_log_file
    if global_log_file is not None and not global_log_file.closed:
        global_log_file.close()
        _original_print("Log file closed.")


def custom_print(*args, **kwargs):
    global global_log_file  # declare global for clarity
    sep = kwargs.get("sep", " ")
    end = kwargs.get("end", "\n")
    message = sep.join(str(arg) for arg in args) + end

    if PRINT_ENABLED:
        _original_print(*args, **kwargs)

    if LOG_ENABLED and global_log_file is not None and not global_log_file.closed:
        try:
            global_log_file.write(message)
            global_log_file.flush()  # flush after each write so the log updates immediately
        except Exception as e:
            _original_print("❌ Logging error:", e, file=sys.stderr)


# Override the built-in print function.
builtins.print = custom_print


def update_log_file(new_log_directory, new_video_title):
    global global_log_file, global_log_file_path
    # Close previous log file if open.
    if global_log_file:
        try:
            if not global_log_file.closed:
                global_log_file.close()
        except Exception:
            pass
        global_log_file = None

    # Only open a new file if both a directory and a video title are provided.
    if new_log_directory and new_video_title:
        log_filename = f"{new_video_title}.log"
        global_log_file_path = os.path.join(new_log_directory, log_filename)
        try:
            global_log_file = open(global_log_file_path, "a", encoding="utf-8")
            print(f"Logging enabled. Log file: {global_log_file_path}")  # This call writes to both console and log.
        except Exception as e:
            _original_print("❌ Error opening log file:", e, file=sys.stderr)


def get_video_duration(file_path):
    """
    Returns the duration of the video in seconds using MoviePy.
    """
    with VideoFileClip(file_path) as clip:
        return clip.duration


def get_platform_resolution(platform):
    """Returns the resolution tuple (width, height) for the given platform."""
    if platform in output_settings:
        return output_settings[platform]['resolution']
    else:
        print(f"⚠️ Warning: Platform '{platform}' not found in output_settings. Using default resolution (1920, 1080).")
        return (1920, 1080)  # Explicit default fallback resolution


def get_pixmap_from_base64(base64_string):
    """Convert a base64 string to a QPixmap."""
    image_data = base64.b64decode(base64_string)
    pixmap = QPixmap()
    pixmap.loadFromData(image_data)
    return pixmap


class PreviewLabel(QLabel):
    def __init__(self, file_path, media_type, parent=None):
        super().__init__(parent)
        self.file_path = file_path  # store the file path
        self.media_type = media_type  # "Video", "Image", or "Music"
        self.setCursor(Qt.PointingHandCursor)

    def mouseDoubleClickEvent(self, event):
        # When double-clicked, ask the parent window to show the preview.
        if hasattr(self.parent(), "openPreview"):
            self.parent().openPreview(self.file_path, self.media_type)


class ClickablePreviewLabel(QLabel):
    def __init__(self, file_path, media_type, parent=None):
        super().__init__(parent)
        self.file_path = file_path  # file path to preview
        self.media_type = media_type  # "Video", "Image", or "Music"
        self.setCursor(QCursor(Qt.PointingHandCursor))

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            mainWin = self.window()
            # Call openPreview method from the main window if available.
            if hasattr(mainWin, "openPreview"):
                mainWin.openPreview(self.file_path, self.media_type)
        super().mousePressEvent(event)


# Create a dedicated dialog class for video preview:
class VideoPreviewDialog(QDialog):
    def __init__(self, file_path, parent=None):
        super().__init__(parent)
        #self.setWindowTitle(f"Video Preview: {os.path.basename(file_path)}")
        self.setWindowTitle(texts.get("video_preview_title", DEFAULT_STRINGS["video_preview_title"]).format(
            os.path.basename(file_path)))
        self.resize(800, 600)
        layout = QVBoxLayout(self)
        self.videoWidget = QVideoWidget(self)
        layout.addWidget(self.videoWidget)
        self.player = QMediaPlayer(self)
        self.player.setVideoOutput(self.videoWidget)
        media = QMediaContent(QUrl.fromLocalFile(file_path))
        self.player.setMedia(media)
        self.player.setVolume(50)
        # Use a timer to start playback after the dialog is fully visible.
        QTimer.singleShot(1000, self.player.play)

    def closeEvent(self, event):
        self.player.stop()
        super().closeEvent(event)


# Similarly, for music preview, create a dedicated dialog:
class MusicPreviewDialog(QDialog):
    def __init__(self, file_path, parent=None):
        super().__init__(parent)
        #self.setWindowTitle(f"Music Preview: {os.path.basename(file_path)}")
        self.setWindowTitle(texts.get("music_preview_title", DEFAULT_STRINGS["music_preview_title"]).format(
            os.path.basename(file_path)))

        self.resize(400, 200)
        layout = QVBoxLayout(self)
        self.label = QLabel(f"Playing audio: {os.path.basename(file_path)}", self)
        layout.addWidget(self.label)
        self.player = QMediaPlayer(self)
        media = QMediaContent(QUrl.fromLocalFile(file_path))
        self.player.setMedia(media)
        self.player.setVolume(50)
        QTimer.singleShot(1000, self.player.play)

    def closeEvent(self, event):
        self.player.stop()
        super().closeEvent(event)


# A clickable preview label for images (and used for video/music icons as well)
class ClickablePreviewLabel(QLabel):
    def __init__(self, file_path, media_type, parent=None):
        super().__init__(parent)
        self.file_path = file_path
        self.media_type = media_type  # "Image", "Video", or "Music"
        self.setCursor(QCursor(Qt.PointingHandCursor))

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            # Call openPreview in the top-level window.
            mainWin = self.window()
            if hasattr(mainWin, "openPreview"):
                mainWin.openPreview(self.file_path, self.media_type)
        super().mousePressEvent(event)


def format_seconds(seconds):
    """Convert seconds (float/int) to a mm:ss formatted string."""

    minutes = int(seconds // 60)
    secs = int(seconds % 60)
    return f"{minutes:02d}:{secs:02d}"


def get_test_statement_for_voice(voice_name):
    """Return a test statement based on the voice language code (default is English)."""
    lower_voice = voice_name.lower()

    if lower_voice.startswith("ar-"):
        return "مرحبًا! هذا اختبار للصوت. كيف أبدو؟"
    elif lower_voice.startswith("es-"):
        return "¡Hola! Esta es una prueba de voz. ¿Cómo sueno?"
    elif lower_voice.startswith("pt-"):
        return "Olá! Este é um teste de voz. Como eu soou?"
    elif lower_voice.startswith("hi-"):
        return "नमस्ते! यह एक वॉयस टेस्ट है। मेरी आवाज कैसी लग रही है?"
    elif lower_voice.startswith("de-"):
        return "Hallo! Dies ist ein Stimmtest. Wie klinge ich?"
    elif lower_voice.startswith("zh-"):
        return "你好！这是一个语音测试。我听起来怎样？"
    elif lower_voice.startswith("jp-") or lower_voice.startswith("ja-"):
        return "こんにちは！これは音声テストです。私の声はどうですか？"
    elif lower_voice.startswith("fr-"):
        return "Bonjour ! Ceci est un test vocal. Comment est ma voix ?"
    elif lower_voice.startswith("ru-"):
        return "Привет! Это тест голоса. Как я звучу?"
    # --- new additions below ---
    elif lower_voice.startswith("ko-"):
        return "안녕하세요! 이것은 음성 테스트입니다. 제 목소리는 어떻게 들리나요?"
    elif lower_voice.startswith("tr-"):
        return "Merhaba! Bu bir ses testidir. Sesim nasıl geliyor?"
    elif lower_voice.startswith("ur-"):
        return "ہیلو! یہ ایک وائس ٹیسٹ ہے۔ میری آواز کیسی لگ رہی ہے؟"
    # ----------------------------
    else:
        return "Hello! This is a voice test. How do I sound?"


class VoiceSelector(QWidget):
    def __init__(self):
        super().__init__()

        texts = get_texts_for_current_language()
        self._player = QMediaPlayer()

        #self.setWindowTitle("Voice Selector")
        self.setWindowTitle(texts.get("voice_selector_title", DEFAULT_STRINGS["voice_selector_title"]))

        main_layout = QVBoxLayout()

        # Voice selection
        self.voice_label = QLabel("Select Voice:")
        self.voice_input = QComboBox()

        # Fetch available voices (only using locales en-GB and en-US)
        self.voice_list = asyncio.run(list_voices())
        self.voice_input.addItems([voice['ShortName'] for voice in self.voice_list])

        # Default voice: en-US-AndrewMultilingualNeural
        #default_voice = "en-US-AndrewMultilingualNeural"

        default_index = self.voice_input.findText(default_voice)
        if default_index >= 0:
            self.voice_input.setCurrentIndex(default_index)
        else:
            # Optionally print/log if the default voice is not found
            print(f"Default voice '{default_voice}' not found.")

        main_layout.addWidget(self.voice_label)
        main_layout.addWidget(self.voice_input)

        # Add "Test Voice" button
        self.test_button = QPushButton("Test Voice")
        self.test_button.setStyleSheet("""
                QPushButton {
                    background-color: #5d8aa8; /* Base color */
                    color: white;
                    font-weight: bold;
                    font-size: 24px;
                    border: 2px solid #4a739b; /* Darker border for depth */
                    border-radius: 5px;
                    padding: 5px 10px;
                    min-width: 80px;
                    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3); /* Shadow for 3D effect */
                }
                QPushButton:pressed {
                    background-color: #4a739b; /* Darker shade when pressed */
                    border: 2px solid #3b5a7b;
                    box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.3); /* Inset shadow for pressed effect */
                }
                QPushButton:hover {
                    background-color: #6b9ec1; /* Lighter blue on hover */
                }
            """)
        self.test_button.clicked.connect(self.test_selected_voice)
        main_layout.addWidget(self.test_button)

        self.setLayout(main_layout)

    async def play_test_statement(self, voice_name):
        """Play a test statement for the selected voice."""
        try:
            # Generate a unique file name.
            file_name = f"test_voice_{uuid.uuid4()}.mp3"

            # Get language-specific test text based on selected voice.
            test_text = get_test_statement_for_voice(voice_name)
            print(f"Testing voice: {voice_name} with text: {test_text}")

            communicator = Communicate(text=test_text, voice=voice_name)
            await communicator.save(file_name)

            # Ensure the file exists before playback
            for _ in range(10):
                if os.path.exists(file_name) and os.path.getsize(file_name) > 0:
                    break
                time.sleep(0.1)
            else:
                print(f"❌ Error: File {file_name} not found or empty after save.")
                return

            # Now play it
            self._player.setMedia(QMediaContent(QUrl.fromLocalFile(os.path.abspath(file_name))))
            self._player.setVolume(100)
            self._player.play()


        except Exception as e:
            print(f"❌ Error during voice test: {e}")

    def test_selected_voice(self):
        """Test the selected voice."""
        selected_voice = self.get_selected_voice()
        print(f"Voice name type: {type(selected_voice)}")
        if not isinstance(selected_voice, str):
            print("❌ Error: selected_voice is not a string.")
            return
        asyncio.run(self.play_test_statement(selected_voice))

    def get_selected_voice(self):
        """Get the currently selected voice."""
        return self.voice_input.currentText()


class VoiceoverThread(QThread):
    finished = pyqtSignal()

    def __init__(self, script, output_file, voice):
        super().__init__()
        self.script = script
        self.output_file = output_file
        self.voice = voice

    def run(self):
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            loop.run_until_complete(generate_voiceover(self.script, self.output_file, self.voice))
            print("✅ Voiceover successfully generated.")
        except Exception as e:
            print(f"❌ Error generating voiceover: {e}")
        finally:
            loop.close()
            self.finished.emit()


# Define parse_srt_time at module level.
def parse_srt_time(time_str):
    """
    Convert a time string into seconds.
    Supports both a simple float string (e.g., "0.000")
    and the standard SRT format "HH:MM:SS,mmm".
    """
    try:
        return float(time_str.replace(",", "."))
    except Exception:
        pass
    try:
        hours, minutes, sec_milli = time_str.split(":")
        seconds, milli = sec_milli.split(",")
        return int(hours) * 3600 + int(minutes) * 60 + int(seconds) + int(milli) / 1000.0
    except Exception as e:
        print(f"❌ Error parsing time '{time_str}': {e}")
        return 0.0


def generate_subtitle_clips_from_srt(srt_content, resolution, scale=1.0):
    """
    Parse SRT content and generate a list of TextClip objects.
    It assumes each subtitle block is separated by a blank line and formatted as:
        timecode (e.g., "0.000 --> 2.214" or "00:00:00,000 --> 00:00:02,214")
        followed by one or more lines of subtitle text.
    The scale factor multiplies each subtitle’s start and duration.
    Returns a list of TextClip objects.
    """
    global font
    global parse_srt_time  # to ensure availability in the child process
    subtitle_clips = []
    blocks = re.split(r'\n\s*\n', srt_content.strip())
    print(f"DEBUG: Found {len(blocks)} subtitle blocks in SRT content.")
    timecode_re = re.compile(r'(\d+(?:\.\d+)?(?:,\d{3})?)\s*-->\s*(\d+(?:\.\d+)?(?:,\d{3})?)')
    for block in blocks:
        lines = block.splitlines()
        if len(lines) < 2:
            print("DEBUG: Skipping block (insufficient lines):", block)
            continue
        if "-->" in lines[0]:
            time_line = lines[0]
            text = " ".join(lines[1:])
        else:
            time_line = lines[1]
            text = " ".join(lines[2:])
        match = timecode_re.match(time_line)
        if not match:
            print("DEBUG: Timecode format not recognized in block:", block)
            continue
        start_str, end_str = match.groups()
        start_time = parse_srt_time(start_str) * scale
        end_time = parse_srt_time(end_str) * scale
        duration = end_time - start_time
        if duration <= 0:
            continue
        fontsize = 70 if resolution[0] >= 1280 else 48
        video_height = resolution[1]
        y_position = video_height * 0.75

        if re.search(r'[\u0600-\u06FF]', text):
            font = arabic_font
        else:
            font = english_font

        #print(f"Inside generate_subtitle_clips_from_srt font: {font}")
        try:
            clip = (TextClip(text, fontsize=fontsize, color="white", font=font,
                             stroke_color='black', stroke_width=2)
                    .set_position(('center', y_position))
                    .set_start(start_time)
                    .set_duration(duration))
            subtitle_clips.append(clip)
        except Exception as e:
            print(f"❌ Error creating TextClip for text '{text}': {e}")
    print(f"DEBUG: Generated {len(subtitle_clips)} subtitle clips with scale factor {scale:.2f}.")
    return subtitle_clips


def encode_video(media_files, subtitle_file_path, voiceover_file, music_files, final_video_file, platform_settings):
    """
    Rebuilds media clips from file paths and encodes the final video.
    Expects:
      - media_files and music_files as lists of file paths.
      - subtitle_file_path is a string path to the SRT file.
    Raises an Exception if anything goes wrong.
    """
    print("DEBUG: Inside encode_video().")

    video_exts = {".mp4", ".avi", ".mov", ".mkv"}
    music_exts = {".mp3", ".wav", ".flac", ".aac", ".ogg"}
    resolution = platform_settings.get('resolution', (1280, 720))
    fps = platform_settings.get('fps', 24)

    # Lists to record which files were successfully loaded/used.
    used_media_files = []
    used_music_files = []

    new_clips = []
    for file in media_files:
        if not file or file.strip() == "":
            continue
        if not os.path.exists(file):
            print(f"⚠️ WARNING: File does not exist: {file}")
            continue
        ext = os.path.splitext(file)[1].lower()
        # Skip files that are music.
        if ext in music_exts:
            print(f"DEBUG: Skipping music file from media clip list: {file}")
            continue
        try:
            if ext in video_exts:
                print(f"DEBUG: Loading video clip: {file}")
                clip = VideoFileClip(file)
                if clip.duration <= 0:
                    print(f"⚠️ WARNING: Clip duration is zero: {file}")
                    clip.close()
                    continue
                clip = clip.resize(newsize=resolution)
                new_clips.append(clip)
                used_media_files.append(file)  # Mark this file as used
            else:
                print(f"DEBUG: Loading image clip: {file}")
                clip = ImageClip(file, duration=5).resize(newsize=resolution)
                new_clips.append(clip)
                used_media_files.append(file)  # Mark as used
        except Exception as e:
            print(f"⚠️ WARNING: Could not load clip {file}: {e}")

    if not new_clips:
        raise Exception("No valid media clips loaded.")

    print("DEBUG: Concatenating media clips (method='compose')...")
    base_video = concatenate_videoclips(new_clips, method="compose").set_position("center")
    print(f"DEBUG: Base video created; duration: {base_video.duration:.2f}s ({base_video.duration / 60:.2f} minutes)")

    # Generate subtitle clips from the SRT file.
    subtitle_clips = []
    if subtitle_file_path and os.path.exists(subtitle_file_path):
        try:
            with open(subtitle_file_path, "r", encoding="utf-8") as f:
                srt_content = f.read()
            # First, generate raw subtitle clips with scaling factor 1.0.
            raw_subtitle_clips = generate_subtitle_clips_from_srt(srt_content, resolution, scale=1.0)
            max_end = 0
            for clip in raw_subtitle_clips:
                end_time = clip.start + clip.duration
                if end_time > max_end:
                    max_end = end_time
            audio_clip = AudioFileClip(voiceover_file)
            voiceover_duration = audio_clip.duration
            audio_clip.close()
            if max_end > 0 and voiceover_duration > max_end:
                ratio = voiceover_duration / max_end
                print(f"DEBUG: Scaling subtitle timings by factor {ratio:.2f}")
                subtitle_clips = generate_subtitle_clips_from_srt(srt_content, resolution, scale=ratio)
            else:
                subtitle_clips = raw_subtitle_clips
        except Exception as e:
            print(f"⚠️ WARNING: ❌ Error processing subtitles: {e}")
    else:
        print("DEBUG: Subtitle file not provided or does not exist.")

    if subtitle_clips:
        print("DEBUG: Adding subtitle clips...")
        final_video = CompositeVideoClip([base_video] + subtitle_clips)
    else:
        final_video = base_video

    if not os.path.exists(voiceover_file):
        raise Exception("Voiceover file not found.")
    audio_file_clip = AudioFileClip(voiceover_file)
    print(
        f"DEBUG: Voiceover loaded; duration: {audio_file_clip.duration:.2f}s ({audio_file_clip.duration / 60:.2f} minutes)")

    if music_files:
        music_audio_clips = []
        for mf in music_files:
            if not os.path.exists(mf):
                print(f"⚠️ WARNING: Music file not found: {mf}")
                continue
            try:
                clip_audio = AudioFileClip(mf)
                music_audio_clips.append(clip_audio)
                used_music_files.append(mf)  # Mark this music file as used.
            except Exception as e:
                print(f"⚠️ WARNING: Could not load music file {mf}: {e}")
        if music_audio_clips:
            background_music = concatenate_audioclips(music_audio_clips).volumex(0.1)
            final_audio = CompositeAudioClip([audio_file_clip, background_music.set_duration(final_video.duration)])
        else:
            final_audio = CompositeAudioClip([audio_file_clip])
    else:
        final_audio = CompositeAudioClip([audio_file_clip])

    final_audio = final_audio.set_duration(final_video.duration)
    final_video = final_video.set_audio(final_audio)

    print("DEBUG: Writing final video file...")
    final_video.write_videofile(final_video_file,
                                codec="libx264",
                                audio_codec="aac",
                                fps=fps,
                                preset="medium",
                                ffmpeg_params=["-movflags", "+faststart", "-pix_fmt", "yuv420p", "-profile:v",
                                               "baseline", "-level", "3.0", "-ar", "44100"],
                                threads=1)

    # Clean up resources.
    final_video.close()
    final_audio.close()
    for clip in new_clips:
        try:
            clip.close()
        except Exception:
            pass
    gc.collect()




class VideoEncoderThread(QThread):
    encoding_finished = pyqtSignal(bool, str)  # (success, message)

    def __init__(self, media_files, subtitle_clips, voiceover_file, music_files,
                 final_video_file, platform_settings, parent=None):
        super(VideoEncoderThread, self).__init__(parent)
        self.media_files = media_files  # list of media file paths (self.media_clips)
        self.subtitle_clips = subtitle_clips  # Composite subtitle clips (if any)
        self.voiceover_file = voiceover_file
        self.music_files = music_files  # list of music file paths (self.music_clips)
        self.final_video_file = final_video_file
        self.platform_settings = platform_settings
        self.resolution = platform_settings.get('resolution', (1280, 720))
        self.fps = platform_settings.get('fps', 24)

    def run(self):
        try:
            new_clips = []
            video_exts = {".mp4", ".avi", ".mov", ".mkv"}
            # Process each media file, ensuring the file exists
            for file in self.media_files:
                if not file or file.strip() == "":
                    continue
                if not os.path.exists(file):
                    print(f"⚠️ WARNING (EncoderThread): File does not exist: {file}")
                    continue
                ext = os.path.splitext(file)[1].lower()
                try:
                    if ext in video_exts:
                        print(f"DEBUG (EncoderThread): Loading video clip: {file}")
                        clip = VideoFileClip(file)
                        if clip.duration <= 0:
                            print(f"⚠️ WARNING (EncoderThread): Clip duration is zero: {file}")
                            clip.close()
                            continue
                        clip = clip.resize(newsize=self.resolution)
                        new_clips.append(clip)
                    else:
                        print(f"DEBUG (EncoderThread): Loading image clip: {file}")
                        clip = ImageClip(file, duration=5).resize(newsize=self.resolution)
                        new_clips.append(clip)
                except Exception as e:
                    print(f"⚠️ WARNING (EncoderThread): Could not load clip {file}: {e}")
            if not new_clips:
                self.encoding_finished.emit(False, "No valid media clips loaded.")
                return

            print("DEBUG (EncoderThread): Concatenating media clips (method='compose')...")
            base_video = concatenate_videoclips(new_clips, method="compose").set_position("center")

            print(
                f"DEBUG (EncoderThread): Base video created; duration: {base_video.duration:.2f}s ({base_video.duration / 60:.2f} minutes)")

            if self.subtitle_clips:
                print("DEBUG (EncoderThread): Adding subtitle clips...")
                final_video = CompositeVideoClip([base_video] + self.subtitle_clips)
            else:
                final_video = base_video

            # Check voiceover file existence
            if not os.path.exists(self.voiceover_file):
                self.encoding_finished.emit(False, "Voiceover file not found.")
                return
            audio_file_clip = AudioFileClip(self.voiceover_file)

            print(
                f"DEBUG (EncoderThread): Voiceover loaded; duration: {audio_file_clip.duration:.2f}s ({audio_file_clip.duration / 60:.2f} minutes)")

            if self.music_files:
                music_audio_clips = []
                for mf in self.music_files:
                    if not os.path.exists(mf):
                        print(f"⚠️ WARNING (EncoderThread): Music file not found: {mf}")
                        continue
                    try:
                        clip_audio = AudioFileClip(mf)
                        music_audio_clips.append(clip_audio)
                    except Exception as e:
                        print(f"⚠️ WARNING (EncoderThread): Could not load music file {mf}: {e}")
                if music_audio_clips:
                    background_music = concatenate_audioclips(music_audio_clips)
                    background_music = background_music.volumex(0.2)
                    final_audio = CompositeAudioClip([audio_file_clip,
                                                      background_music.set_duration(final_video.duration)])
                else:
                    final_audio = CompositeAudioClip([audio_file_clip])
            else:
                final_audio = CompositeAudioClip([audio_file_clip])

            final_audio = final_audio.set_duration(final_video.duration)
            final_video = final_video.set_audio(final_audio)

            print("DEBUG (EncoderThread): Writing final video file...")
            final_video.write_videofile(self.final_video_file,
                                        codec="libx264",
                                        audio_codec="aac",
                                        fps=self.fps,
                                        preset="medium",
                                        ffmpeg_params=["-movflags", "+faststart", "-pix_fmt", "yuv420p", "-profile:v",
                                                       "baseline", "-level", "3.0", "-ar", "44100"],
                                        threads=1)
            self.encoding_finished.emit(True, "Video encoding completed successfully.")
        except Exception as e:
            self.encoding_finished.emit(False, f"❌ Error encoding video: {e}")
        finally:
            try:
                final_video.close()
            except Exception:
                pass
            try:
                final_audio.close()
            except Exception:
                pass
            for clip in new_clips:
                try:
                    clip.close()
                except Exception:
                    pass
            gc.collect()


# (Other needed imports already exist such as QProgressDialog, etc.)

# Assume there is a translation helper that accepts a string and a target language:
# For example:
# def translate_text(text: str, target_lang: str, source_lang: str = "en") -> str:
#     ...   # returns the translated text.

DEFAULT_STRINGS = {  # Default - English
    "missing_required_title": "Missing Required Fields",
    "missing_required_msg": "Please fill all required fields:\n",
    "issue_option": "Issue",
    "enh_option": "Enhancement",
    "comment_option": "Comment",
    "coming_soon_title":        "Coming Soon",
    "coming_soon_msg": (
        "The integration for {} is coming soon.\n\n"
        "Please manually upload the final video.\n"
        "Video path: {}"
    ),
    "youtube_shorts_reminder_title":  "YouTube Shorts Reminder",
    "youtube_shorts_reminder_msg": (
        "NOTE: YouTube Shorts are intended for videos of 60 seconds or less. "
        "Please ensure that your video meets the length requirement for YouTube Shorts."
    ),
    "file_not_found_title":     "⚠️ WARNING: File Not Found",
    "file_not_found_msg": (
        "Final video file for {} not found. "
        "You may not have generated it for the specific platform. "
        "Please generate it and try again."
    ),
    "yes":            "Yes",
    "no":             "No",
    "video":          "Video",
    "image":          "Image",
    "info":           "Info",
    "switch_account": "Switch Account",
    "main_tab_title": "Main",
    "target_language_label": "Target Language:",
    "voice_label": "Select Narrator Voice:",
    "video_title_label": "Video Title:",
    "platform_label": "Platform:",
    "prompt_label": "Enter the prompt for the video content (in any Language):",
    "genre_label": "Select Instrumental Genre:",
    "modify_label": "Modify Keywords?",
    "bypass_label": "Bypass Text, Subtitles, and Voiceover?",
    "status_label": "Status:",
    "save_subtitles_btn": "Save and Regenerate Subtitles",
    "start_video_btn": "Start Video Creation",
    "play_video_btn_final": "Play Video",
    "replace_clip_btn": "Replace Selected Clip",
    "delete_clip_btn": "Delete Selected Clips",
    "base_directory_label": "Base Directory:",
    "base_browse_btn": "Browse",
    "video_image_folder_label": "Video Image Folder:",
    "output_directory_label": "Output Directory:",
    "music_folder_label": "Music Folder:",
    "voiceover_directory_label": "Voiceover Directory:",
    "review_script_tab": "Review or Edit Script",
    "review_clips_tab": "Review or Edit Media Clips and Subtitles",
    "test_voice_button": "Test Voice",
    "generate_final_video_btn": "Generate Final Video",
    "final_video_tab": "Final Video",
    "upload_video_btn": "Upload to Social Media",
    "clip_table_headers": [
        "Select", "Media Preview", "Media Type", "Media File", "Media Dur",
        "Media Start", "Media End", "Select", "Music Preview", "Music File",
        "Music Dur", "Music Start", "Music End", "Subtitle", "Subtitle Start", "Subtitle End"
    ],
    # Tooltips
    "editable_field_tooltip": "Editable field",
    "readonly_field_tooltip": "Read-only field",
    "bypass_mode_message": (
        "Since you selected bypass Script, Subtitles, and Voiceover mode, "
        "no script/subtitles/voiceover were generated.\n"
        "Please review the downloaded media in the 'Review or Edit Clips and Subtitles' tab.\n"
        "After you're done reviewing, click on 'Generate Final Video' button to generate the final video.\n"
        "After the final video is generated, Click OK on the pop-up alert that will show up.\n"
        "Then, you will be switched automatically to 'Final Video' tab to Preview the video.\n"
        "Click OK to dismiss this notification."
    ),
    "normal_mode_message": (
        "Please review the generated content:\n"
        "1. In the 'Review or Edit Script' tab, please review/edit the generated script.\n"
        "2. Then, click on 'Save and Regenerate Subtitles' button in order to be switched to "
        "the 'Review or Edit Clips and Subtitles' tab for review.\n"
        "After you're done reviewing, click on 'Generate Final Video' button to generate the final video.\n"
        "After the final video is generated, Click OK on the pop-up alert that will show up.\n"
        "Then, you will be switched automatically to 'Final Video' tab to Preview the video.\n"
        "Click OK to dismiss this notification."
    ),
    # Buttons
    "add_media_btn": "Add Media",
    "add_music_btn": "Add Music",
    # Placeholders
    "no_file_placeholder": "No file",
    "none_text": "None",
    # ToolTips
    "switch_account_tooltip": "Check this box if you want to sign in with a different YouTube account.",
    "target_language_tooltip": "Select the target language for the interface translations.",
    "prompt_tooltip": (
        "Provide a comprehensive prompt describing the video content you wish to create.\n"
        "Include key topics, desired style, and all essential details to guide the video generation process.\n"
        "You may write the prompt in any language; the video will be produced in the language selected.\n"
        "The generated output will form a video script that you can review later."
    ),
    "modify_tooltip": (
        "Choose 'Yes' (default) to allow editing of the keywords extracted from the script; selecting 'No' retains the original keywords\n"
        "These keywords determine the selection of downloaded media; more keywords may yield more media (and longer videos),\n"
        "while more precise keywords produce more relevant content.\n"
        "Note: If you use a language other than English for the prompt, English keywords will be added automatically for optimal content results."
    ),
    "modify_yes_tooltip": "Yes: Allow modifications to the extracted keywords.",
    "modify_no_tooltip": "No: Use the originally generated keywords.",
    "bypass_tooltip": (
        "When set to 'Yes', the generation and processing of text, subtitles, and voiceover will be bypassed\n"
        "Example: meditation or Relaxation videos.\n"
        "When set to 'No' (default), text, subtitles, and voiceover are generated."
    ),
    "bypass_yes_tooltip": "Yes: Bypass text, subtitle, and voiceover generation.",
    "bypass_no_tooltip": "No: Generate text, subtitles, and voiceover.",

    # Buttons
    "play_button": "Play",
    "pause_button": "Pause",
    "forward_button": "Forward (+10 s)",
    "backward_button": "Backward (-10 s)",
    "browse_button": "Browse",

    # Window Titles
    "success_text": "Success",
    "video_preview_title": "Video Preview: ",  #
    "music_preview_title": "Music Preview: ",
    "voice_selector_title": "Voice Selector",
    "upload_details_title": "Upload Details",
    "modify_keywords_title": "Modify Keywords",

    # Progress Messages
    "uploading_video": "Uploading Video to YouTube... Please wait.",
    "uploading_thumbnail": "Uploading YouTube thumbnail... Please wait.",
    "generating_final_video": "Generating Final Video... Please wait.",
    "saving_subtitles": "Saving subtitles and regenerating SRT",
    "replacing_media": "Replacing Selected Media... Please wait.",
    "deleting_clips": "Deleting selected clip(s)... Please wait.",
    "inserting_media": "Inserting New Media... Please wait.",
    "inserting_music": "Inserting New Music Media... Please wait.",
    "starting_video": "Starting video creation... Please wait.",

    # Info Messages
    "upload_success": "✅ YouTube Video Upload Completed Successfully!",
    "upload_failure": "❌ An error occurred during upload.",
    "upload_cancelled": "Upload was cancelled by the user.",
    "subtitle_error": "❌ An error occurred during subtitle processing: ",
    "select_media_warning": "Please select a media cell to replace.",
    "unsupported_file": "Selected file type is not supported.",
    "replace_media_error": "❌ An error occurred while Replacing Selected Media: ",
    "no_items_selected": "No media, music, or subtitles selected for deletion.",
    "delete_error": "❌ An error occurred while deleting clips: ",
    "insert_media_error": "❌ An error occurred while Inserting New Media: ",
    "video_success_bypass": "Video creation completed successfully (bypass mode).",
    "video_success": "Video creation completed successfully.",
    "encoding_error": "❌ Error encoding video in separate process.",
    "review_content_title": "Info - Review Content",
    "title_required": "Please enter a video title.",
    "platform_required": "Please select a platform.",
    "prompt_required": "Please enter a Video Script Prompt.",
    "video_not_found": "Video file not found: ",
    "playback_error": "❌ An error occurred while playing the video: ",
    "invalid_platform": "❌ Invalid platform settings for .",

    # Status Messages
    "encoding_complete": "Video encoding completed successfully.",
    "encoding_error_status": "❌ Error encoding video in separate process.",
    "general_error": "❌ An error occurred: ",
    "playing_video": "Playing video: ",
    "subtitles_saved": "Subtitles saved and voiceover generation started...",
    "items_deleted": "✅ Selected items deleted.",
    "no_media_found": "❌ No video or image files found in ",
    "video_processing_error": "❌ Error processing video file : ",
    "image_processing_error": "❌ Error processing image file : ",
    "no_valid_clips": "❌ No valid clips could be processed.",
    "invalid_voiceover": "❌ Invalid voiceover duration. Aborting.",
    "no_music_files": "❌ No music files found; setting music clips as empty list.",
    "review_aborted": "Review aborted by the user. Video creation canceled.",
    "video_creation_started": "Video creation started...",
    "creating_video": "Initiate - Creating Video Titled: ",
    "video_in_progress": "In Progress - Creating Video Titled: ",
    "main_execution_error": "❌ Error in main execution: ",

    # Dialog Messages
    "enter_keywords": "Enter the new keywords, separated by commas:",
    "description_label": "Description:",
    "tags_label": "Tags (comma separated):",
    "privacy_label": "Privacy:",
    "thumbnail_label": "Thumbnail Image:",
    "category_label": "Category:",
    "video_language_label": "Video Language:",
    "recording_date_label": "Recording Date:",
    "switch_account_label": "Switch YouTube Account",
    "select_thumbnail": "Select Thumbnail Image",
    "image_files_filter": "Image Files (*.png *.jpg *.jpeg)",
    "select_platform_title": "Select Platform",
    "select_platform_prompt": "Choose a social media platform:",
    "loading_clips_message": "Loading clips and subtitles... Please wait.",
    "moving_media_message": "Moving media clip... Please wait.",
    "processing_subtitles_message": "Processing subtitles... Please wait.",
    "loading_title": "Loading",
    "processing_title": "Processing",
    "support_tab": "Support",
    "check_faq_label": "Please check our FAQ first:",
    "faq_link_text": "Click here for FAQ",
    "sr_number_label": "SR Number",
    "customer_name_label": "Customer Name",
    "email_label": "Email",
    "phone_label": "Phone",
    "ticket_type_label": "Ticket Type",
    "issue_description_label": "Issue Description",
    "video_name_label": "Video Name",
    "creation_dt_label": "Creation Date/Time (tentative)",
    "desc_label": "Description",
    "send_button": "Send Ticket",
    "sr_sent_title": "Ticket Sent",
    "sr_sent_msg": "Your support request has been sent successfully!"
}

# only invert the entries whose default is a str
REVERSE_DEFAULTS = {
    text: key
    for key, text in DEFAULT_STRINGS.items()
    if isinstance(text, str)
}


HARDCODED_TRANSLATIONS = {
    "en": {},  # fallback to DEFAULT_STRINGS
    # Arabic
    "ar": {
        "missing_required_title": "حقول مطلوبة مفقودة",
        "missing_required_msg": "يرجى ملء جميع الحقول المطلوبة:\n",
        "issue_option": "مشكلة",
        "enh_option":   "تحسين",
        "comment_option": "تعليق",
        "coming_soon_title":       "قريباً",
        "coming_soon_msg": (
            "التكامل لـ {} قادم قريباً.\n\n"
            "يرجى تحميل الفيديو النهائي يدوياً.\n"
            "مسار الفيديو: {}"
        ),
        "youtube_shorts_reminder_title": "تذكير YouTube Shorts",
        "youtube_shorts_reminder_msg": (
            "ملاحظة: مقاطع YouTube القصيرة (Shorts) مخصصة لمقاطع فيديو مدتها 60 ثانية أو أقل. "
            "يرجى التأكد من أن الفيديو الخاص بك يستوفي متطلبات الطول لـ YouTube Shorts."
        ),
        "file_not_found_title":    "⚠️ تحذير: الملف غير موجود",
        "file_not_found_msg": (
            "لم يتم العثور على ملف الفيديو النهائي لـ {}. "
            "قد لا تكون قد أنشأته لهذه المنصة. "
            "يرجى إنشاؤه وحاول مرة أخرى."
        ),
        "yes":            "نعم",
        "no":             "لا",
        "video":          "فيديو",
        "image":          "صورة",
        "info":           "معلومات",
        "switch_account": "تبديل الحساب",
        "main_tab_title": "الرئيسية",
        "target_language_label": "اللغة المستهدفة:",
        "voice_label": "اختر صوت المُعلق:",
        "video_title_label": "عنوان الفيديو:",
        "platform_label": "المنصة:",
        "prompt_label": "أدخل الموجه لمحتوى الفيديو (بأي لغة):",
        "genre_label": "اختر نوع الموسيقى الآلية:",
        "modify_label": "تعديل الكلمات المفتاحية؟",
        "bypass_label": "تخطي نص الحوار والتعليق الصوتي؟",
        "status_label": "الحالة:",
        "save_subtitles_btn": "حفظ وإعادة إنشاء نص الحوار",
        "start_video_btn": "بدء إنشاء الفيديو",
        "play_video_btn_final": "تشغيل الفيديو",
        "replace_clip_btn": "استبدال المقطع المحدد",
        "delete_clip_btn": "حذف المقاطع المحددة",
        "base_directory_label": "الملف الأساسي:",
        "base_browse_btn": "تصفح",
        "video_image_folder_label": "ملف صور الفيديو:",
        "output_directory_label": "ملف المخرجات:",
        "music_folder_label": "ملف الموسيقى:",
        "voiceover_directory_label": "ملف التعليق الصوتي:",
        "review_script_tab": "مراجعة أو تعديل نص الحوار",
        "review_clips_tab": "مراجعة أو تعديل مقاطع الفيديو والموسيقى",
        "test_voice_button": "اختبار الصوت",
        "generate_final_video_btn": "إنشاء الفيديو النهائي",
        "final_video_tab": "الفيديو النهائي",
        "upload_video_btn": "تحميل إلى وسائل التواصل الاجتماعي",
        "clip_table_headers": [
            "اختر", "معاينة الوسائط", "نوع الوسائط", "ملف الوسائط", "مدة الوسائط",
            "بداية الوسائط", "نهاية الوسائط", "اختر", "معاينة الموسيقى", "ملف الموسيقى",
            "مدة الموسيقى", "بداية الموسيقى", "نهاية الموسيقى", "النص", "بداية النص", "نهاية النص"
        ],
        # Tooltips
        "editable_field_tooltip": "حقل قابل للتحرير",
        "readonly_field_tooltip": "حقل للقراءة فقط",
        "bypass_mode_message": (
            "نظراً لاختيارك تخطي وضع النص والترجمات والتعليق الصوتي، "
            "لم يتم إنشاء نص/ترجمات/تعليق صوتي.\n"
            "يرجى مراجعة الوسائط التي تم تنزيلها في علامة التبويب 'مراجعة أو تعديل مقاطع الفيديو والموسيقى'.\n"
            "بعد الانتهاء من المراجعة، انقر على زر 'إنشاء الفيديو النهائي' لإنشاء الفيديو النهائي.\n"
            "بعد إنشاء الفيديو النهائي، انقر على OK في التنبيه المنبثق الذي سيظهر.\n"
            "ثم سيتم تحويلك تلقائياً إلى علامة التبويب 'الفيديو النهائي' لمعاينة الفيديو.\n"
            "انقر على OK لتجاهل هذا الإشعار."
        ),
        "normal_mode_message": (
            "يرجى مراجعة المحتوى المُنشأ:\n"
            "١. في علامة التبويب 'مراجعة أو تعديل نص الحوار'، يرجى مراجعة/تعديل النص المُنشأ.\n"
            "٢. ثم انقر على زر 'حفظ وإعادة إنشاء نص الحوار' ليتم تحويلك إلى "
            "علامة التبويب 'مراجعة أو تعديل مقاطع الفيديو والموسيقى' للمراجعة.\n"
            "بعد الانتهاء من المراجعة، انقر على زر 'إنشاء الفيديو النهائي' لإنشاء الفيديو النهائي.\n"
            "بعد إنشاء الفيديو النهائي، انقر على OK في التنبيه المنبثق الذي سيظهر.\n"
            "ثم سيتم تحويلك تلقائياً إلى علامة التبويب 'الفيديو النهائي' لمعاينة الفيديو.\n"
            "انقر على OK لتجاهل هذا الإشعار."
        ),
        # Buttons
        "add_media_btn": "إضافة وسائط",
        "add_music_btn": "إضافة موسيقى",
        # Placeholders
        "no_file_placeholder": "لا يوجد ملف",
        "none_text": "لا شيء",
        # ToolTips
        "switch_account_tooltip": "حدد هذا المربع إذا كنت تريد تسجيل الدخول بحساب يوتيوب مختلف",
        "target_language_tooltip": "حدد لغة الواجهة للترجمات",
        "prompt_tooltip": (
            "قدم وصفاً شاملاً لمحتوى الفيديو الذي ترغب في إنشائه.\n"
            "قم بتضمين المواضيع الرئيسية والأسلوب المطلوب وجميع التفاصيل الأساسية لتوجيه عملية إنشاء الفيديو.\n"
            "يمكنك كتابة النص بأي لغة؛ سيتم إنتاج الفيديو باللغة المحددة.\n"
            "سيشكل الناتج النهائي نصاً للفيديو يمكنك مراجعته لاحقاً."
        ),
        "modify_tooltip": (
            "اختر 'نعم' (الافتراضي) للسماح بتعديل الكلمات المفتاحية المستخرجة من النص؛ اختيار 'لا' يحتفظ بالكلمات المفتاحية الأصلية\n"
            "هذه الكلمات المفتاحية تحدد اختيار الوسائط التي سيتم تنزيلها؛ المزيد من الكلمات المفتاحية قد ينتج عنه المزيد من الوسائط (وفيديوهات أطول)،\n"
            "بينما الكلمات المفتاحية الأكثر دقة تنتج محتوى أكثر صلة.\n"
            "ملاحظة: إذا استخدمت لغة غير الإنجليزية للنص، سيتم إضافة كلمات مفتاحية باللغة الإنجليزية تلقائياً للحصول على أفضل النتائج."
        ),
        "modify_yes_tooltip": "نعم: السماح بتعديل الكلمات المفتاحية المستخرجة",
        "modify_no_tooltip": "لا: استخدام الكلمات المفتاحية المولدة أصلاً",
        "bypass_tooltip": (
            "عند اختيار 'نعم'، سيتم تجاوز توليد ومعالجة النص والترجمات والتعليق الصوتي\n"
            "مثال: فيديوهات التأمل أو الاسترخاء.\n"
            "عند اختيار 'لا' (الافتراضي)، سيتم توليد النص والترجمات والتعليق الصوتي."
        ),
        "bypass_yes_tooltip": "نعم: تجاوز توليد النص والترجمات والتعليق الصوتي",
        "bypass_no_tooltip": "لا: توليد النص والترجمات والتعليق الصوتي",

        # Buttons
        "play_button": "تشغيل",
        "pause_button": "إيقاف مؤقت",
        "forward_button": "تقديم (+10 ث)",
        "backward_button": "إرجاع (-10 ث)",
        "browse_button": "تصفح",

        # Window Titles
        "success_text": "نجاح",
        "video_preview_title": "معاينة الفيديو: ",
        "music_preview_title": "معاينة الموسيقى: ",
        "voice_selector_title": "اختيار الصوت",
        "upload_details_title": "تفاصيل الرفع",
        "modify_keywords_title": "تعديل الكلمات المفتاحية",

        # Progress Messages
        "uploading_video": "جاري رفع الفيديو إلى يوتيوب... يرجى الانتظار.",
        "uploading_thumbnail": "جاري رفع الصورة المصغرة... يرجى الانتظار.",
        "generating_final_video": "جاري إنشاء الفيديو النهائي... يرجى الانتظار.",
        "saving_subtitles": "جاري حفظ النص وإعادة توليد ملف SRT",
        "replacing_media": "جاري استبدال الوسائط المحددة... يرجى الانتظار.",
        "deleting_clips": "جاري حذف المقاطع المحددة... يرجى الانتظار.",
        "inserting_media": "جاري إدراج وسائط جديدة... يرجى الانتظار.",
        "inserting_music": "جاري إدراج موسيقى جديدة... يرجى الانتظار.",
        "starting_video": "جاري بدء إنشاء الفيديو... يرجى الانتظار.",

        # Info Messages
        "upload_success": "✅ تم رفع الفيديو إلى يوتيوب بنجاح!",
        "upload_failure": "❌ حدث خطأ أثناء الرفع.",
        "upload_cancelled": "تم إلغاء الرفع من قبل المستخدم.",
        "subtitle_error": "❌ حدث خطأ أثناء معالجة الترجمات: ",
        "select_media_warning": "يرجى اختيار خلية وسائط للاستبدال.",
        "unsupported_file": "نوع الملف المحدد غير مدعوم.",
        "replace_media_error": "❌ حدث خطأ أثناء استبدال الوسائط المحددة: ",
        "no_items_selected": "لم يتم تحديد وسائط أو موسيقى أو ترجمات للحذف.",
        "delete_error": "❌ حدث خطأ أثناء حذف المقاطع: ",
        "insert_media_error": "❌ حدث خطأ أثناء إدراج وسائط جديدة: ",
        "video_success_bypass": "تم إكمال إنشاء الفيديو بنجاح (وضع التجاوز).",
        "video_success": "تم إكمال إنشاء الفيديو بنجاح.",
        "encoding_error": "❌ خطأ في ترميز الفيديو في العملية المنفصلة.",
        "review_content_title": "معلومات - مراجعة المحتوى",
        "title_required": "يرجى إدخال عنوان للفيديو.",
        "platform_required": "يرجى اختيار منصة.",
        "prompt_required": "يرجى إدخال نص توجيهي للفيديو.",
        "video_not_found": "لم يتم العثور على ملف الفيديو: ",
        "playback_error": "❌ حدث خطأ أثناء تشغيل الفيديو: ",
        "invalid_platform": "❌ إعدادات منصة غير صالحة لـ .",

        # Status Messages
        "encoding_complete": "اكتمل ترميز الفيديو بنجاح.",
        "encoding_error_status": "❌ خطأ في ترميز الفيديو في العملية المنفصلة.",
        "general_error": "❌ حدث خطأ: ",
        "playing_video": "جاري تشغيل الفيديو: ",
        "subtitles_saved": "تم حفظ الترجمات وبدأ توليد التعليق الصوتي...",
        "items_deleted": "✅ تم حذف العناصر المحددة.",
        "no_media_found": "❌ لم يتم العثور على ملفات فيديو أو صور في ",
        "video_processing_error": "❌ خطأ في معالجة ملف الفيديو : ",
        "image_processing_error": "❌ خطأ في معالجة ملف الصورة : ",
        "no_valid_clips": "❌ لم يتم معالجة أي مقاطع صالحة.",
        "invalid_voiceover": "❌ مدة التعليق الصوتي غير صالحة. إلغاء العملية.",
        "no_music_files": "❌ لم يتم العثور على ملفات موسيقى؛ تعيين قائمة المقاطع الموسيقية كقائمة فارغة.",
        "review_aborted": "تم إلغاء المراجعة من قبل المستخدم. تم إلغاء إنشاء الفيديو.",
        "video_creation_started": "بدأ إنشاء الفيديو...",
        "creating_video": "بدء - إنشاء فيديو بعنوان: ",
        "video_in_progress": "قيد التنفيذ - إنشاء فيديو بعنوان: ",
        "main_execution_error": "❌ خطأ في التنفيذ الرئيسي: ",

        # Dialog Messages
        "enter_keywords": "أدخل الكلمات المفتاحية الجديدة، مفصولة بفواصل:",
        "description_label": "الوصف:",
        "tags_label": "العلامات (مفصولة بفواصل):",
        "privacy_label": "الخصوصية:",
        "thumbnail_label": "الصورة المصغرة:",
        "category_label": "الفئة:",
        "video_language_label": "لغة الفيديو:",
        "recording_date_label": "تاريخ التسجيل:",
        "switch_account_label": "تبديل حساب يوتيوب",
        "select_thumbnail": "اختر الصورة المصغرة",
        "image_files_filter": "ملفات الصور (*.png *.jpg *.jpeg)",
        "select_platform_title": "اختر المنصة",
        "select_platform_prompt": "اختر منصة التواصل الاجتماعي:",
        "loading_clips_message": "جارٍ تحميل المقاطع والنص... يرجى الانتظار.",
        "moving_media_message": "جارٍ نقل مقطع الوسائط... يرجى الانتظار.",
        "processing_subtitles_message": "جارٍ معالجة النص... يرجى الانتظار.",
        "loading_title": "جارٍ التحميل",
        "processing_title": "جارٍ المعالجة",
        "support_tab": "الدعم",
        "check_faq_label": "يرجى التحقق أولاً من الأسئلة الشائعة لدينا:",
        "faq_link_text": "انقر هنا للاطلاع على الأسئلة الشائعة",
        "sr_number_label": "رقم SR",
        "customer_name_label": "اسم العميل",
        "email_label": "البريد الإلكتروني",
        "phone_label": "الهاتف",
        "ticket_type_label": "نوع التذكرة",
        "issue_description_label": "وصف المشكلة",
        "video_name_label": "اسم الفيديو",
        "creation_dt_label": "تاريخ/وقت الإنشاء (تقديري)",
        "desc_label": "الوصف",
        "send_button": "إرسال التذكرة",
        "sr_sent_title": "تم إرسال التذكرة",
        "sr_sent_msg": "تم إرسال طلب الدعم الخاص بك بنجاح!"
    },
    # Spanish
    "es": {
        "missing_required_title": "Campos obligatorios faltantes",
        "missing_required_msg": "Por favor, complete todos los campos obligatorios:\n",
        "issue_option": "Problema",
        "enh_option":   "Mejora",
        "comment_option": "Comentario",
        "coming_soon_title":       "Próximamente",
        "coming_soon_msg": (
            "La integración para {} estará disponible pronto.\n\n"
            "Por favor sube el vídeo final manualmente.\n"
            "Ruta del vídeo: {}"
        ),
        "youtube_shorts_reminder_title": "Recordatorio de YouTube Shorts",
        "youtube_shorts_reminder_msg": (
            "NOTA: Los YouTube Shorts están destinados a videos de 60 segundos o menos. "
            "Por favor, asegúrate de que tu video cumpla con el requisito de duración para YouTube Shorts."
        ),
        "file_not_found_title":    "⚠️ ADVERTENCIA: Archivo no encontrado",
        "file_not_found_msg": (
            "No se encontró el archivo de vídeo final para {}. "
            "Es posible que no lo hayas generado para esta plataforma. "
            "Por favor, genera el vídeo y vuelve a intentarlo."
        ),
        "yes":            "Sí",
        "no":             "No",
        "video":          "Vídeo",
        "image":          "Imagen",
        "info":           "Información",
        "switch_account": "Cambiar cuenta",
        "main_tab_title": "Principal",
        "target_language_label": "Idioma de destino:",
        "voice_label": "Seleccione la voz del narrador:",
        "video_title_label": "Título del video:",
        "platform_label": "Plataforma:",
        "prompt_label": "Ingrese el mensaje para el contenido del video (en cualquier idioma):",
        "genre_label": "Seleccione el género instrumental:",
        "modify_label": "¿Modificar palabras clave?",
        "bypass_label": "¿Omitir texto, subtítulos y voz en off?",
        "status_label": "Estado:",
        "save_subtitles_btn": "Guardar y regenerar subtítulos",
        "start_video_btn": "Iniciar creación del video",
        "play_video_btn_final": "Reproducir video",
        "replace_clip_btn": "Reemplazar clip seleccionado",
        "delete_clip_btn": "Eliminar clips seleccionados",
        "base_directory_label": "Directorio base:",
        "base_browse_btn": "Explorar",
        "video_image_folder_label": "Carpeta de imágenes del video:",
        "output_directory_label": "Directorio de salida:",
        "music_folder_label": "Carpeta de música:",
        "voiceover_directory_label": "Directorio de voz en off:",
        "review_script_tab": "Revisar o editar el guión",
        "review_clips_tab": "Revisar o editar clips y subtítulos",
        "test_voice_button": "Probar voz",
        "generate_final_video_btn": "Generar video final",
        "final_video_tab": "Video final",
        "upload_video_btn": "Subir a redes sociales",
        "clip_table_headers": [
            "Seleccionar", "Vista previa", "Tipo de medio", "Archivo de medio", "Duración",
            "Inicio", "Fin", "Seleccionar", "Vista previa música", "Archivo de música",
            "Duración música", "Inicio música", "Fin música", "Subtítulo", "Inicio subtítulo", "Fin subtítulo"
        ],
        "editable_field_tooltip": "Campo editable",
        "readonly_field_tooltip": "Campo de solo lectura",
        "bypass_mode_message": (
            "Como seleccionó el modo de omisión de guión, subtítulos y voz en off, "
            "no se generaron guión/subtítulos/voz en off.\n"
            "Por favor, revise los medios descargados en la pestaña 'Revisar o editar clips y subtítulos'.\n"
            "Después de terminar la revisión, haga clic en el botón 'Generar video final' para generar el video final.\n"
            "Después de que se genere el video final, haga clic en OK en la alerta emergente que aparecerá.\n"
            "Luego, será transferido automáticamente a la pestaña 'Video final' para previsualizar el video.\n"
            "Haga clic en OK para descartar esta notificación."
        ),
        "normal_mode_message": (
            "Por favor, revise el contenido generado:\n"
            "1. En la pestaña 'Revisar o editar el guión', por favor revise/edite el guión generado.\n"
            "2. Luego, haga clic en el botón 'Guardar y regenerar subtítulos' para ser transferido a "
            "la pestaña 'Revisar o editar clips y subtítulos' para revisión.\n"
            "Después de terminar la revisión, haga clic en el botón 'Generar video final' para generar el video final.\n"
            "Después de que se genere el video final, haga clic en OK en la alerta emergente que aparecerá.\n"
            "Luego, será transferido automáticamente a la pestaña 'Video final' para previsualizar el video.\n"
            "Haga clic en OK para descartar esta notificación."
        ),
        "add_media_btn": "Agregar medio",
        "add_music_btn": "Agregar música",
        "no_file_placeholder": "Sin archivo",
        "none_text": "Ninguno",
        # ToolTips
        "switch_account_tooltip": "Marque esta casilla si desea iniciar sesión con una cuenta diferente de YouTube",
        "target_language_tooltip": "Seleccione el idioma de destino para las traducciones de la interfaz",
        "prompt_tooltip": (
            "Proporcione una descripción detallada del contenido del video que desea crear.\n"
            "Incluya temas clave, estilo deseado y todos los detalles esenciales para guiar el proceso de generación del video.\n"
            "Puede escribir el texto en cualquier idioma; el video se producirá en el idioma seleccionado.\n"
            "La salida generada formará un guión de video que podrá revisar más tarde."
        ),
        "modify_tooltip": (
            "Elija 'Sí' (predeterminado) para permitir la edición de palabras clave extraídas del guión; 'No' mantiene las palabras clave originales\n"
            "Estas palabras clave determinan la selección de medios a descargar; más palabras clave pueden generar más medios (y videos más largos),\n"
            "mientras que palabras clave más precisas producen contenido más relevante.\n"
            "Nota: Si usa un idioma diferente al inglés, se añadirán automáticamente palabras clave en inglés para obtener resultados óptimos."
        ),
        "modify_yes_tooltip": "Sí: Permitir modificaciones a las palabras clave extraídas",
        "modify_no_tooltip": "No: Usar las palabras clave generadas originalmente",
        "bypass_tooltip": (
            "Cuando se establece en 'Sí', se omitirá la generación y procesamiento de texto, subtítulos y voz en off\n"
            "Ejemplo: videos de meditación o relajación.\n"
            "Cuando se establece en 'No' (predeterminado), se generan texto, subtítulos y voz en off."
        ),
        "bypass_yes_tooltip": "Sí: Omitir generación de texto, subtítulos y voz en off",
        "bypass_no_tooltip": "No: Generar texto, subtítulos y voz en off",

        # Buttons
        "play_button": "Reproducir",
        "pause_button": "Pausar",
        "forward_button": "Adelantar (+10 s)",
        "backward_button": "Retroceder (-10 s)",
        "browse_button": "Explorar",

        # Window Titles
        "success_text": "Éxito",
        "video_preview_title": "Vista previa del video: ",
        "music_preview_title": "Vista previa de música: ",
        "voice_selector_title": "Selector de voz",
        "upload_details_title": "Detalles de carga",
        "modify_keywords_title": "Modificar palabras clave",

        # Progress Messages
        "uploading_video": "Subiendo video a YouTube... Por favor espere.",
        "uploading_thumbnail": "Subiendo miniatura... Por favor espere.",
        "generating_final_video": "Generando video final... Por favor espere.",
        "saving_subtitles": "Guardando subtítulos y regenerando SRT",
        "replacing_media": "Reemplazando medios seleccionados... Por favor espere.",
        "deleting_clips": "Eliminando clip(s) seleccionado(s)... Por favor espere.",
        "inserting_media": "Insertando nuevos medios... Por favor espere.",
        "inserting_music": "Insertando nueva música... Por favor espere.",
        "starting_video": "Iniciando creación de video... Por favor espere.",

        # Info Messages
        "upload_success": "✅ ¡Carga de video a YouTube completada con éxito!",
        "upload_failure": "❌ Ocurrió un error durante la carga.",
        "upload_cancelled": "La carga fue cancelada por el usuario.",
        "subtitle_error": "❌ Ocurrió un error durante el procesamiento de subtítulos: ",
        "select_media_warning": "Por favor seleccione una celda de medios para reemplazar.",
        "unsupported_file": "El tipo de archivo seleccionado no es compatible.",
        "replace_media_error": "❌ Ocurrió un error al reemplazar los medios seleccionados: ",
        "no_items_selected": "No hay medios, música o subtítulos seleccionados para eliminar.",
        "delete_error": "❌ Ocurrió un error al eliminar clips: ",
        "insert_media_error": "❌ Ocurrió un error al insertar nuevos medios: ",
        "video_success_bypass": "Creación de video completada con éxito (modo bypass).",
        "video_success": "Creación de video completada con éxito.",
        "encoding_error": "❌ Error al codificar video en proceso separado.",
        "review_content_title": "Información - Revisar contenido",
        "title_required": "Por favor ingrese un título para el video.",
        "platform_required": "Por favor seleccione una plataforma.",
        "prompt_required": "Por favor ingrese un texto guía para el video.",
        "video_not_found": "Archivo de video no encontrado: ",
        "playback_error": "❌ Ocurrió un error al reproducir el video: ",
        "invalid_platform": "❌ Configuración de plataforma inválida para .",

        # Status Messages
        "encoding_complete": "Codificación de video completada con éxito.",
        "encoding_error_status": "❌ Error al codificar video en proceso separado.",
        "general_error": "❌ Ocurrió un error: ",
        "playing_video": "Reproduciendo video: ",
        "subtitles_saved": "Subtítulos guardados e iniciando generación de voz en off...",
        "items_deleted": "✅ Elementos seleccionados eliminados.",
        "no_media_found": "❌ No se encontraron archivos de video o imagen en ",
        "video_processing_error": "❌ Error al procesar archivo de video : ",
        "image_processing_error": "❌ Error al procesar archivo de imagen : ",
        "no_valid_clips": "❌ No se pudieron procesar clips válidos.",
        "invalid_voiceover": "❌ Duración de voz en off inválida. Abortando.",
        "no_music_files": "❌ No se encontraron archivos de música; estableciendo clips de música como lista vacía.",
        "review_aborted": "Revisión abortada por el usuario. Creación de video cancelada.",
        "video_creation_started": "Creación de video iniciada...",
        "creating_video": "Iniciando - Creando video titulado: ",
        "video_in_progress": "En progreso - Creando video titulado: ",
        "main_execution_error": "❌ Error en ejecución principal: ",

        # Dialog Messages
        "enter_keywords": "Ingrese las nuevas palabras clave, separadas por comas:",
        "description_label": "Descripción:",
        "tags_label": "Etiquetas (separadas por comas):",
        "privacy_label": "Privacidad:",
        "thumbnail_label": "Miniatura:",
        "category_label": "Categoría:",
        "video_language_label": "Idioma del video:",
        "recording_date_label": "Fecha de grabación:",
        "switch_account_label": "Cambiar cuenta de YouTube",
        "select_thumbnail": "Seleccionar miniatura",
        "image_files_filter": "Archivos de imagen (*.png *.jpg *.jpeg)",
        "select_platform_title": "Seleccionar plataforma",
        "select_platform_prompt": "Elija una plataforma de redes sociales:",
        "loading_clips_message": "Cargando clips y subtítulos... Por favor espere.",
        "moving_media_message": "Moviendo clip multimedia... Por favor espere.",
        "processing_subtitles_message": "Procesando subtítulos... Por favor espere.",
        "loading_title": "Cargando",
        "processing_title": "Procesando",
        "support_tab": "Soporte",
        "check_faq_label": "Por favor, revise primero nuestras Preguntas Frecuentes:",
        "faq_link_text": "Haga clic aquí para FAQ",
        "sr_number_label": "Número SR",
        "customer_name_label": "Nombre del cliente",
        "email_label": "Correo electrónico",
        "phone_label": "Teléfono",
        "ticket_type_label": "Tipo de Ticket",
        "issue_description_label": "Descripción del problema",
        "video_name_label": "Nombre del video",
        "creation_dt_label": "Fecha/Hora de creación (tentativa)",
        "desc_label": "Descripción",
        "send_button": "Enviar Ticket",
        "sr_sent_title": "Ticket Enviado",
        "sr_sent_msg": "¡Su solicitud de soporte se ha enviado correctamente!"
    },
    # Frensh
    "fr": {
        "missing_required_title": "Champs obligatoires manquants",
        "missing_required_msg": "Veuillez remplir tous les champs obligatoires:\n",
        "issue_option": "Problème",
        "enh_option":   "Amélioration",
        "comment_option": "Commentaire",
        "coming_soon_title":       "Bientôt disponible",
        "coming_soon_msg": (
            "L'intégration pour {} sera bientôt disponible.\n\n"
            "Veuillez télécharger manuellement la vidéo finale.\n"
            "Chemin de la vidéo : {}"
        ),
        "youtube_shorts_reminder_title": "Rappel YouTube Shorts",
        "youtube_shorts_reminder_msg": (
            "REMARQUE : les YouTube Shorts sont destinés à des vidéos de 60 secondes ou moins. "
            "Veuillez vous assurer que votre vidéo répond à cette exigence de durée pour les YouTube Shorts."
        ),
        "file_not_found_title":    "⚠️ AVERTISSEMENT : fichier introuvable",
        "file_not_found_msg": (
            "Fichier vidéo final pour {} introuvable. "
            "Vous ne l'avez peut-être pas généré pour cette plateforme. "
            "Veuillez le générer et réessayer."
        ),
        "yes": "Oui",
        "no": "Non",
        "video": "Vidéo",
        "image": "Image",
        "info": "Info",
        "switch_account": "Changer de compte",
        "main_tab_title": "Principal",
        "target_language_label": "Langue cible:",
        "voice_label": "Sélectionnez la voix du narrateur :",
        "video_title_label": "Titre de la vidéo :",
        "platform_label": "Plateforme :",
        "prompt_label": "Entrez l'invite pour le contenu vidéo (dans n'importe quelle langue) :",
        "genre_label": "Sélectionnez le genre instrumental :",
        "modify_label": "Modifier les mots-clés ?",
        "bypass_label": "Contourner le texte, les sous-titres et la voix-off ?",
        "status_label": "Statut :",
        "save_subtitles_btn": "Enregistrer et régénérer les sous-titres",
        "start_video_btn": "Démarrer la création de la vidéo",
        "play_video_btn_final": "Lire la vidéo",
        "replace_clip_btn": "Remplacer le clip sélectionné",
        "delete_clip_btn": "Supprimer les clips sélectionnés",
        "base_directory_label": "Répertoire de base :",
        "base_browse_btn": "Parcourir",
        "video_image_folder_label": "Dossier d'images vidéo :",
        "output_directory_label": "Répertoire de sortie :",
        "music_folder_label": "Dossier de musique :",
        "voiceover_directory_label": "Répertoire de la voix off :",
        "review_script_tab": "Réviser ou modifier le script",
        "review_clips_tab": "Réviser ou modifier les clips et sous-titres",
        "test_voice_button": "Tester la voix",
        "generate_final_video_btn": "Générer la vidéo finale",
        "final_video_tab": "Vidéo finale",
        "upload_video_btn": "Télécharger sur les réseaux sociaux",
        "clip_table_headers": [
            "Sélectionner", "Aperçu média", "Type de média", "Fichier média", "Durée média",
            "Début média", "Fin média", "Sélectionner", "Aperçu musique", "Fichier musique",
            "Durée musique", "Début musique", "Fin musique", "Sous-titre", "Début sous-titre", "Fin sous-titre"
        ],
        "editable_field_tooltip": "Champ modifiable",
        "readonly_field_tooltip": "Champ en lecture seule",
        "bypass_mode_message": (
            "Puisque vous avez sélectionné le mode de contournement du script, des sous-titres et de la voix off, "
            "aucun script/sous-titre/voix off n'a été généré.\n"
            "Veuillez examiner les médias téléchargés dans l'onglet 'Réviser ou modifier les clips et sous-titres'.\n"
            "Une fois l'examen terminé, cliquez sur le bouton 'Générer la vidéo finale' pour générer la vidéo finale.\n"
            "Après la génération de la vidéo finale, cliquez sur OK dans l'alerte qui apparaîtra.\n"
            "Vous serez ensuite automatiquement dirigé vers l'onglet 'Vidéo finale' pour prévisualiser la vidéo.\n"
            "Cliquez sur OK pour fermer cette notification."
        ),
        "normal_mode_message": (
            "Veuillez examiner le contenu généré :\n"
            "1. Dans l'onglet 'Réviser ou modifier le script', veuillez examiner/modifier le script généré.\n"
            "2. Ensuite, cliquez sur le bouton 'Enregistrer et régénérer les sous-titres' pour être dirigé vers "
            "l'onglet 'Réviser ou modifier les clips et sous-titres' pour examen.\n"
            "Une fois l'examen terminé, cliquez sur le bouton 'Générer la vidéo finale' pour générer la vidéo finale.\n"
            "Après la génération de la vidéo finale, cliquez sur OK dans l'alerte qui apparaîtra.\n"
            "Vous serez ensuite automatiquement dirigé vers l'onglet 'Vidéo finale' pour prévisualiser la vidéo.\n"
            "Cliquez sur OK pour fermer cette notification."
        ),
        "add_media_btn": "Ajouter média",
        "add_music_btn": "Ajouter musique",
        "no_file_placeholder": "Pas de fichier",
        "none_text": "Aucun",
        # ToolTips
        "switch_account_tooltip": "Cochez cette case si vous souhaitez vous connecter avec un autre compte YouTube",
        "target_language_tooltip": "Sélectionnez la langue cible pour les traductions de l'interface",
        "prompt_tooltip": (
            "Fournissez une description détaillée du contenu vidéo que vous souhaitez créer.\n"
            "Incluez les sujets clés, le style souhaité et tous les détails essentiels pour guider le processus de génération vidéo.\n"
            "Vous pouvez écrire le texte dans n'importe quelle langue ; la vidéo sera produite dans la langue sélectionnée.\n"
            "La sortie générée formera un script vidéo que vous pourrez examiner ultérieurement."
        ),
        "modify_tooltip": (
            "Choisissez 'Oui' (par défaut) pour permettre la modification des mots-clés extraits du script ; 'Non' conserve les mots-clés originaux\n"
            "Ces mots-clés déterminent la sélection des médias à télécharger ; plus de mots-clés peuvent générer plus de médias (et des vidéos plus longues),\n"
            "tandis que des mots-clés plus précis produisent un contenu plus pertinent.\n"
            "Note : Si vous utilisez une langue autre que l'anglais, des mots-clés en anglais seront automatiquement ajoutés pour des résultats optimaux."
        ),
        "modify_yes_tooltip": "Oui : Permettre les modifications des mots-clés extraits",
        "modify_no_tooltip": "Non : Utiliser les mots-clés générés initialement",
        "bypass_tooltip": (
            "Lorsque défini sur 'Oui', la génération et le traitement du texte, des sous-titres et de la voix off seront contournés\n"
            "Exemple : vidéos de méditation ou de relaxation.\n"
            "Lorsque défini sur 'Non' (par défaut), le texte, les sous-titres et la voix off sont générés."
        ),
        "bypass_yes_tooltip": "Oui : Contourner la génération de texte, sous-titres et voix off",
        "bypass_no_tooltip": "Non : Générer le texte, les sous-titres et la voix off",

        # Buttons
        "play_button": "Lecture",
        "pause_button": "Pause",
        "forward_button": "Avancer (+10 s)",
        "backward_button": "Reculer (-10 s)",
        "browse_button": "Parcourir",

        # Window Titles
        "success_text": "Succès",
        "video_preview_title": "Aperçu vidéo : ",
        "music_preview_title": "Aperçu musical : ",
        "voice_selector_title": "Sélecteur de voix",
        "upload_details_title": "Détails du téléchargement",
        "modify_keywords_title": "Modifier les mots-clés",

        # Progress Messages
        "uploading_video": "Téléchargement de la vidéo vers YouTube... Veuillez patienter.",
        "uploading_thumbnail": "Téléchargement de la miniature... Veuillez patienter.",
        "generating_final_video": "Génération de la vidéo finale... Veuillez patienter.",
        "saving_subtitles": "Sauvegarde des sous-titres et régénération du SRT",
        "replacing_media": "Remplacement des médias sélectionnés... Veuillez patienter.",
        "deleting_clips": "Suppression du/des clip(s) sélectionné(s)... Veuillez patienter.",
        "inserting_media": "Insertion de nouveaux médias... Veuillez patienter.",
        "inserting_music": "Insertion de nouvelle musique... Veuillez patienter.",
        "starting_video": "Démarrage de la création vidéo... Veuillez patienter.",

        # Info Messages
        "upload_success": "✅ Téléchargement YouTube terminé avec succès !",
        "upload_failure": "❌ Une erreur s'est produite lors du téléchargement.",
        "upload_cancelled": "Le téléchargement a été annulé par l'utilisateur.",
        "subtitle_error": "❌ Une erreur s'est produite lors du traitement des sous-titres : ",
        "select_media_warning": "Veuillez sélectionner une cellule média à remplacer.",
        "unsupported_file": "Le type de fichier sélectionné n'est pas pris en charge.",
        "replace_media_error": "❌ Une erreur s'est produite lors du remplacement des médias sélectionnés : ",
        "no_items_selected": "Aucun média, musique ou sous-titre sélectionné pour la suppression.",
        "delete_error": "❌ Une erreur s'est produite lors de la suppression des clips : ",
        "insert_media_error": "❌ Une erreur s'est produite lors de l'insertion de nouveaux médias : ",
        "video_success_bypass": "Création vidéo terminée avec succès (mode contournement).",
        "video_success": "Création vidéo terminée avec succès.",
        "encoding_error": "❌ Erreur lors de l'encodage vidéo dans un processus séparé.",
        "review_content_title": "Information - Examiner le contenu",
        "title_required": "Veuillez saisir un titre pour la vidéo.",
        "platform_required": "Veuillez sélectionner une plateforme.",
        "prompt_required": "Veuillez saisir un texte guide pour la vidéo.",
        "video_not_found": "Fichier vidéo non trouvé : ",
        "playback_error": "❌ Une erreur s'est produite lors de la lecture de la vidéo : ",
        "invalid_platform": "❌ Paramètres de plateforme invalides pour .",

        # Status Messages
        "encoding_complete": "Encodage vidéo terminé avec succès.",
        "encoding_error_status": "❌ Erreur lors de l'encodage vidéo dans un processus séparé.",
        "general_error": "❌ Une erreur s'est produite : ",
        "playing_video": "Lecture de la vidéo : ",
        "subtitles_saved": "Sous-titres sauvegardés et génération de la voix off démarrée...",
        "items_deleted": "✅ Éléments sélectionnés supprimés.",
        "no_media_found": "❌ Aucun fichier vidéo ou image trouvé dans ",
        "video_processing_error": "❌ Erreur lors du traitement du fichier vidéo  : ",
        "image_processing_error": "❌ Erreur lors du traitement du fichier image  : ",
        "no_valid_clips": "❌ Aucun clip valide n'a pu être traité.",
        "invalid_voiceover": "❌ Durée de voix off invalide. Abandon.",
        "no_music_files": "❌ Aucun fichier musical trouvé ; définition de la liste des clips musicaux comme vide.",
        "review_aborted": "Examen annulé par l'utilisateur. Création vidéo annulée.",
        "video_creation_started": "Création vidéo démarrée...",
        "creating_video": "Initialisation - Création de la vidéo intitulée : ",
        "video_in_progress": "En cours - Création de la vidéo intitulée : ",
        "main_execution_error": "❌ Erreur dans l'exécution principale : ",

        # Dialog Messages
        "enter_keywords": "Entrez les nouveaux mots-clés, séparés par des virgules :",
        "description_label": "Description :",
        "tags_label": "Tags (séparés par des virgules) :",
        "privacy_label": "Confidentialité :",
        "thumbnail_label": "Miniature :",
        "category_label": "Catégorie :",
        "video_language_label": "Langue de la vidéo :",
        "recording_date_label": "Date d'enregistrement :",
        "switch_account_label": "Changer de compte YouTube",
        "select_thumbnail": "Sélectionner une miniature",
        "image_files_filter": "Fichiers image (*.png *.jpg *.jpeg)",
        "select_platform_title": "Sélectionner une plateforme",
        "select_platform_prompt": "Choisissez une plateforme de médias sociaux :",
        "loading_clips_message": "Chargement des clips et sous-titres... Veuillez patienter.",
        "moving_media_message": "Déplacement du clip média... Veuillez patienter.",
        "processing_subtitles_message": "Traitement des sous-titres... Veuillez patienter.",
        "loading_title": "Chargement",
        "processing_title": "Traitement",
        "support_tab": "Support",
        "check_faq_label": "Veuillez d'abord consulter notre FAQ :",
        "faq_link_text": "Cliquez ici pour la FAQ",
        "sr_number_label": "Numéro SR",
        "customer_name_label": "Nom du client",
        "email_label": "Email",
        "phone_label": "Téléphone",
        "ticket_type_label": "Type de ticket",
        "issue_description_label": "Description du problème",
        "video_name_label": "Nom de la vidéo",
        "creation_dt_label": "Date/Heure de création (prévision)",
        "desc_label": "Description",
        "send_button": "Envoyer le ticket",
        "sr_sent_title": "Ticket envoyé",
        "sr_sent_msg": "Votre demande de support a été envoyée avec succès !"
    },
    # German
    "de": {
        "missing_required_title": "Fehlende Pflichtfelder",
        "missing_required_msg": "Bitte füllen Sie alle erforderlichen Felder aus:\n",
        "issue_option": "Problem",
        "enh_option":   "Verbesserung",
        "comment_option": "Kommentar",
        "coming_soon_title":       "Kommt bald",
        "coming_soon_msg": (
            "Die Integration für {} kommt bald.\n\n"
            "Bitte lade das fertige Video manuell hoch.\n"
            "Videopfad: {}"
        ),
        "youtube_shorts_reminder_title": "YouTube Shorts Erinnerung",
        "youtube_shorts_reminder_msg": (
            "HINWEIS: YouTube Shorts sind für Videos von 60 Sekunden oder weniger gedacht. "
            "Bitte stelle sicher, dass dein Video die Längenanforderung für YouTube Shorts erfüllt."
        ),
        "file_not_found_title":    "⚠️ WARNUNG: Datei nicht gefunden",
        "file_not_found_msg": (
            "Die endgültige Videodatei für {} wurde nicht gefunden. "
            "Möglicherweise haben Sie sie für diese Plattform nicht erstellt. "
            "Bitte erstellen Sie sie und versuchen Sie es erneut."
        ),
        "yes":            "Ja",
        "no":             "Nein",
        "video":          "Video",
        "image":          "Bild",
        "info":           "Info",
        "switch_account": "Konto wechseln",
        "main_tab_title": "Haupt",
        "target_language_label": "Zielsprache:",
        "voice_label": "Wählen Sie die Sprecherstimme:",
        "video_title_label": "Videotitel:",
        "platform_label": "Plattform:",
        "prompt_label": "Geben Sie den Text für den Videoinhalt ein (in jeder Sprache):",
        "genre_label": "Wählen Sie das instrumentale Genre:",
        "modify_label": "Schlüsselwörter ändern?",
        "bypass_label": "Text, Untertitel und Voiceover überspringen?",
        "status_label": "Status:",
        "save_subtitles_btn": "Untertitel speichern und neu generieren",
        "start_video_btn": "Videoerstellung starten",
        "play_video_btn_final": "Video abspielen",
        "replace_clip_btn": "Ausgewählten Clip ersetzen",
        "delete_clip_btn": "Ausgewählte Clips löschen",
        "base_directory_label": "Basisverzeichnis:",
        "base_browse_btn": "Durchsuchen",
        "video_image_folder_label": "Video-Bildordner:",
        "output_directory_label": "Ausgabeverzeichnis:",
        "music_folder_label": "Musikordner:",
        "voiceover_directory_label": "Voiceover-Verzeichnis:",
        "review_script_tab": "Skript überprüfen oder bearbeiten",
        "review_clips_tab": "Clips und Untertitel überprüfen oder bearbeiten",
        "test_voice_button": "Stimme testen",
        "generate_final_video_btn": "Finales Video generieren",
        "final_video_tab": "Finales Video",
        "upload_video_btn": "In sozialen Medien hochladen",
        "clip_table_headers": [
            "Auswählen", "Medienvorschau", "Medientyp", "Mediendatei", "Mediendauer",
            "Medienstart", "Medienende", "Auswählen", "Musikvorschau", "Musikdatei",
            "Musikdauer", "Musikstart", "Musikende", "Untertitel", "Untertitelstart", "Untertitelende"
        ],
        "editable_field_tooltip": "Bearbeitbares Feld",
        "readonly_field_tooltip": "Schreibgeschütztes Feld",
        "bypass_mode_message": (
            "Da Sie den Bypass-Modus für Skript, Untertitel und Voiceover ausgewählt haben, "
            "wurden keine Skript/Untertitel/Voiceover generiert.\n"
            "Bitte überprüfen Sie die heruntergeladenen Medien im Tab 'Clips und Untertitel überprüfen oder bearbeiten'.\n"
            "Nachdem Sie die Überprüfung abgeschlossen haben, klicken Sie auf 'Finales Video generieren'.\n"
            "Nachdem das finale Video generiert wurde, klicken Sie auf OK im erscheinenden Popup-Fenster.\n"
            "Dann werden Sie automatisch zum Tab 'Finales Video' weitergeleitet, um das Video voranzusehen.\n"
            "Klicken Sie auf OK, um diese Benachrichtigung zu schließen."
        ),
        "normal_mode_message": (
            "Bitte überprüfen Sie den generierten Inhalt:\n"
            "1. Im Tab 'Skript überprüfen oder bearbeiten' überprüfen/bearbeiten Sie bitte das generierte Skript.\n"
            "2. Klicken Sie dann auf 'Untertitel speichern und neu generieren', um zum "
            "Tab 'Clips und Untertitel überprüfen oder bearbeiten' zu gelangen.\n"
            "Nachdem Sie die Überprüfung abgeschlossen haben, klicken Sie auf 'Finales Video generieren'.\n"
            "Nachdem das finale Video generiert wurde, klicken Sie auf OK im erscheinenden Popup-Fenster.\n"
            "Dann werden Sie automatisch zum Tab 'Finales Video' weitergeleitet, um das Video voranzusehen.\n"
            "Klicken Sie auf OK, um diese Benachrichtigung zu schließen."
        ),
        "add_media_btn": "Medien hinzufügen",
        "add_music_btn": "Musik hinzufügen",
        "no_file_placeholder": "Keine Datei",
        "none_text": "Keine",
        # ToolTips
        "switch_account_tooltip": "Aktivieren Sie dieses Kontrollkästchen, wenn Sie sich mit einem anderen YouTube-Konto anmelden möchten",
        "target_language_tooltip": "Wählen Sie die Zielsprache für die Benutzeroberflächen-Übersetzungen",
        "prompt_tooltip": (
            "Geben Sie eine ausführliche Beschreibung des Videoinhalts ein, den Sie erstellen möchten.\n"
            "Fügen Sie Schlüsselthemen, gewünschten Stil und alle wesentlichen Details hinzu, um den Videogenerierungsprozess zu steuern.\n"
            "Sie können den Text in jeder Sprache schreiben; das Video wird in der ausgewählten Sprache erstellt.\n"
            "Die generierte Ausgabe bildet ein Videoskript, das Sie später überprüfen können."
        ),
        "modify_tooltip": (
            "Wählen Sie 'Ja' (Standard), um die aus dem Skript extrahierten Schlüsselwörter zu bearbeiten; 'Nein' behält die ursprünglichen Schlüsselwörter bei\n"
            "Diese Schlüsselwörter bestimmen die Auswahl der herunterzuladenden Medien; mehr Schlüsselwörter können mehr Medien (und längere Videos) ergeben,\n"
            "während präzisere Schlüsselwörter relevantere Inhalte produzieren.\n"
            "Hinweis: Wenn Sie eine andere Sprache als Englisch verwenden, werden automatisch englische Schlüsselwörter für optimale Ergebnisse hinzugefügt."
        ),
        "modify_yes_tooltip": "Ja: Änderungen an extrahierten Schlüsselwörtern erlauben",
        "modify_no_tooltip": "Nein: Ursprünglich generierte Schlüsselwörter verwenden",
        "bypass_tooltip": (
            "Wenn auf 'Ja' gesetzt, wird die Generierung und Verarbeitung von Text, Untertiteln und Sprachausgabe umgangen\n"
            "Beispiel: Meditations- oder Entspannungsvideos.\n"
            "Wenn auf 'Nein' (Standard) gesetzt, werden Text, Untertitel und Sprachausgabe generiert."
        ),
        "bypass_yes_tooltip": "Ja: Text-, Untertitel- und Sprachausgabe-Generierung umgehen",
        "bypass_no_tooltip": "Nein: Text, Untertitel und Sprachausgabe generieren",

        # Buttons
        "play_button": "Abspielen",
        "pause_button": "Pause",
        "forward_button": "Vorwärts (+10 s)",
        "backward_button": "Rückwärts (-10 s)",
        "browse_button": "Durchsuchen",

        # Window Titles
        "success_text": "Erfolg",
        "video_preview_title": "Videovorschau: ",
        "music_preview_title": "Musikvorschau: ",
        "voice_selector_title": "Stimmenauswahl",
        "upload_details_title": "Upload-Details",
        "modify_keywords_title": "Schlüsselwörter bearbeiten",

        # Progress Messages
        "uploading_video": "Video wird zu YouTube hochgeladen... Bitte warten.",
        "uploading_thumbnail": "Vorschaubild wird hochgeladen... Bitte warten.",
        "generating_final_video": "Finales Video wird generiert... Bitte warten.",
        "saving_subtitles": "Untertitel werden gespeichert und SRT wird neu generiert",
        "replacing_media": "Ausgewählte Medien werden ersetzt... Bitte warten.",
        "deleting_clips": "Ausgewählte Clip(s) werden gelöscht... Bitte warten.",
        "inserting_media": "Neue Medien werden eingefügt... Bitte warten.",
        "inserting_music": "Neue Musik wird eingefügt... Bitte warten.",
        "starting_video": "Videoerstellung wird gestartet... Bitte warten.",

        # Info Messages
        "upload_success": "✅ YouTube-Video-Upload erfolgreich abgeschlossen!",
        "upload_failure": "❌ Beim Upload ist ein Fehler aufgetreten.",
        "upload_cancelled": "Upload wurde vom Benutzer abgebrochen.",
        "subtitle_error": "❌ Bei der Verarbeitung der Untertitel ist ein Fehler aufgetreten: ",
        "select_media_warning": "Bitte wählen Sie eine Medienzelle zum Ersetzen aus.",
        "unsupported_file": "Der ausgewählte Dateityp wird nicht unterstützt.",
        "replace_media_error": "❌ Beim Ersetzen der ausgewählten Medien ist ein Fehler aufgetreten: ",
        "no_items_selected": "Keine Medien, Musik oder Untertitel zum Löschen ausgewählt.",
        "delete_error": "❌ Beim Löschen der Clips ist ein Fehler aufgetreten: ",
        "insert_media_error": "❌ Beim Einfügen neuer Medien ist ein Fehler aufgetreten: ",
        "video_success_bypass": "Videoerstellung erfolgreich abgeschlossen (Bypass-Modus).",
        "video_success": "Videoerstellung erfolgreich abgeschlossen.",
        "encoding_error": "❌ Fehler beim Codieren des Videos in separatem Prozess.",
        "review_content_title": "Info - Inhalt überprüfen",
        "title_required": "Bitte geben Sie einen Videotitel ein.",
        "platform_required": "Bitte wählen Sie eine Plattform aus.",
        "prompt_required": "Bitte geben Sie einen Video-Skript-Prompt ein.",
        "video_not_found": "Videodatei nicht gefunden: ",
        "playback_error": "❌ Beim Abspielen des Videos ist ein Fehler aufgetreten: ",
        "invalid_platform": "❌ Ungültige Plattform-Einstellungen für .",

        # Status Messages
        "encoding_complete": "Videocodierung erfolgreich abgeschlossen.",
        "encoding_error_status": "❌ Fehler beim Codieren des Videos in separatem Prozess.",
        "general_error": "❌ Ein Fehler ist aufgetreten: ",
        "playing_video": "Video wird abgespielt: ",
        "subtitles_saved": "Untertitel gespeichert und Sprachausgabe-Generierung gestartet...",
        "items_deleted": "✅ Ausgewählte Elemente gelöscht.",
        "no_media_found": "❌ Keine Video- oder Bilddateien gefunden in ",
        "video_processing_error": "❌ Fehler bei der Verarbeitung der Videodatei : ",
        "image_processing_error": "❌ Fehler bei der Verarbeitung der Bilddatei : ",
        "no_valid_clips": "❌ Es konnten keine gültigen Clips verarbeitet werden.",
        "invalid_voiceover": "❌ Ungültige Sprachausgabe-Dauer. Abbruch.",
        "no_music_files": "❌ Keine Musikdateien gefunden; Musik-Clips werden als leere Liste gesetzt.",
        "review_aborted": "Überprüfung vom Benutzer abgebrochen. Videoerstellung abgebrochen.",
        "video_creation_started": "Videoerstellung gestartet...",
        "creating_video": "Initialisierung - Video wird erstellt mit Titel: ",
        "video_in_progress": "In Bearbeitung - Video wird erstellt mit Titel: ",
        "main_execution_error": "❌ Fehler in der Hauptausführung: ",

        # Dialog Messages
        "enter_keywords": "Geben Sie die neuen Schlüsselwörter ein, durch Kommas getrennt:",
        "description_label": "Beschreibung:",
        "tags_label": "Tags (durch Kommas getrennt):",
        "privacy_label": "Datenschutz:",
        "thumbnail_label": "Vorschaubild:",
        "category_label": "Kategorie:",
        "video_language_label": "Videosprache:",
        "recording_date_label": "Aufnahmedatum:",
        "switch_account_label": "YouTube-Konto wechseln",
        "select_thumbnail": "Vorschaubild auswählen",
        "image_files_filter": "Bilddateien (*.png *.jpg *.jpeg)",
        "select_platform_title": "Plattform auswählen",
        "select_platform_prompt": "Wählen Sie eine Social-Media-Plattform:",
        "loading_clips_message": "Lade Clips und Untertitel... Bitte warten.",
        "moving_media_message": "Verschiebe Medienclip... Bitte warten.",
        "processing_subtitles_message": "Verarbeite Untertitel... Bitte warten.",
        "loading_title": "Laden",
        "processing_title": "Verarbeitung",
        "support_tab": "Support",
        "check_faq_label": "Bitte sehen Sie zuerst in unseren FAQ nach:",
        "faq_link_text": "Hier klicken für FAQ",
        "sr_number_label": "SR-Nummer",
        "customer_name_label": "Kundenname",
        "email_label": "E-Mail",
        "phone_label": "Telefon",
        "ticket_type_label": "Ticket-Typ",
        "issue_description_label": "Problembeschreibung",
        "video_name_label": "Videoname",
        "creation_dt_label": "Erstellungsdatum/-zeit (geschätzt)",
        "desc_label": "Beschreibung",
        "send_button": "Ticket senden",
        "sr_sent_title": "Ticket gesendet",
        "sr_sent_msg": "Ihre Support-Anfrage wurde erfolgreich gesendet!"
    },
    # Portuguese
    "pt": {
        "missing_required_title": "Campos obrigatórios ausentes",
        "missing_required_msg": "Por favor, preencha todos os campos obrigatórios:\n",
        "issue_option": "Problema",
        "enh_option":   "Aprimoramento",
        "comment_option": "Comentário",
        "coming_soon_title":       "Em breve",
        "coming_soon_msg": (
            "A integração com {} estará disponível em breve.\n\n"
            "Por favor, carregue o vídeo final manualmente.\n"
            "Caminho do vídeo: {}"
        ),
        "youtube_shorts_reminder_title": "Lembrete do YouTube Shorts",
        "youtube_shorts_reminder_msg": (
            "NOTA: Os YouTube Shorts destinam-se a vídeos de 60 segundos ou menos. "
            "Por favor, certifique-se de que o seu vídeo cumpra o requisito de duração para o YouTube Shorts."
        ),
        "file_not_found_title":    "⚠️ AVISO: Arquivo não encontrado",
        "file_not_found_msg": (
            "Arquivo de vídeo final para {} não encontrado. "
            "Você pode não tê-lo gerado para esta plataforma. "
            "Gere-o e tente novamente."
        ),
        "yes":            "Sim",
        "no":             "Não",
        "video":          "Vídeo",
        "image":          "Imagem",
        "info":           "Informação",
        "switch_account": "Mudar Conta",
        "main_tab_title": "Principal",
        "target_language_label": "Idioma de destino:",
        "voice_label": "Selecione a voz do narrador:",
        "video_title_label": "Título do vídeo:",
        "platform_label": "Plataforma:",
        "prompt_label": "Digite o prompt para o conteúdo do vídeo (em qualquer idioma):",
        "genre_label": "Selecione o gênero instrumental:",
        "modify_label": "Modificar palavras-chave?",
        "bypass_label": "Ignorar texto, legendas e narração?",
        "status_label": "Status:",
        "save_subtitles_btn": "Salvar e regenerar legendas",
        "start_video_btn": "Iniciar criação do vídeo",
        "play_video_btn_final": "Reproduzir vídeo",
        "replace_clip_btn": "Substituir clipe selecionado",
        "delete_clip_btn": "Excluir clipes selecionados",
        "base_directory_label": "Diretório base:",
        "base_browse_btn": "Procurar",
        "video_image_folder_label": "Pasta de imagens do vídeo:",
        "output_directory_label": "Diretório de saída:",
        "music_folder_label": "Pasta de música:",
        "voiceover_directory_label": "Diretório de narração:",
        "review_script_tab": "Revisar ou editar o roteiro",
        "review_clips_tab": "Revisar ou editar clipes e legendas",
        "test_voice_button": "Testar voz",
        "generate_final_video_btn": "Gerar vídeo final",
        "final_video_tab": "Vídeo final",
        "upload_video_btn": "Enviar para redes sociais",
        "clip_table_headers": [
            "Selecionar", "Prévia de mídia", "Tipo de mídia", "Arquivo de mídia", "Duração mídia",
            "Início mídia", "Fim mídia", "Selecionar", "Prévia música", "Arquivo música",
            "Duração música", "Início música", "Fim música", "Legenda", "Início legenda", "Fim legenda"
        ],
        "editable_field_tooltip": "Campo editável",
        "readonly_field_tooltip": "Campo somente leitura",
        "bypass_mode_message": (
            "Como você selecionou o modo de bypass de roteiro, legendas e narração, "
            "nenhum roteiro/legenda/narração foi gerado.\n"
            "Por favor, revise a mídia baixada na aba 'Revisar ou editar clipes e legendas'.\n"
            "Depois de terminar a revisão, clique no botão 'Gerar vídeo final' para gerar o vídeo final.\n"
            "Após o vídeo final ser gerado, clique em OK no alerta que aparecerá.\n"
            "Então, você será automaticamente direcionado para a aba 'Vídeo final' para visualizar o vídeo.\n"
            "Clique em OK para dispensar esta notificação."
        ),
        "normal_mode_message": (
            "Por favor, revise o conteúdo gerado:\n"
            "1. Na aba 'Revisar ou editar o roteiro', por favor revise/edite o roteiro gerado.\n"
            "2. Em seguida, clique no botão 'Salvar e regenerar legendas' para ser direcionado à "
            "aba 'Revisar ou editar clipes e legendas' para revisão.\n"
            "Depois de terminar a revisão, clique no botão 'Gerar vídeo final' para gerar o vídeo final.\n"
            "Após o vídeo final ser gerado, clique em OK no alerta que aparecerá.\n"
            "Então, você será automaticamente direcionado para a aba 'Vídeo final' para visualizar o vídeo.\n"
            "Clique em OK para dispensar esta notificação."
        ),
        "add_media_btn": "Adicionar mídia",
        "add_music_btn": "Adicionar música",
        "no_file_placeholder": "Sem arquivo",
        "none_text": "Nenhum",
        # ToolTips
        "switch_account_tooltip": "Marque esta caixa se quiser fazer login com uma conta diferente do YouTube",
        "target_language_tooltip": "Selecione o idioma alvo para as traduções da interface",
        "prompt_tooltip": (
            "Forneça uma descrição detalhada do conteúdo do vídeo que deseja criar.\n"
            "Inclua tópicos principais, estilo desejado e todos os detalhes essenciais para guiar o processo de geração do vídeo.\n"
            "Você pode escrever o texto em qualquer idioma; o vídeo será produzido no idioma selecionado.\n"
            "A saída gerada formará um roteiro de vídeo que você poderá revisar posteriormente."
        ),
        "modify_tooltip": (
            "Escolha 'Sim' (padrão) para permitir a edição das palavras-chave extraídas do roteiro; 'Não' mantém as palavras-chave originais\n"
            "Essas palavras-chave determinam a seleção de mídia a ser baixada; mais palavras-chave podem gerar mais mídia (e vídeos mais longos),\n"
            "enquanto palavras-chave mais precisas produzem conteúdo mais relevante.\n"
            "Nota: Se você usar um idioma diferente do inglês, palavras-chave em inglês serão adicionadas automaticamente para resultados ideais."
        ),
        "modify_yes_tooltip": "Sim: Permitir modificações nas palavras-chave extraídas",
        "modify_no_tooltip": "Não: Usar palavras-chave geradas originalmente",
        "bypass_tooltip": (
            "Quando definido como 'Sim', a geração e processamento de texto, legendas e narração serão ignorados\n"
            "Exemplo: vídeos de meditação ou relaxamento.\n"
            "Quando definido como 'Não' (padrão), texto, legendas e narração são gerados."
        ),
        "bypass_yes_tooltip": "Sim: Ignorar geração de texto, legendas e narração",
        "bypass_no_tooltip": "Não: Gerar texto, legendas e narração",

        # Buttons
        "play_button": "Reproduzir",
        "pause_button": "Pausar",
        "forward_button": "Avançar (+10 s)",
        "backward_button": "Retroceder (-10 s)",
        "browse_button": "Procurar",

        # Window Titles
        "success_text": "Sucesso",
        "video_preview_title": "Pré-visualização do vídeo: ",
        "music_preview_title": "Pré-visualização da música: ",
        "voice_selector_title": "Seletor de voz",
        "upload_details_title": "Detalhes do upload",
        "modify_keywords_title": "Modificar palavras-chave",

        # Progress Messages
        "uploading_video": "Fazendo upload do vídeo para o YouTube... Por favor, aguarde.",
        "uploading_thumbnail": "Fazendo upload da miniatura... Por favor, aguarde.",
        "generating_final_video": "Gerando vídeo final... Por favor, aguarde.",
        "saving_subtitles": "Salvando legendas e regenerando SRT",
        "replacing_media": "Substituindo mídia selecionada... Por favor, aguarde.",
        "deleting_clips": "Excluindo clip(s) selecionado(s)... Por favor, aguarde.",
        "inserting_media": "Inserindo nova mídia... Por favor, aguarde.",
        "inserting_music": "Inserindo nova música... Por favor, aguarde.",
        "starting_video": "Iniciando criação do vídeo... Por favor, aguarde.",

        # Info Messages
        "upload_success": "✅ Upload do vídeo para o YouTube concluído com sucesso!",
        "upload_failure": "❌ Ocorreu um erro durante o upload.",
        "upload_cancelled": "Upload foi cancelado pelo usuário.",
        "subtitle_error": "❌ Ocorreu um erro durante o processamento das legendas: ",
        "select_media_warning": "Por favor, selecione uma célula de mídia para substituir.",
        "unsupported_file": "O tipo de arquivo selecionado não é suportado.",
        "replace_media_error": "❌ Ocorreu um erro ao substituir a mídia selecionada: ",
        "no_items_selected": "Nenhuma mídia, música ou legenda selecionada para exclusão.",
        "delete_error": "❌ Ocorreu um erro ao excluir clips: ",
        "insert_media_error": "❌ Ocorreu um erro ao inserir nova mídia: ",
        "video_success_bypass": "Criação do vídeo concluída com sucesso (modo bypass).",
        "video_success": "Criação do vídeo concluída com sucesso.",
        "encoding_error": "❌ Erro ao codificar vídeo em processo separado.",
        "review_content_title": "Informação - Revisar conteúdo",
        "title_required": "Por favor, insira um título para o vídeo.",
        "platform_required": "Por favor, selecione uma plataforma.",
        "prompt_required": "Por favor, insira um prompt para o roteiro do vídeo.",
        "video_not_found": "Arquivo de vídeo não encontrado: ",
        "playback_error": "❌ Ocorreu um erro ao reproduzir o vídeo: ",
        "invalid_platform": "❌ Configurações de plataforma inválidas para .",

        # Status Messages
        "encoding_complete": "Codificação do vídeo concluída com sucesso.",
        "encoding_error_status": "❌ Erro ao codificar vídeo em processo separado.",
        "general_error": "❌ Ocorreu um erro: ",
        "playing_video": "Reproduzindo vídeo: ",
        "subtitles_saved": "Legendas salvas e geração de narração iniciada...",
        "items_deleted": "✅ Itens selecionados excluídos.",
        "no_media_found": "❌ Nenhum arquivo de vídeo ou imagem encontrado em ",
        "video_processing_error": "❌ Erro ao processar arquivo de vídeo : ",
        "image_processing_error": "❌ Erro ao processar arquivo de imagem : ",
        "no_valid_clips": "❌ Não foi possível processar clips válidos.",
        "invalid_voiceover": "❌ Duração de narração inválida. Abortando.",
        "no_music_files": "❌ Nenhum arquivo de música encontrado; definindo lista de clips de música como vazia.",
        "review_aborted": "Revisão abortada pelo usuário. Criação do vídeo cancelada.",
        "video_creation_started": "Criação do vídeo iniciada...",
        "creating_video": "Inicializando - Criando vídeo intitulado: ",
        "video_in_progress": "Em andamento - Criando vídeo intitulado: ",
        "main_execution_error": "❌ Erro na execução principal: ",

        # Dialog Messages
        "enter_keywords": "Digite as novas palavras-chave, separadas por vírgulas:",
        "description_label": "Descrição:",
        "tags_label": "Tags (separadas por vírgulas):",
        "privacy_label": "Privacidade:",
        "thumbnail_label": "Miniatura:",
        "category_label": "Categoria:",
        "video_language_label": "Idioma do vídeo:",
        "recording_date_label": "Data de gravação:",
        "switch_account_label": "Trocar conta do YouTube",
        "select_thumbnail": "Selecionar miniatura",
        "image_files_filter": "Arquivos de imagem (*.png *.jpg *.jpeg)",
        "select_platform_title": "Selecionar plataforma",
        "select_platform_prompt": "Escolha uma plataforma de mídia social:",
        "loading_clips_message": "Carregando clipes e legendas... Por favor, aguarde.",
        "moving_media_message": "Movendo clipe de mídia... Por favor, aguarde.",
        "processing_subtitles_message": "Processando legendas... Por favor, aguarde.",
        "loading_title": "Carregando",
        "processing_title": "Processando",
        "support_tab": "Suporte",
        "check_faq_label": "Por favor, verifique primeiro nossas Perguntas Frequentes:",
        "faq_link_text": "Clique aqui para o FAQ",
        "sr_number_label": "Número SR",
        "customer_name_label": "Nome do Cliente",
        "email_label": "E-mail",
        "phone_label": "Telefone",
        "ticket_type_label": "Tipo de Ticket",
        "issue_description_label": "Descrição do Problema",
        "video_name_label": "Nome do Vídeo",
        "creation_dt_label": "Data/Hora de Criação (estimada)",
        "desc_label": "Descrição",
        "send_button": "Enviar Ticket",
        "sr_sent_title": "Ticket Enviado",
        "sr_sent_msg": "Seu pedido de suporte foi enviado com sucesso!"
    },
    # Russian
    "ru": {
        "missing_required_title": "Отсутствуют обязательные поля",
        "missing_required_msg": "Пожалуйста, заполните все обязательные поля:\n",
        "issue_option": "Проблема",
        "enh_option":   "Улучшение",
        "comment_option": "Комментарий",
        "coming_soon_title":       "Скоро появится",
        "coming_soon_msg": (
            "Интеграция для {} скоро будет доступна.\n\n"
            "Пожалуйста, загрузите итоговое видео вручную.\n"
            "Путь к видео: {}"
        ),
        "youtube_shorts_reminder_title": "Напоминание YouTube Shorts",
        "youtube_shorts_reminder_msg": (
            "ПРИМЕЧАНИЕ: YouTube Shorts предназначены для видео продолжительностью 60 секунд или меньше. "
            "Пожалуйста, убедитесь, что ваше видео соответствует требованию длины для YouTube Shorts."
        ),
        "file_not_found_title":    "⚠️ ПРЕДУПРЕЖДЕНИЕ : файл не найден",
        "file_not_found_msg": (
            "Не удалось найти итоговый видеофайл для {}. "
            "Возможно, вы не создали его для этой платформы. "
            "Пожалуйста, создайте его и попробуйте снова."
        ),
        "yes":            "Да",
        "no":             "Нет",
        "video":          "Видео",
        "image":          "Изображение",
        "info":           "Инфо",
        "switch_account": "Сменить аккаунт",
        "main_tab_title": "Главная",
        "target_language_label": "Целевой язык:",
        "voice_label": "Выберите голос диктора:",
        "video_title_label": "Заголовок видео:",
        "platform_label": "Платформа:",
        "prompt_label": "Введите запрос для содержания видео (на любом языке):",
        "genre_label": "Выберите инструментальный жанр:",
        "modify_label": "Изменить ключевые слова?",
        "bypass_label": "Пропустить текст, субтитры и озвучку?",
        "status_label": "Статус:",
        "save_subtitles_btn": "Сохранить и пересоздать субтитры",
        "start_video_btn": "Начать создание видео",
        "play_video_btn_final": "Воспроизвести видео",
        "replace_clip_btn": "Заменить выбранный клип",
        "delete_clip_btn": "Удалить выбранные клипы",
        "base_directory_label": "Базовая директория:",
        "base_browse_btn": "Обзор",
        "video_image_folder_label": "Папка с изображениями видео:",
        "output_directory_label": "Выходной каталог:",
        "music_folder_label": "Папка с музыкой:",
        "voiceover_directory_label": "Директория озвучивания:",
        "review_script_tab": "Просмотреть или отредактировать сценарий",
        "review_clips_tab": "Просмотреть или отредактировать клипы и субтитры",
        "test_voice_button": "Проверить голос",
        "generate_final_video_btn": "Создать финальное видео",
        "final_video_tab": "Финальное видео",
        "upload_video_btn": "Загрузить в социальные сети",
        "clip_table_headers": [
            "Выбрать", "Предпросмотр медиа", "Тип медиа", "Медиафайл", "Длительность медиа",
            "Начало медиа", "Конец медиа", "Выбрать", "Предпросмотр музыки", "Музыкальный файл",
            "Длительность музыки", "Начало музыки", "Конец музыки", "Субтитры", "Начало субтитров", "Конец субтитров"
        ],
        "editable_field_tooltip": "Редактируемое поле",
        "readonly_field_tooltip": "Поле только для чтения",
        "bypass_mode_message": (
            "Поскольку вы выбрали режим обхода сценария, субтитров и озвучки, "
            "сценарий/субтитры/озвучка не были сгенерированы.\n"
            "Пожалуйста, просмотрите загруженные медиафайлы во вкладке 'Просмотреть или отредактировать клипы и субтитры'.\n"
            "После завершения просмотра нажмите кнопку 'Создать финальное видео'.\n"
            "После создания финального видео нажмите OK во всплывающем уведомлении.\n"
            "Затем вы будете автоматически переключены на вкладку 'Финальное видео' для предпросмотра.\n"
            "Нажмите OK, чтобы закрыть это уведомление."
        ),
        "normal_mode_message": (
            "Пожалуйста, просмотрите сгенерированный контент:\n"
            "1. Во вкладке 'Просмотреть или отредактировать сценарий' просмотрите/отредактируйте сгенерированный сценарий.\n"
            "2. Затем нажмите кнопку 'Сохранить и пересоздать субтитры', чтобы перейти к "
            "вкладке 'Просмотреть или отредактировать клипы и субтитры' для проверки.\n"
            "После завершения просмотра нажмите кнопку 'Создать финальное видео'.\n"
            "После создания финального видео нажмите OK во всплывающем уведомлении.\n"
            "Затем вы будете автоматически переключены на вкладку 'Финальное видео' для предпросмотра.\n"
            "Нажмите OK, чтобы закрыть это уведомление."
        ),
        "add_media_btn": "Добавить медиа",
        "add_music_btn": "Добавить музыку",
        "no_file_placeholder": "Нет файла",
        "none_text": "Нет",
        # ToolTips
        "switch_account_tooltip": "Отметьте этот флажок, если хотите войти с другим аккаунтом YouTube",
        "target_language_tooltip": "Выберите целевой язык для переводов интерфейса",
        "prompt_tooltip": (
            "Предоставьте подробное описание видеоконтента, который вы хотите создать.\n"
            "Включите ключевые темы, желаемый стиль и все важные детали для руководства процессом создания видео.\n"
            "Вы можете писать текст на любом языке; видео будет создано на выбранном языке.\n"
            "Сгенерированный результат сформирует видеосценарий, который вы сможете просмотреть позже."
        ),
        "modify_tooltip": (
            "Выберите 'Да' (по умолчанию), чтобы разрешить редактирование ключевых слов, извлеченных из сценария; 'Нет' сохраняет исходные ключевые слова\n"
            "Эти ключевые слова определяют выбор загружаемых медиафайлов; больше ключевых слов может дать больше медиафайлов (и более длинные видео),\n"
            "в то время как более точные ключевые слова создают более релевантный контент.\n"
            "Примечание: Если вы используете язык, отличный от английского, английские ключевые слова будут добавлены автоматически для оптимальных результатов."
        ),
        "modify_yes_tooltip": "Да: Разрешить изменение извлеченных ключевых слов",
        "modify_no_tooltip": "Нет: Использовать изначально сгенерированные ключевые слова",
        "bypass_tooltip": (
            "При установке 'Да' генерация и обработка текста, субтитров и закадрового голоса будут пропущены\n"
            "Пример: видео для медитации или релаксации.\n"
            "При установке 'Нет' (по умолчанию) текст, субтитры и закадровый голос будут сгенерированы."
        ),
        "bypass_yes_tooltip": "Да: Пропустить генерацию текста, субтитров и закадрового голоса",
        "bypass_no_tooltip": "Нет: Генерировать текст, субтитры и закадровый голос",

        # Buttons
        "play_button": "Воспроизвести",
        "pause_button": "Пауза",
        "forward_button": "Вперед (+10 с)",
        "backward_button": "Назад (-10 с)",
        "browse_button": "Обзор",

        # Window Titles
        "success_text": "Успех",
        "video_preview_title": "Предпросмотр видео: ",
        "music_preview_title": "Предпросмотр музыки: ",
        "voice_selector_title": "Выбор голоса",
        "upload_details_title": "Детали загрузки",
        "modify_keywords_title": "Изменение ключевых слов",

        # Progress Messages
        "uploading_video": "Загрузка видео на YouTube... Пожалуйста, подождите.",
        "uploading_thumbnail": "Загрузка миниатюры... Пожалуйста, подождите.",
        "generating_final_video": "Создание финального видео... Пожалуйста, подождите.",
        "saving_subtitles": "Сохранение субтитров и повторная генерация SRT",
        "replacing_media": "Замена выбранных медиафайлов... Пожалуйста, подождите.",
        "deleting_clips": "Удаление выбранных клипов... Пожалуйста, подождите.",
        "inserting_media": "Вставка новых медиафайлов... Пожалуйста, подождите.",
        "inserting_music": "Вставка новой музыки... Пожалуйста, подождите.",
        "starting_video": "Начало создания видео... Пожалуйста, подождите.",

        # Info Messages
        "upload_success": "✅ Загрузка видео на YouTube успешно завершена!",
        "upload_failure": "❌ Произошла ошибка при загрузке.",
        "upload_cancelled": "Загрузка была отменена пользователем.",
        "subtitle_error": "❌ Произошла ошибка при обработке субтитров: ",
        "select_media_warning": "Пожалуйста, выберите ячейку медиа для замены.",
        "unsupported_file": "Выбранный тип файла не поддерживается.",
        "replace_media_error": "❌ Произошла ошибка при замене выбранных медиафайлов: ",
        "no_items_selected": "Не выбраны медиафайлы, музыка или субтитры для удаления.",
        "delete_error": "❌ Произошла ошибка при удалении клипов: ",
        "insert_media_error": "❌ Произошла ошибка при вставке новых медиафайлов: ",
        "video_success_bypass": "Создание видео успешно завершено (режим обхода).",
        "video_success": "Создание видео успешно завершено.",
        "encoding_error": "❌ Ошибка кодирования видео в отдельном процессе.",
        "review_content_title": "Информация - Просмотр содержимого",
        "title_required": "Пожалуйста, введите название видео.",
        "platform_required": "Пожалуйста, выберите платформу.",
        "prompt_required": "Пожалуйста, введите подсказку для видеосценария.",
        "video_not_found": "Видеофайл не найден: ",
        "playback_error": "❌ Произошла ошибка при воспроизведении видео: ",
        "invalid_platform": "❌ Неверные настройки платформы для .",

        # Status Messages
        "encoding_complete": "Кодирование видео успешно завершено.",
        "encoding_error_status": "❌ Ошибка кодирования видео в отдельном процессе.",
        "general_error": "❌ Произошла ошибка: ",
        "playing_video": "Воспроизведение видео: ",
        "subtitles_saved": "Субтитры сохранены и начата генерация закадрового голоса...",
        "items_deleted": "✅ Выбранные элементы удалены.",
        "no_media_found": "❌ Видео или изображения не найдены в ",
        "video_processing_error": "❌ Ошибка обработки видеофайла : ",
        "image_processing_error": "❌ Ошибка обработки изображения : ",
        "no_valid_clips": "❌ Не удалось обработать действительные клипы.",
        "invalid_voiceover": "❌ Недопустимая длительность закадрового голоса. Прерывание.",
        "no_music_files": "❌ Музыкальные файлы не найдены; установка списка музыкальных клипов как пустого.",
        "review_aborted": "Просмотр прерван пользователем. Создание видео отменено.",
        "video_creation_started": "Создание видео начато...",
        "creating_video": "Инициализация - Создание видео с названием: ",
        "video_in_progress": "В процессе - Создание видео с названием: ",
        "main_execution_error": "❌ Ошибка в основном выполнении: ",

        # Dialog Messages
        "enter_keywords": "Введите новые ключевые слова, разделенные запятыми:",
        "description_label": "Описание:",
        "tags_label": "Теги (разделенные запятыми):",
        "privacy_label": "Конфиденциальность:",
        "thumbnail_label": "Миниатюра:",
        "category_label": "Категория:",
        "video_language_label": "Язык видео:",
        "recording_date_label": "Дата записи:",
        "switch_account_label": "Сменить аккаунт YouTube",
        "select_thumbnail": "Выбрать миниатюру",
        "image_files_filter": "Файлы изображений (*.png *.jpg *.jpeg)",
        "select_platform_title": "Выбор платформы",
        "select_platform_prompt": "Выберите платформу социальных сетей:",
        "loading_clips_message": "Загрузка клипов и субтитров... Пожалуйста, подождите.",
        "moving_media_message": "Перемещение медиаклипа... Пожалуйста, подождите.",
        "processing_subtitles_message": "Обработка субтитров... Пожалуйста, подождите.",
        "loading_title": "Загрузка",
        "processing_title": "Обработка",
        "support_tab": "Поддержка",
        "check_faq_label": "Пожалуйста, сначала ознакомьтесь с нашими FAQ:",
        "faq_link_text": "Нажмите здесь, чтобы перейти к FAQ",
        "sr_number_label": "Номер SR",
        "customer_name_label": "Имя клиента",
        "email_label": "Электронная почта",
        "phone_label": "Телефон",
        "ticket_type_label": "Тип заявки",
        "issue_description_label": "Описание проблемы",
        "video_name_label": "Название видео",
        "creation_dt_label": "Дата/время создания (предварительно)",
        "desc_label": "Описание",
        "send_button": "Отправить заявку",
        "sr_sent_title": "Заявка отправлена",
        "sr_sent_msg": "Ваш запрос в службу поддержки успешно отправлен!"
    },
    # Chinese (Simplified)
    "zh": {
        "missing_required_title": "缺少必填字段",
        "missing_required_msg": "请填写所有必填字段：\n",
        "issue_option": "问题",
        "enh_option":   "改进",
        "comment_option": "评论",
        "coming_soon_title":       "即将推出",
        "coming_soon_msg": (
            "{} 的集成即将推出。\n\n"
            "请手动上传最终视频。\n"
            "视频路径：{}"
        ),
        "youtube_shorts_reminder_title": "YouTube Shorts 提醒",
        "youtube_shorts_reminder_msg": (
            "注意：YouTube Shorts 适用于时长不超过 60 秒的视频。"
            "请确保您的视频符合 YouTube Shorts 的时长要求。"
        ),
        "file_not_found_title":    "⚠️ 警告：未找到文件",
        "file_not_found_msg": (
            "{} 的最终视频文件未找到。"
            "您可能尚未为此平台生成它。"
            "请生成它，然后重试。"
        ),
        "yes":            "是",
        "no":             "否",
        "video":          "视频",
        "image":          "图像",
        "info":           "信息",
        "switch_account": "切换账户",
        "main_tab_title": "主页",
        "target_language_label": "目标语言:",
        "voice_label": "选择旁白声音：",
        "video_title_label": "视频标题：",
        "platform_label": "平台：",
        "prompt_label": "输入视频内容提示（任意语言）：",
        "genre_label": "选择器乐风格：",
        "modify_label": "修改关键词？",
        "bypass_label": "跳过文本、字幕和旁白？",
        "status_label": "状态：",
        "save_subtitles_btn": "保存并重新生成字幕",
        "start_video_btn": "开始视频创建",
        "play_video_btn_final": "播放视频",
        "replace_clip_btn": "替换选定片段",
        "delete_clip_btn": "删除选定片段",
        "base_directory_label": "基本目录：",
        "base_browse_btn": "浏览",
        "video_image_folder_label": "视频图片文件夹：",
        "output_directory_label": "输出目录：",
        "music_folder_label": "音乐文件夹：",
        "voiceover_directory_label": "旁白目录：",
        "review_script_tab": "查看或编辑脚本",
        "review_clips_tab": "查看或编辑片段和字幕",
        "test_voice_button": "测试声音",
        "generate_final_video_btn": "生成最终视频",
        "final_video_tab": "最终视频",
        "upload_video_btn": "上传到社交媒体",
        "clip_table_headers": [
            "选择", "媒体预览", "媒体类型", "媒体文件", "媒体时长",
            "媒体开始", "媒体结束", "选择", "音乐预览", "音乐文件",
            "音乐时长", "音乐开始", "音乐结束", "字幕", "字幕开始", "字幕结束"
        ],
        "editable_field_tooltip": "可编辑字段",
        "readonly_field_tooltip": "只读字段",
        "bypass_mode_message": """由于您选择了跳过脚本、字幕和旁白模式 
        未生成脚本/字幕/旁白。
        请在"查看或编辑片段和字幕"标签页中查看下载的媒体。
        完成查看后，点击"生成最终视频"按钮生成最终视频。
        最终视频生成后，点击弹出提示框中的 OK。
        然后，您将自动切换到"最终视频"标签页预览视频。
        点击 OK 关闭此通知。""",
        "normal_mode_message": """请查看生成的内容：
        1. 在"查看或编辑脚本"标签页中，请查看/编辑生成的脚本。
        2. 然后，点击"保存并重新生成字幕"按钮，切换到"查看或编辑片段和字幕"标签页进行查看。
        完成查看后，点击"生成最终视频"按钮生成最终视频。
        最终视频生成后，点击弹出提示框中的 OK。
        然后，您将自动切换到"最终视频"标签页预览视频。
        点击 OK 关闭此通知。""",
        "add_media_btn": "添加媒体",
        "add_music_btn": "添加音乐",
        "no_file_placeholder": "无文件",
        "none_text": "无",
        # ToolTips
        "switch_account_tooltip": "如果您想使用其他YouTube账号登录，请勾选此框",
        "target_language_tooltip": "选择界面翻译的目标语言",
        "prompt_tooltip": (
            "请提供描述您想要创建的视频内容的详细提示。\n"
            "包括关键主题、期望风格和所有指导视频生成过程的必要细节。\n"
            "您可以使用任何语言编写提示；视频将以所选语言制作。\n"
            "生成的输出将形成一个您可以稍后审查的视频脚本。"
        ),
        "modify_tooltip": (
            "选择'是'（默认）允许编辑从脚本中提取的关键词；选择'否'保留原始关键词\n"
            "这些关键词决定了将下载的媒体选择；更多关键词可能产生更多媒体（和更长的视频），\n"
            "而更精确的关键词会产生更相关的内容。\n"
            "注意：如果您使用英语以外的语言编写提示，系统会自动添加英语关键词以获得最佳内容结果。"
        ),
        "modify_yes_tooltip": "是：允许修改提取的关键词",
        "modify_no_tooltip": "否：使用原始生成的关键词",
        "bypass_tooltip": (
            "选择'是'时，将跳过文本、字幕和旁白的生成和处理\n"
            "示例：冥想或放松视频。\n"
            "选择'否'（默认）时，将生成文本、字幕和旁白。"
        ),
        "bypass_yes_tooltip": "是：跳过文本、字幕和旁白生成",
        "bypass_no_tooltip": "否：生成文本、字幕和旁白",

        # Buttons
        "play_button": "播放",
        "pause_button": "暂停",
        "forward_button": "前进 (+10秒)",
        "backward_button": "后退 (-10秒)",
        "browse_button": "浏览",

        # Window Titles
        "success_text": "成功",
        "video_preview_title": "视频预览: ",
        "music_preview_title": "音乐预览: ",
        "voice_selector_title": "语音选择器",
        "upload_details_title": "上传详情",
        "modify_keywords_title": "修改关键词",

        # Progress Messages
        "uploading_video": "正在上传视频至YouTube... 请稍候。",
        "uploading_thumbnail": "正在上传缩略图... 请稍候。",
        "generating_final_video": "正在生成最终视频... 请稍候。",
        "saving_subtitles": "正在保存字幕并重新生成SRT文件",
        "replacing_media": "正在替换所选媒体... 请稍候。",
        "deleting_clips": "正在删除所选片段... 请稍候。",
        "inserting_media": "正在插入新媒体... 请稍候。",
        "inserting_music": "正在插入新音乐... 请稍候。",
        "starting_video": "正在开始视频创建... 请稍候。",

        # Info Messages
        "upload_success": "✅ YouTube视频上传成功完成！",
        "upload_failure": "❌ 上传过程中发生错误。",
        "upload_cancelled": "上传已被用户取消。",
        "subtitle_error": "❌ 字幕处理过程中发生错误：",
        "select_media_warning": "请选择要替换的媒体单元格。",
        "unsupported_file": "所选文件类型不受支持。",
        "replace_media_error": "❌ 替换所选媒体时发生错误：",
        "no_items_selected": "未选择要删除的媒体、音乐或字幕。",
        "delete_error": "❌ 删除片段时发生错误：",
        "insert_media_error": "❌ 插入新媒体时发生错误：",
        "video_success_bypass": "视频创建成功完成（跳过模式）。",
        "video_success": "视频创建成功完成。",
        "encoding_error": "❌ 在单独进程中编码视频时出错。",
        "review_content_title": "信息 - 审查内容",
        "title_required": "请输入视频标题。",
        "platform_required": "请选择平台。",
        "prompt_required": "请输入视频脚本提示。",
        "video_not_found": "未找到视频文件：",
        "playback_error": "❌ 播放视频时发生错误：",
        "invalid_platform": "❌ 的平台设置无效。",

        # Status Messages
        "encoding_complete": "视频编码成功完成。",
        "encoding_error_status": "❌ 在单独进程中编码视频时出错。",
        "general_error": "❌ 发生错误：",
        "playing_video": "正在播放视频：",
        "subtitles_saved": "字幕已保存，开始生成旁白...",
        "items_deleted": "✅ 已删除所选项目。",
        "no_media_found": "❌ 在中未找到视频或图像文件",
        "video_processing_error": "❌ 处理视频文件时出错：",
        "image_processing_error": "❌ 处理图像文件时出错：",
        "no_valid_clips": "❌ 无法处理有效片段。",
        "invalid_voiceover": "❌ 旁白时长无效。正在中止。",
        "no_music_files": "❌ 未找到音乐文件；将音乐片段设置为空列表。",
        "review_aborted": "用户已中止审查。视频创建已取消。",
        "video_creation_started": "视频创建已开始...",
        "creating_video": "初始化 - 正在创建标题为：的视频",
        "video_in_progress": "进行中 - 正在创建标题为：的视频",
        "main_execution_error": "❌ 主执行过程中出错：",

        # Dialog Messages
        "enter_keywords": "输入新的关键词，用逗号分隔：",
        "description_label": "描述：",
        "tags_label": "标签（用逗号分隔）：",
        "privacy_label": "隐私设置：",
        "thumbnail_label": "缩略图：",
        "category_label": "类别：",
        "video_language_label": "视频语言：",
        "recording_date_label": "录制日期：",
        "switch_account_label": "切换YouTube账号",
        "select_thumbnail": "选择缩略图",
        "image_files_filter": "图像文件 (*.png *.jpg *.jpeg)",
        "select_platform_title": "选择平台",
        "select_platform_prompt": "选择社交媒体平台：",
        "loading_clips_message": "正在加载剪辑和字幕...请稍候。",
        "moving_media_message": "正在移动媒体剪辑...请稍候。",
        "processing_subtitles_message": "正在处理字幕...请稍候。",
        "loading_title": "加载中",
        "processing_title": "处理中",
        "support_tab": "支持",
        "check_faq_label": "请先查看我们的常见问题：",
        "faq_link_text": "点击此处查看FAQ",
        "sr_number_label": "SR编号",
        "customer_name_label": "客户名称",
        "email_label": "电子邮箱",
        "phone_label": "电话",
        "ticket_type_label": "工单类型",
        "issue_description_label": "问题描述",
        "video_name_label": "视频名称",
        "creation_dt_label": "创建日期/时间（暂定）",
        "desc_label": "描述",
        "send_button": "发送工单",
        "sr_sent_title": "工单已发送",
        "sr_sent_msg": "您的支持请求已成功发送！"
    },
    # Japanese
    "ja": {
        "missing_required_title": "必須項目が不足しています",
        "missing_required_msg": "必須項目をすべて入力してください:\n",
        "issue_option": "不具合",
        "enh_option":   "機能改善",
        "comment_option": "コメント",
        "coming_soon_title":       "近日公開",
        "coming_soon_msg": (
            "{} の統合機能は間もなく利用可能になります。\n\n"
            "最終ビデオを手動でアップロードしてください。\n"
            "ビデオパス：{}"
        ),
        "youtube_shorts_reminder_title": "YouTube Shorts のリマインダー",
        "youtube_shorts_reminder_msg": (
            "注意：YouTube Shorts は60秒以内の動画を対象としています。"
            "動画が YouTube Shorts の長さ要件を満たしていることを確認してください。"
        ),
        "file_not_found_title":    "⚠️ 警告: ファイルが見つかりません",
        "file_not_found_msg": (
            "{} の最終ビデオファイルが見つかりませんでした。"
            "このプラットフォーム用に生成されていない可能性があります。"
            "生成してもう一度お試しください。"
        ),
        "yes": "はい",
        "no": "いいえ",
        "video": "ビデオ",
        "image": "画像",
        "info": "情報",
        "switch_account": "アカウントを切り替え",
        "main_tab_title": "メイン",
        "target_language_label": "対象言語:",
        "voice_label": "ナレーターの声を選択：",
        "video_title_label": "ビデオのタイトル：",
        "platform_label": "プラットフォーム：",
        "prompt_label": "ビデオコンテンツのためのプロンプトを入力してください（任意の言語で）：",
        "genre_label": "インストゥルメンタルジャンルを選択：",
        "modify_label": "キーワードを変更しますか？",
        "bypass_label": "テキスト、字幕、ナレーションをスキップしますか？",
        "status_label": "ステータス：",
        "save_subtitles_btn": "字幕を保存して再生成",
        "start_video_btn": "ビデオ作成開始",
        "play_video_btn_final": "ビデオを再生",
        "replace_clip_btn": "選択されたクリップを置き換え",
        "delete_clip_btn": "選択されたクリップを削除",
        "base_directory_label": "基本ディレクトリ：",
        "base_browse_btn": "参照",
        "video_image_folder_label": "ビデオ画像フォルダー：",
        "output_directory_label": "出力ディレクトリ：",
        "music_folder_label": "音楽フォルダー：",
        "voiceover_directory_label": "ナレーションディレクトリ：",
        "review_script_tab": "スクリプトの確認または編集",
        "review_clips_tab": "クリップと字幕の確認または編集",
        "test_voice_button": "音声テスト",
        "generate_final_video_btn": "最終ビデオを生成",
        "final_video_tab": "最終ビデオ",
        "upload_video_btn": "ソーシャルメディアにアップロード",
        "clip_table_headers": [
            "選択", "メディアプレビュー", "メディアタイプ", "メディアファイル", "メディア長",
            "メディア開始", "メディア終了", "選択", "音楽プレビュー", "音楽ファイル",
            "音楽長", "音楽開始", "音楽終了", "字幕", "字幕開始", "字幕終了"
        ],
        "editable_field_tooltip": "編集可能フィールド",
        "readonly_field_tooltip": "読み取り専用フィールド",
        "bypass_mode_message": (
            "スクリプト、字幕、ナレーションのバイパスモードを選択したため、"
            "スクリプト/字幕/ナレーションは生成されませんでした。\n"
            "「クリップと字幕の確認または編集」タブでダウンロードしたメディアを確認してください。\n"
            "確認が終わったら、「最終ビデオを生成」ボタンをクリックして最終ビデオを生成してください。\n"
            "最終ビデオが生成されたら、表示されるポップアップアラートで OK をクリックしてください。\n"
            "その後、自動的に「最終ビデオ」タブに切り替わり、ビデオをプレビューできます。\n"
            "OK をクリックしてこの通知を閉じてください。"
        ),
        "normal_mode_message": (
            "生成されたコンテンツを確認してください：\n"
            "1. 「スクリプトの確認または編集」タブで、生成されたスクリプトを確認/編集してください。\n"
            "2. 次に、「字幕を保存して再生成」ボタンをクリックして、"
            "「クリップと字幕の確認または編集」タブに移動して確認してください。\n"
            "確認が終わったら、「最終ビデオを生成」ボタンをクリックして最終ビデオを生成してください。\n"
            "最終ビデオが生成されたら、表示されるポップアップアラートで OK をクリックしてください。\n"
            "その後、自動的に「最終ビデオ」タブに切り替わり、ビデオをプレビューできます。\n"
            "OK をクリックしてこの通知を閉じてください。"
        ),
        "add_media_btn": "メディアを追加",
        "add_music_btn": "音楽を追加",
        "no_file_placeholder": "ファイルなし",
        "none_text": "なし",
        # ToolTips
        "switch_account_tooltip": "別のYouTubeアカウントでログインする場合はこのボックスをチェックしてください",
        "target_language_tooltip": "インターフェース翻訳の対象言語を選択してください",
        "prompt_tooltip": (
            "作成したい動画コンテンツの詳細な説明を入力してください。\n"
            "主要なトピック、希望するスタイル、動画生成プロセスを導くために必要な全ての重要な詳細を含めてください。\n"
            "テキストは任意の言語で書くことができます；動画は選択した言語で制作されます。\n"
            "生成された出力は、後で確認できる動画スクリプトとなります。"
        ),
        "modify_tooltip": (
            "'はい'（デフォルト）を選択するとスクリプトから抽出されたキーワードを編集できます；'いいえ'を選択すると元のキーワードが保持されます\n"
            "これらのキーワードはダウンロードするメディアの選択を決定します；より多くのキーワードでより多くのメディア（そしてより長い動画）が生成される可能性があり、\n"
            "より正確なキーワードでより関連性の高いコンテンツが生成されます。\n"
            "注意：英語以外の言語を使用する場合、最適な結果を得るために英語のキーワードが自動的に追加されます。"
        ),
        "modify_yes_tooltip": "はい：抽出されたキーワードの修正を許可",
        "modify_no_tooltip": "いいえ：元々生成されたキーワードを使用",
        "bypass_tooltip": (
            "'はい'に設定すると、テキスト、字幕、ナレーションの生成と処理がスキップされます\n"
            "例：瞑想やリラクゼーション動画。\n"
            "'いいえ'（デフォルト）に設定すると、テキスト、字幕、ナレーションが生成されます。"
        ),
        "bypass_yes_tooltip": "はい：テキスト、字幕、ナレーションの生成をスキップ",
        "bypass_no_tooltip": "いいえ：テキスト、字幕、ナレーションを生成",

        # Buttons
        "play_button": "再生",
        "pause_button": "一時停止",
        "forward_button": "進む (+10秒)",
        "backward_button": "戻る (-10秒)",
        "browse_button": "参照",

        # Window Titles
        "success_text": "成功",
        "video_preview_title": "動画プレビュー: ",
        "music_preview_title": "音楽プレビュー: ",
        "voice_selector_title": "音声セレクター",
        "upload_details_title": "アップロード詳細",
        "modify_keywords_title": "キーワードの修正",

        # Progress Messages
        "uploading_video": "YouTubeに動画をアップロード中... お待ちください。",
        "uploading_thumbnail": "サムネイルをアップロード中... お待ちください。",
        "generating_final_video": "最終動画を生成中... お待ちください。",
        "saving_subtitles": "字幕を保存しSRTを再生成中",
        "replacing_media": "選択したメディアを置換中... お待ちください。",
        "deleting_clips": "選択したクリップを削除中... お待ちください。",
        "inserting_media": "新しいメディアを挿入中... お待ちください。",
        "inserting_music": "新しい音楽を挿入中... お待ちください。",
        "starting_video": "動画作成を開始中... お待ちください。",

        # Info Messages
        "upload_success": "✅ YouTube動画のアップロードが正常に完了しました！",
        "upload_failure": "❌ アップロード中にエラーが発生しました。",
        "upload_cancelled": "アップロードはユーザーによってキャンセルされました。",
        "subtitle_error": "❌ 字幕の処理中にエラーが発生しました: ",
        "select_media_warning": "置換するメディアセルを選択してください。",
        "unsupported_file": "選択されたファイルタイプはサポートされていません。",
        "replace_media_error": "❌ 選択したメディアの置換中にエラーが発生しました: ",
        "no_items_selected": "削除するメディア、音楽、または字幕が選択されていません。",
        "delete_error": "❌ クリップの削除中にエラーが発生しました: ",
        "insert_media_error": "❌ 新しいメディアの挿入中にエラーが発生しました: ",
        "video_success_bypass": "動画作成が正常に完了しました（バイパスモード）。",
        "video_success": "動画作成が正常に完了しました。",
        "encoding_error": "❌ 別プロセスでの動画エンコード中にエラーが発生しました。",
        "review_content_title": "情報 - コンテンツの確認",
        "title_required": "動画タイトルを入力してください。",
        "platform_required": "プラットフォームを選択してください。",
        "prompt_required": "動画スクリプトのプロンプトを入力してください。",
        "video_not_found": "動画ファイルが見つかりません: ",
        "playback_error": "❌ 動画の再生中にエラーが発生しました: ",
        "invalid_platform": "❌ の無効なプラットフォーム設定です。",

        # Status Messages
        "encoding_complete": "動画エンコードが正常に完了しました。",
        "encoding_error_status": "❌ 別プロセスでの動画エンコード中にエラーが発生しました。",
        "general_error": "❌ エラーが発生しました: ",
        "playing_video": "動画再生中: ",
        "subtitles_saved": "字幕を保存し、ナレーション生成を開始しました...",
        "items_deleted": "✅ 選択したアイテムを削除しました。",
        "no_media_found": "❌ で動画または画像ファイルが見つかりません",
        "video_processing_error": "❌ 動画ファイルの処理中にエラーが発生しました: ",
        "image_processing_error": "❌ 画像ファイルの処理中にエラーが発生しました: ",
        "no_valid_clips": "❌ 有効なクリップを処理できませんでした。",
        "invalid_voiceover": "❌ 無効なナレーション時間です。中止します。",
        "no_music_files": "❌ 音楽ファイルが見つかりません；音楽クリップを空のリストとして設定します。",
        "review_aborted": "ユーザーによってレビューが中止されました。動画作成をキャンセルしました。",
        "video_creation_started": "動画作成を開始しました...",
        "creating_video": "初期化中 - タイトル「」の動画を作成中",
        "video_in_progress": "進行中 - タイトル「」の動画を作成中",
        "main_execution_error": "❌ メイン実行でエラーが発生しました: ",

        # Dialog Messages
        "enter_keywords": "新しいキーワードをカンマ区切りで入力してください:",
        "description_label": "説明:",
        "tags_label": "タグ（カンマ区切り）:",
        "privacy_label": "プライバシー:",
        "thumbnail_label": "サムネイル:",
        "category_label": "カテゴリー:",
        "video_language_label": "動画の言語:",
        "recording_date_label": "録画日:",
        "switch_account_label": "YouTubeアカウントの切り替え",
        "select_thumbnail": "サムネイルを選択",
        "image_files_filter": "画像ファイル (*.png *.jpg *.jpeg)",
        "select_platform_title": "プラットフォームを選択",
        "select_platform_prompt": "ソーシャルメディアプラットフォームを選択してください:",
        "loading_clips_message": "クリップと字幕を読み込んでいます... お待ちください。",
        "moving_media_message": "メディアクリップを移動中... お待ちください。",
        "processing_subtitles_message": "字幕を処理中... お待ちください。",
        "loading_title": "読み込み中",
        "processing_title": "処理中",
        "support_tab": "サポート",
        "check_faq_label": "まずはFAQをご確認ください:",
        "faq_link_text": "FAQはこちら",
        "sr_number_label": "SR番号",
        "customer_name_label": "お客様名",
        "email_label": "メールアドレス",
        "phone_label": "電話番号",
        "ticket_type_label": "チケットの種類",
        "issue_description_label": "問題の詳細",
        "video_name_label": "ビデオ名",
        "creation_dt_label": "作成日時（仮）",
        "desc_label": "説明",
        "send_button": "チケット送信",
        "sr_sent_title": "チケットが送信されました",
        "sr_sent_msg": "サポート依頼が正常に送信されました！"
    },
    # Hindi
    "hi": {
        "missing_required_title": "अनिवार्य फ़ील्ड गायब हैं",
        "missing_required_msg": "कृपया सभी अनिवार्य फ़ील्ड भरें:\n",
        "issue_option": "समस्या",
        "enh_option":   "सुधार",
        "comment_option": "टिप्पणी",
        "coming_soon_title":       "जल्द आ रहा है",
        "coming_soon_msg": (
            "{} के लिए एकीकरण जल्द ही आ रहा है।\n\n"
            "कृपया अंतिम वीडियो मैन्युअल रूप से अपलोड करें।\n"
            "वीडियो पथ: {}"
        ),
        "youtube_shorts_reminder_title": "YouTube Shorts अनुस्मारक",
        "youtube_shorts_reminder_msg": (
            "नोट: YouTube Shorts 60 सेकंड या उससे कम की वीडियो के लिए बनाए गए हैं। "
            "कृपया सुनिश्चित करें कि आपकी वीडियो YouTube Shorts की लंबाई आवश्यकताओं को पूरा करती है।"
        ),
        "file_not_found_title":    "⚠️ चेतावनी: फाइल नहीं मिली",
        "file_not_found_msg": (
            "{} के लिए अंतिम वीडियो फ़ाइल नहीं मिली। "
            "हो सकता है आपने इसे इस प्लेटफ़ॉर्म के लिए नहीं बनाया हो। "
            "कृपया इसे बनाएं और पुनः प्रयास करें।"
        ),
        "yes":            "हाँ",
        "no":             "नहीं",
        "video":          "वीडियो",
        "image":          "छवि",
        "info":           "सूचना",
        "switch_account": "खाता बदलें",
        "main_tab_title": "मुख्य",
        "target_language_label": "लक्षित भाषा:",
        "voice_label": "वक्ता की आवाज़ चुनें:",
        "video_title_label": "वीडियो का शीर्षक:",
        "platform_label": "प्लेटफ़ॉर्म:",
        "prompt_label": "वीडियो सामग्री के लिए प्रॉम्प्ट दर्ज करें (किसी भी भाषा में):",
        "genre_label": "इंस्ट्रूमेंटल शैली चुनें:",
        "modify_label": "कुंजी शब्द संशोधित करें?",
        "bypass_label": "पाठ, सबटाइटल और वॉयसओवर छोड़ें?",
        "status_label": "स्थिति:",
        "save_subtitles_btn": "सबटाइटल सहेजें और पुन: जनरेट करें",
        "start_video_btn": "वीडियो निर्माण शुरू करें",
        "play_video_btn_final": "वीडियो चलाएं",
        "replace_clip_btn": "चयनित क्लिप बदलें",
        "delete_clip_btn": "चयनित क्लिप्स हटाएं",
        "base_directory_label": "बेस डायरेक्टरी:",
        "base_browse_btn": "ब्राउज़ करें",
        "video_image_folder_label": "वीडियो छवि फ़ोल्डर:",
        "output_directory_label": "आउटपुट डायरेक्टरी:",
        "music_folder_label": "संगीत फ़ोल्डर:",
        "voiceover_directory_label": "वॉयसओवर डायरेक्टरी:",
        "review_script_tab": "स्क्रिप्ट की समीक्षा या संपादन करें",
        "review_clips_tab": "क्लिप्स और सबटाइटल्स की समीक्षा या संपादन करें",
        "test_voice_button": "वॉयस टेस्ट करें",
        "generate_final_video_btn": "अंतिम वीडियो जनरेट करें",
        "final_video_tab": "अंतिम वीडियो",
        "upload_video_btn": "सोशल मीडिया पर अपलोड करें",
        "clip_table_headers": [
            "चयन", "मीडिया पूर्वावलोकन", "मीडिया प्रकार", "मीडिया फ़ाइल", "मीडिया अवधि",
            "मीडिया प्रारंभ", "मीडिया समाप्ति", "चयन", "संगीत पूर्वावलोकन", "संगीत फ़ाइल",
            "संगीत अवधि", "संगीत प्रारंभ", "संगीत समाप्ति", "उपशीर्षक", "उपशीर्षक प्रारंभ", "उपशीर्षक समाप्ति"
        ],
        "editable_field_tooltip": "संपादन योग्य फ़ील्ड",
        "readonly_field_tooltip": "केवल पठनीय फ़ील्ड",
        "bypass_mode_message": (
            "चूंकि आपने स्क्रिप्ट, सबटाइटल और वॉयसओवर मोड को बायपास करना चुना है, "
            "कोई स्क्रिप्ट/सबटाइटल/वॉयसओवर नहीं बनाया गया।\n"
            "कृपया 'क्लिप्स और सबटाइटल्स की समीक्षा या संपादन करें' टैब में डाउनलोड की गई मीडिया की समीक्षा करें।\n"
            "समीक्षा पूरी होने के बाद, अंतिम वीडियो बनाने के लिए 'अंतिम वीडियो जनरेट करें' बटन पर क्लिक करें।\n"
            "अंतिम वीडियो जनरेट होने के बाद, पॉप-अप अलर्ट में OK पर क्लिक करें।\n"
            "फिर, आप स्वचालित रूप से वीडियो प्रीव्यू के लिए 'अंतिम वीडियो' टैब पर स्विच कर दिए जाएंगे।\n"
            "इस सूचना को बंद करने के लिए OK पर क्लिक करें।"
        ),
        "normal_mode_message": (
            "कृपया जनरेट की गई सामग्री की समीक्षा करें:\n"
            "1. 'स्क्रिप्ट की समीक्षा या संपादन करें' टैब में, कृपया जनरेट की गई स्क्रिप्ट की समीक्षा/संपादन करें।\n"
            "2. फिर, समीक्षा के लिए 'क्लिप्स और सबटाइटल्स की समीक्षा या संपादन करें' टैब में जाने के लिए "
            "'सबटाइटल सहेजें और पुन: जनरेट करें' बटन पर क्लिक करें।\n"
            "समीक्षा पूरी होने के बाद, अंतिम वीडियो बनाने के लिए 'अंतिम वीडियो जनरेट करें' बटन पर क्लिक करें।\n"
            "अंतिम वीडियो जनरेट होने के बाद, पॉप-अप अलर्ट में OK पर क्लिक करें।\n"
            "फिर, आप स्वचालित रूप से वीडियो प्रीव्यू के लिए 'अंतिम वीडियो' टैब पर स्विच कर दिए जाएंगे।\n"
            "इस सूचना को बंद करने के लिए OK पर क्लिक करें।"
        ),
        "add_media_btn": "मीडिया जोड़ें",
        "add_music_btn": "संगीत जोड़ें",
        "no_file_placeholder": "कोई फ़ाइल नहीं",
        "none_text": "कोई नहीं",
        # ToolTips
        "switch_account_tooltip": "अगर आप दूसरे YouTube खाते से लॉगिन करना चाहते हैं तो इस बॉक्स को चेक करें",
        "target_language_tooltip": "इंटरफ़ेस अनुवाद के लिए लक्षित भाषा चुनें",
        "prompt_tooltip": (
            "आप जो वीडियो सामग्री बनाना चाहते हैं उसका विस्तृत विवरण प्रदान करें।\n"
            "मुख्य विषय, वांछित शैली और वीडियो निर्माण प्रक्रिया को मार्गदर्शित करने के लिए सभी आवश्यक विवरण शामिल करें।\n"
            "आप किसी भी भाषा में टेक्स्ट लिख सकते हैं; वीडियो चयनित भाषा में तैयार किया जाएगा।\n"
            "जनरेट किया गया आउटपुट एक वीडियो स्क्रिप्ट बनेगा जिसे आप बाद में समीक्षा कर सकते हैं।"
        ),
        "modify_tooltip": (
            "'हाँ' (डिफ़ॉल्ट) चुनें स्क्रिप्ट से निकाले गए कीवर्ड को संपादित करने के लिए; 'नहीं' मूल कीवर्ड रखता है\n"
            "ये कीवर्ड डाउनलोड की जाने वाली मीडिया का चयन निर्धारित करते हैं; अधिक कीवर्ड अधिक मीडिया (और लंबी वीडियो) उत्पन्न कर सकते हैं,\n"
            "जबकि अधिक सटीक कीवर्ड अधिक प्रासंगिक सामग्री उत्पन्न करते हैं।\n"
            "नोट: यदि आप अंग्रेजी के अलावा कोई अन्य भाषा का उपयोग करते हैं, तो सर्वोत्तम परिणामों के लिए अंग्रेजी कीवर्ड स्वचालित रूप से जोड़े जाएंगे।"
        ),
        "modify_yes_tooltip": "हाँ: निकाले गए कीवर्ड में संशोधन की अनुमति दें",
        "modify_no_tooltip": "नहीं: मूल रूप से जनरेट किए गए कीवर्ड का उपयोग करें",
        "bypass_tooltip": (
            "जब 'हाँ' पर सेट किया जाता है, तो टेक्स्ट, सबटाइटल और वॉइसओवर की जनरेशन और प्रोसेसिंग को बायपास कर दिया जाएगा\n"
            "उदाहरण: ध्यान या आराम की वीडियो।\n"
            "जब 'नहीं' (डिफ़ॉल्ट) पर सेट किया जाता है, तो टेक्स्ट, सबटाइटल और वॉइसओवर जनरेट किए जाते हैं।"
        ),
        "bypass_yes_tooltip": "हाँ: टेक्स्ट, सबटाइटल और वॉइसओवर जनरेशन को बायपास करें",
        "bypass_no_tooltip": "नहीं: टेक्स्ट, सबटाइटल और वॉइसओवर जनरेट करें",

        # Buttons
        "play_button": "चलाएं",
        "pause_button": "रोकें",
        "forward_button": "आगे (+10 सेकंड)",
        "backward_button": "पीछे (-10 सेकंड)",
        "browse_button": "ब्राउज़ करें",

        # Window Titles
        "success_text": "सफलता",
        "video_preview_title": "वीडियो पूर्वावलोकन: ",
        "music_preview_title": "संगीत पूर्वावलोकन: ",
        "voice_selector_title": "आवाज चयनकर्ता",
        "upload_details_title": "अपलोड विवरण",
        "modify_keywords_title": "कीवर्ड संशोधित करें",

        # Progress Messages
        "uploading_video": "YouTube पर वीडियो अपलोड हो रहा है... कृपया प्रतीक्षा करें।",
        "uploading_thumbnail": "थंबनेल अपलोड हो रहा है... कृपया प्रतीक्षा करें।",
        "generating_final_video": "अंतिम वीडियो जनरेट हो रहा है... कृपया प्रतीक्षा करें।",
        "saving_subtitles": "सबटाइटल सहेजे जा रहे हैं और SRT पुनः जनरेट हो रहा है",
        "replacing_media": "चयनित मीडिया बदला जा रहा है... कृपया प्रतीक्षा करें।",
        "deleting_clips": "चयनित क्लिप(स) हटाए जा रहे हैं... कृपया प्रतीक्षा करें।",
        "inserting_media": "नई मीडिया डाली जा रही है... कृपया प्रतीक्षा करें।",
        "inserting_music": "नया संगीत डाला जा रहा है... कृपया प्रतीक्षा करें।",
        "starting_video": "वीडियो निर्माण शुरू हो रहा है... कृपया प्रतीक्षा करें।",

        # Info Messages
        "upload_success": "✅ YouTube वीडियो अपलोड सफलतापूर्वक पूरा हुआ!",
        "upload_failure": "❌ अपलोड के दौरान एक त्रुटि हुई।",
        "upload_cancelled": "अपलोड उपयोगकर्ता द्वारा रद्द कर दिया गया।",
        "subtitle_error": "❌ सबटाइटल प्रोसेसिंग के दौरान एक त्रुटि हुई: ",
        "select_media_warning": "कृपया बदलने के लिए एक मीडिया सेल चुनें।",
        "unsupported_file": "चयनित फ़ाइल प्रकार समर्थित नहीं है।",
        "replace_media_error": "❌ चयनित मीडिया को बदलते समय एक त्रुटि हुई: ",
        "no_items_selected": "हटाने के लिए कोई मीडिया, संगीत या सबटाइटल चयनित नहीं है।",
        "delete_error": "❌ क्लिप्स को हटाते समय एक त्रुटि हुई: ",
        "insert_media_error": "❌ नई मीडिया डालते समय एक त्रुटि हुई: ",
        "video_success_bypass": "वीडियो निर्माण सफलतापूर्वक पूरा हुआ (बायपास मोड)।",
        "video_success": "वीडियो निर्माण सफलतापूर्वक पूरा हुआ।",
        "encoding_error": "❌ अलग प्रक्रिया में वीडियो एनकोडिंग में त्रुटि।",
        "review_content_title": "जानकारी - सामग्री समीक्षा",
        "title_required": "कृपया एक वीडियो शीर्षक दर्ज करें।",
        "platform_required": "कृपया एक प्लेटफ़ॉर्म चुनें।",
        "prompt_required": "कृपया एक वीडियो स्क्रिप्ट प्रॉम्प्ट दर्ज करें।",
        "video_not_found": "वीडियो फ़ाइल नहीं मिली: ",
        "playback_error": "❌ वीडियो चलाते समय एक त्रुटि हुई: ",
        "invalid_platform": "❌  के लिए अमान्य प्लेटफ़ॉर्म सेटिंग्स।",

        # Status Messages
        "encoding_complete": "वीडियो एनकोडिंग सफलतापूर्वक पूरी हुई।",
        "encoding_error_status": "❌ अलग प्रक्रिया में वीडियो एनकोडिंग में त्रुटि।",
        "general_error": "❌ एक त्रुटि हुई: ",
        "playing_video": "वीडियो चल रहा है: ",
        "subtitles_saved": "सबटाइटल सहेजे गए और वॉइसओवर जनरेशन शुरू हुआ...",
        "items_deleted": "✅ चयनित आइटम हटा दिए गए।",
        "no_media_found": "❌  में कोई वीडियो या छवि फ़ाइलें नहीं मिलीं",
        "video_processing_error": "❌ वीडियो फ़ाइल  को प्रोसेस करने में त्रुटि: ",
        "image_processing_error": "❌ छवि फ़ाइल  को प्रोसेस करने में त्रुटि: ",
        "no_valid_clips": "❌ कोई वैध क्लिप प्रोसेस नहीं किया जा सका।",
        "invalid_voiceover": "❌ अमान्य वॉइसओवर अवधि। निरस्त किया जा रहा है।",
        "no_music_files": "❌ कोई संगीत फ़ाइलें नहीं मिलीं; संगीत क्लिप्स को खाली सूची के रूप में सेट किया जा रहा है।",
        "review_aborted": "समीक्षा उपयोगकर्ता द्वारा निरस्त की गई। वीडियो निर्माण रद्द किया गया।",
        "video_creation_started": "वीडियो निर्माण शुरू हुआ...",
        "creating_video": "प्रारंभ - शीर्षक के साथ वीडियो बनाई जा रही है: ",
        "video_in_progress": "प्रगति में - शीर्षक के साथ वीडियो बनाई जा रही है: ",
        "main_execution_error": "❌ मुख्य निष्पादन में त्रुटि: ",

        # Dialog Messages
        "enter_keywords": "नए कीवर्ड दर्ज करें, कॉमा से अलग करें:",
        "description_label": "विवरण:",
        "tags_label": "टैग्स (कॉमा से अलग):",
        "privacy_label": "गोपनीयता:",
        "thumbnail_label": "थंबनेल:",
        "category_label": "श्रेणी:",
        "video_language_label": "वीडियो भाषा:",
        "recording_date_label": "रिकॉर्डिंग तिथि:",
        "switch_account_label": "YouTube खाता बदलें",
        "select_thumbnail": "थंबनेल चुनें",
        "image_files_filter": "छवि फ़ाइलें (*.png *.jpg *.jpeg)",
        "select_platform_title": "प्लेटफ़ॉर्म चुनें",
        "select_platform_prompt": "एक सोशल मीडिया प्लेटफ़ॉर्म चुनें:",
        "loading_clips_message": "क्लिप और उपशीर्षक लोड हो रहे हैं... कृपया प्रतीक्षा करें।",
        "moving_media_message": "मीडिया क्लिप स्थानांतरित हो रहा है... कृपया प्रतीक्षा करें।",
        "processing_subtitles_message": "उपशीर्षक संसाधित हो रहे हैं... कृपया प्रतीक्षा करें।",
        "loading_title": "लोड हो रहा है",
        "processing_title": "प्रसंस्करण",
        "support_tab": "सहायता",
        "check_faq_label": "कृपया पहले हमारे FAQ देखें:",
        "faq_link_text": "FAQ के लिए यहाँ क्लिक करें",
        "sr_number_label": "SR नंबर",
        "customer_name_label": "ग्राहक का नाम",
        "email_label": "ईमेल",
        "phone_label": "फ़ोन",
        "ticket_type_label": "टिकट का प्रकार",
        "issue_description_label": "समस्या का विवरण",
        "video_name_label": "वीडियो का नाम",
        "creation_dt_label": "निर्माण तिथि/समय (अनुमानित)",
        "desc_label": "विवरण",
        "send_button": "टिकट भेजें",
        "sr_sent_title": "टिकट भेजा गया",
        "sr_sent_msg": "आपकी सहायता अनुरोध सफलतापूर्वक भेजा गया है!"
    },
    # Korean
    "ko": {
        "missing_required_title": "필수 필드가 누락됨",
        "missing_required_msg": "모든 필수 필드를 작성해 주세요:\n",
        "issue_option": "문제",
        "enh_option":   "개선 사항",
        "comment_option": "댓글",
        "coming_soon_title":       "곧 출시 예정",
        "coming_soon_msg": (
            "{} 통합 기능이 곧 제공됩니다.\n\n"
            "최종 비디오를 수동으로 업로드하세요。\n"
            "비디오 경로: {}"
        ),
        "youtube_shorts_reminder_title": "YouTube Shorts 알림",
        "youtube_shorts_reminder_msg": (
            "참고: YouTube Shorts는 60초 이하의 동영상을 위한 기능입니다。"
            "동영상이 YouTube Shorts 길이 요건을 충족하는지 확인하세요。"
        ),
        "file_not_found_title":    "⚠️ 경고: 파일을 찾을 수 없음",
        "file_not_found_msg": (
            "{}에 대한 최종 비디오 파일을 찾을 수 없습니다。"
            "이 플랫폼용으로 생성하지 않았을 수 있습니다。"
            "생성한 후 다시 시도해주세요。"
        ),
        "yes": "예",
        "no": "아니요",
        "video": "비디오",
        "image": "이미지",
        "info": "정보",
        "switch_account": "계정 전환",
        "main_tab_title": "메인",
        "target_language_label": "대상 언어:",
        "voice_label": "내레이터 음성 선택:",
        "video_title_label": "비디오 제목:",
        "platform_label": "플랫폼:",
        "prompt_label": "비디오 내용 프롬프트 입력 (모든 언어 가능):",
        "genre_label": "악기 장르 선택:",
        "modify_label": "키워드 수정?",
        "bypass_label": "텍스트·자막·음성 건너뛰기?",
        "status_label": "상태:",
        "save_subtitles_btn": "자막 저장 및 재생성",
        "start_video_btn": "비디오 제작 시작",
        "play_video_btn_final": "비디오 재생",
        "replace_clip_btn": "선택한 클립 교체",
        "delete_clip_btn": "선택한 클립 삭제",
        "base_directory_label": "기본 디렉토리:",
        "base_browse_btn": "찾아보기",
        "video_image_folder_label": "비디오 이미지 폴더:",
        "output_directory_label": "출력 디렉토리:",
        "music_folder_label": "음악 폴더:",
        "voiceover_directory_label": "음성 디렉토리:",
        "review_script_tab": "스크립트 검토/편집",
        "review_clips_tab": "클립·자막 검토/편집",
        "test_voice_button": "음성 테스트",
        "generate_final_video_btn": "최종 비디오 생성",
        "final_video_tab": "최종 비디오",
        "upload_video_btn": "소셜 미디어 업로드",
        "clip_table_headers": [
            "선택", "미리보기", "미디어 유형", "파일", "길이",
            "시작", "종료", "선택", "음악 미리보기", "음악 파일",
            "음악 길이", "음악 시작", "음악 종료", "자막",
            "자막 시작", "자막 종료"
        ],
        "editable_field_tooltip": "편집 가능 필드",
        "readonly_field_tooltip": "읽기 전용 필드",
        "bypass_mode_message": (
            "건너뛰기 모드를 선택하여 스크립트·자막·음성이 생성되지 않았습니다.\n"
            "'클립·자막 검토/편집' 탭에서 미디어를 검토하세요.\n"
            "검토 후 '최종 비디오 생성' 클릭→완료 팝업에서 '확인' 클릭→"
            "'최종 비디오' 탭으로 자동 전환됩니다."
        ),
        "normal_mode_message": (
            "생성된 콘텐츠를 검토하세요:\n"
            "1. '스크립트 검토/편집' 탭에서 스크립트 검토·편집\n"
            "2. '자막 저장 및 재생성' 클릭→'클립·자막 검토/편집' 탭으로 이동\n"
            "검토 후 '최종 비디오 생성' 클릭→완료 팝업에서 '확인' 클릭→"
            "'최종 비디오' 탭으로 자동 전환됩니다."
        ),
        "add_media_btn": "미디어 추가",
        "add_music_btn": "음악 추가",
        "no_file_placeholder": "파일 없음",
        "none_text": "없음",
        "switch_account_tooltip": "다른 YouTube 계정으로 로그인하려면 선택하세요.",
        "target_language_tooltip": "인터페이스 번역 대상 언어를 선택하세요.",
        "prompt_tooltip": (
            "만들고자 하는 비디오 내용에 대한 상세 프롬프트를 작성하세요.\n"
            "핵심 주제, 스타일 및 필수 세부 정보를 포함하십시오.\n"
            "어떤 언어로 입력해도 선택된 언어로 비디오가 생성됩니다."
        ),
        "modify_tooltip": (
            "기본값 '예'는 추출된 키워드 편집 허용, '아니요'는 원본 유지합니다.\n"
            "더 많은 키워드는 더 많은 미디어를 가져오고, 정확한 키워드는 더 적절한 콘텐츠를 제공합니다."
        ),
        "modify_yes_tooltip": "예: 키워드 편집 허용",
        "modify_no_tooltip": "아니요: 원본 키워드 사용",
        "bypass_tooltip": (
            "'예' 시 텍스트·자막·음성 생성 건너뛰기\n"
            "예: 명상 비디오\n"
            "'아니요'(기본) 시 모두 생성"
        ),
        "bypass_yes_tooltip": "예: 생성 건너뛰기",
        "bypass_no_tooltip": "아니요: 생성",
        "play_button": "재생",
        "pause_button": "일시정지",
        "forward_button": "앞으로 (+10초)",
        "backward_button": "뒤로 (-10초)",
        "browse_button": "찾아보기",
        "success_text": "성공",
        "video_preview_title": "비디오 미리보기: ",
        "music_preview_title": "음악 미리보기: ",
        "voice_selector_title": "음성 선택기",
        "upload_details_title": "업로드 세부정보",
        "modify_keywords_title": "키워드 수정",
        "uploading_video": "YouTube에 비디오 업로드 중... 잠시 기다려주세요.",
        "uploading_thumbnail": "썸네일 업로드 중... 잠시 기다려주세요.",
        "generating_final_video": "최종 비디오 생성 중... 잠시 기다려주세요.",
        "saving_subtitles": "자막 저장 및 SRT 재생성",
        "replacing_media": "미디어 교체 중... 잠시 기다려주세요.",
        "deleting_clips": "클립 삭제 중... 잠시 기다려주세요.",
        "inserting_media": "미디어 삽입 중... 잠시 기다려주세요.",
        "inserting_music": "음악 삽입 중... 잠시 기다려주세요.",
        "starting_video": "비디오 제작 시작 중... 잠시 기다려주세요.",
        "upload_success": "✅ 업로드 성공!",
        "upload_failure": "❌ 업로드 중 오류 발생.",
        "upload_cancelled": "업로드가 취소되었습니다.",
        "subtitle_error": "❌ 자막 처리 오류: ",
        "select_media_warning": "교체할 미디어를 선택하세요.",
        "unsupported_file": "지원되지 않는 파일 형식입니다.",
        "replace_media_error": "❌ 미디어 교체 오류: ",
        "no_items_selected": "삭제할 항목이 없습니다.",
        "delete_error": "❌ 삭제 오류: ",
        "insert_media_error": "❌ 미디어 삽입 오류: ",
        "video_success_bypass": "건너뛰기 모드로 비디오 생성 완료.",
        "video_success": "비디오 생성 완료.",
        "encoding_error": "❌ 인코딩 오류 발생.",
        "review_content_title": "정보 - 콘텐츠 검토",
        "title_required": "제목을 입력하세요.",
        "platform_required": "플랫폼을 선택하세요.",
        "prompt_required": "프롬프트를 입력하세요.",
        "video_not_found": "비디오를 찾을 수 없음: ",
        "playback_error": "❌ 재생 중 오류 발생: ",
        "invalid_platform": "❌ 잘못된 플랫폼 설정: ",
        "encoding_complete": "인코딩 완료.",
        "encoding_error_status": "❌ 인코딩 오류 발생.",
        "general_error": "❌ 오류 발생: ",
        "playing_video": "비디오 재생 중: ",
        "subtitles_saved": "자막 저장 및 음성 생성 시작...",
        "items_deleted": "✅ 선택 항목 삭제 완료.",
        "no_media_found": "❌ 에서 미디어를 찾을 수 없습니다.",
        "video_processing_error": "❌ 비디오 처리 오류 (): ",
        "image_processing_error": "❌ 이미지 처리 오류 (): ",
        "no_valid_clips": "❌ 처리 가능한 클립이 없습니다.",
        "invalid_voiceover": "❌ 음성 길이 오류. 중단합니다.",
        "no_music_files": "❌ 음악 파일 없음; 음악 클립 비움.",
        "review_aborted": "검토 취소. 비디오 생성 취소.",
        "video_creation_started": "비디오 생성 시작됨...",
        "creating_video": "시작 - 비디오 생성 중: ",
        "video_in_progress": "진행 중 - 비디오 생성 중: ",
        "main_execution_error": "❌ 실행 중 오류 발생: ",
        "enter_keywords": "새 키워드를 쉼표로 구분하여 입력:",
        "description_label": "설명:",
        "tags_label": "태그 (쉼표로 구분):",
        "privacy_label": "공개 범위:",
        "thumbnail_label": "썸네일 이미지:",
        "category_label": "카테고리:",
        "video_language_label": "비디오 언어:",
        "recording_date_label": "녹화 날짜:",
        "switch_account_label": "YouTube 계정 전환",
        "select_thumbnail": "썸네일 선택",
        "image_files_filter": "이미지 파일 (*.png *.jpg *.jpeg)",
        "select_platform_title": "플랫폼 선택",
        "select_platform_prompt": "소셜 미디어 플랫폼을 선택하세요:",
        "loading_clips_message": "클립·자막 로드 중... 잠시 기다려주세요.",
        "moving_media_message": "미디어 클립 이동 중... 잠시 기다려주세요.",
        "processing_subtitles_message": "자막 처리 중... 잠시 기다려주세요.",
        "loading_title": "로드 중",
        "processing_title": "처리 중",
        "support_tab": "지원",
        "check_faq_label": "FAQ를 먼저 확인해 주세요:",
        "faq_link_text": "FAQ 보러가기",
        "sr_number_label": "SR 번호",
        "customer_name_label": "고객 이름",
        "email_label": "이메일",
        "phone_label": "전화번호",
        "ticket_type_label": "티켓 유형",
        "issue_description_label": "문제 설명",
        "video_name_label": "비디오 이름",
        "creation_dt_label": "생성 일시(예정)",
        "desc_label": "설명",
        "send_button": "티켓 전송",
        "sr_sent_title": "티켓 전송됨",
        "sr_sent_msg": "고객 지원 요청이 성공적으로 전송되었습니다!"
    },

    # Turkish
    "tr": {
        "missing_required_title": "Eksik Zorunlu Alanlar",
        "missing_required_msg": "Lütfen tüm zorunlu alanları doldurun:\n",
        "issue_option": "Sorun",
        "enh_option":   "Geliştirme",
        "comment_option": "Yorum",
        "coming_soon_title":       "Yakında",
        "coming_soon_msg": (
            "{} için entegrasyon yakında geliyor。\n\n"
            "Lütfen son videoyu manuel olarak yükleyin。\n"
            "Video yolu: {}"
        ),
        "youtube_shorts_reminder_title": "YouTube Shorts Hatırlatması",
        "youtube_shorts_reminder_msg": (
            "NOT: YouTube Shorts, 60 saniye veya daha kısa videolar içindir。"
            "Lütfen videonuzun YouTube Shorts uzunluk gereksinimini karşıladığından emin olun。"
        ),
        "file_not_found_title":    "⚠️ UYARI: Dosya Bulunamadı",
        "file_not_found_msg": (
            "{} için son video dosyası bulunamadı。"
            "Belki bu platform için oluşturmadınız。"
            "Lütfen oluşturun ve tekrar deneyin。"
        ),
        "yes": "Evet",
        "no": "Hayır",
        "video": "Video",
        "image": "Resim",
        "info": "Bilgi",
        "switch_account": "Hesap Değiştir",
        "main_tab_title": "Ana",
        "target_language_label": "Hedef Dil:",
        "voice_label": "Anlatıcı Sesi Seçin:",
        "video_title_label": "Video Başlığı:",
        "platform_label": "Platform:",
        "prompt_label": "Video içeriği için komut girin (her dilde):",
        "genre_label": "Enstrümantal Tür Seçin:",
        "modify_label": "Anahtar Kelimeleri Değiştir?",
        "bypass_label": "Metin, Altyazı, Seslendir. Atla?",
        "status_label": "Durum:",
        "save_subtitles_btn": "Altyazı Kaydet ve Yeniden Oluştur",
        "start_video_btn": "Video Oluşturmaya Başla",
        "play_video_btn_final": "Videoyu Oynat",
        "replace_clip_btn": "Seçili Klipi Değiştir",
        "delete_clip_btn": "Seçili Klipleri Sil",
        "base_directory_label": "Temel Dizin:",
        "base_browse_btn": "Gözat",
        "video_image_folder_label": "Video Resim Klasörü:",
        "output_directory_label": "Çıktı Dizini:",
        "music_folder_label": "Müzik Klasörü:",
        "voiceover_directory_label": "Seslendirme Dizini:",
        "review_script_tab": "Metni İncele/Düzenle",
        "review_clips_tab": "Klip & Altyazı İncele/Düzenle",
        "test_voice_button": "Sesi Test Et",
        "generate_final_video_btn": "Son Videoyu Oluştur",
        "final_video_tab": "Son Video",
        "upload_video_btn": "Sosyal Medyaya Yükle",
        "clip_table_headers": [
            "Seç", "Önizleme", "Tür", "Dosya", "Süre",
            "Baş", "Bitir", "Seç", "Müzik Önizleme", "Müzik Dosya",
            "Müzik Süre", "Müzik Baş", "Müzik Bitiş", "Altyazı",
            "Altyazı Baş", "Altyazı Bit"
        ],
        "editable_field_tooltip": "Düzenlenebilir alan",
        "readonly_field_tooltip": "Salt okunur alan",
        "bypass_mode_message": (
            "Atla modu seçildi; metin, altyazı, seslendirme oluşturulmadı.\n"
            "'Klip & Altyazı İncele/Düzenle' sekmesinde medya inceleyin.\n"
            "İnceleme bitince 'Son Videoyu Oluştur' butonuna tıklayın.\n"
            "Oluşturma tamamlanınca uyarıda ‘Tamam’a basın."
        ),
        "normal_mode_message": (
            "Oluşturulan içeriği inceleyin:\n"
            "1. 'Metni İncele/Düzenle' sekmesinde metni gözden geçirin.\n"
            "2. 'Altyazı Kaydet ve Yeniden Oluştur' tıklayın → 'Klip & Altyazı İncele/Düzenle' sekmesine geçiş.\n"
            "İnceleme bitince 'Son Videoyu Oluştur' tıklayın → uyarıda ‘Tamam’a tıklayın."
        ),
        "add_media_btn": "Medya Ekle",
        "add_music_btn": "Müzik Ekle",
        "no_file_placeholder": "Dosya yok",
        "none_text": "Yok",
        "switch_account_tooltip": "Başka YouTube hesabıyla giriş yapmak için işaretleyin.",
        "target_language_tooltip": "Arayüz çevirisi için hedef dili seçin.",
        "prompt_tooltip": (
            "Oluşturmak istediğiniz video içeriğini ayrıntılı şekilde tanımlayın.\n"
            "Temel konular, stil ve gerekli tüm ayrıntıları ekleyin.\n"
            "Herhangi bir dilde yazabilirsiniz; video seçilen dilde üretilir."
        ),
        "modify_tooltip": (
            "'Evet' (varsayılan) anahtar kelimeleri düzenlemeye izin verir;\n"
            "'Hayır' orijinal kelimeleri korur.\n"
            "Daha fazla kelime, daha fazla medya getirir; daha öz kelimeler daha ilgili içerik üretir."
        ),
        "modify_yes_tooltip": "Evet: Düzenleme izin ver",
        "modify_no_tooltip": "Hayır: Orijinal kullan",
        "bypass_tooltip": (
            "'Evet' text, altyazı, ses oluşturmayı atlar.\n"
            "Örnek: meditasyon videoları.\n"
            "'Hayır'(varsayılan) hepsi oluşturulur."
        ),
        "bypass_yes_tooltip": "Evet: Atla",
        "bypass_no_tooltip": "Hayır: Oluştur",
        "play_button": "Oynat",
        "pause_button": "Duraklat",
        "forward_button": "İleri (+10 sn)",
        "backward_button": "Geri (-10 sn)",
        "browse_button": "Gözat",
        "success_text": "Başarı",
        "video_preview_title": "Video Önizleme: ",
        "music_preview_title": "Müzik Önizleme: ",
        "voice_selector_title": "Ses Seçici",
        "upload_details_title": "Yükleme Detayları",
        "modify_keywords_title": "Anahtar Kelimeleri Düzenle",
        "uploading_video": "YouTube’a video yükleniyor... Lütfen bekleyin.",
        "uploading_thumbnail": "Thumbnail yükleniyor... Lütfen bekleyin.",
        "generating_final_video": "Son video oluşturuluyor... Lütfen bekleyin.",
        "saving_subtitles": "Altyazılar kaydediliyor ve SRT yeniden oluşturuluyor",
        "replacing_media": "Medya değiştiriliyor... Lütfen bekleyin.",
        "deleting_clips": "Klipler siliniyor... Lütfen bekleyin.",
        "inserting_media": "Yeni medya ekleniyor... Lütfen bekleyin.",
        "inserting_music": "Yeni müzik ekleniyor... Lütfen bekleyin.",
        "starting_video": "Video oluşturma başlatılıyor... Lütfen bekleyin.",
        "upload_success": "✅ Yükleme başarılı!",
        "upload_failure": "❌ Yükleme sırasında hata oluştu.",
        "upload_cancelled": "Yükleme iptal edildi.",
        "subtitle_error": "❌ Altyazı işleme hatası: ",
        "select_media_warning": "Lütfen bir medya seçin.",
        "unsupported_file": "Desteklenmeyen dosya türü.",
        "replace_media_error": "❌ Medya değiştirme hatası: ",
        "no_items_selected": "Silinecek öğe yok.",
        "delete_error": "❌ Silme hatası: ",
        "insert_media_error": "❌ Medya ekleme hatası: ",
        "video_success_bypass": "Atla modunda video başarıyla oluşturuldu.",
        "video_success": "Video başarıyla oluşturuldu.",
        "encoding_error": "❌ Ayrı işlemde kodlama hatası.",
        "review_content_title": "Bilgi - İçeriği İncele",
        "title_required": "Lütfen bir başlık girin.",
        "platform_required": "Lütfen bir platform seçin.",
        "prompt_required": "Lütfen bir video komutu girin.",
        "video_not_found": "Video bulunamadı: ",
        "playback_error": "❌ Oynatma hatası: ",
        "invalid_platform": "❌ Geçersiz platform ayarı: ",
        "encoding_complete": "Video kodlama başarıyla tamamlandı.",
        "encoding_error_status": "❌ Kodlama hatası oluştu.",
        "general_error": "❌ Bir hata oluştu: ",
        "playing_video": "Video oynatılıyor: ",
        "subtitles_saved": "Altyazılar kaydedildi, seslendirme oluşturuluyor...",
        "items_deleted": "✅ Seçili öğeler silindi.",
        "no_media_found": "❌  içinde medya bulunamadı",
        "video_processing_error": "❌ Video işleme hatası (): ",
        "image_processing_error": "❌ Resim işleme hatası (): ",
        "no_valid_clips": "❌ Geçerli klip yok.",
        "invalid_voiceover": "❌ Geçersiz ses uzunluğu. İptal ediliyor.",
        "no_music_files": "❌ Müzik dosyası bulunamadı; boş liste ayarlandı.",
        "review_aborted": "İnceleme iptal edildi. Video oluşturma durduruldu.",
        "video_creation_started": "Video oluşturma başladı...",
        "creating_video": "Başlatılıyor – Video oluşturuluyor: ",
        "video_in_progress": "Devam ediyor – Video oluşturuluyor: ",
        "main_execution_error": "❌ Ana yürütmede hata: ",
        "enter_keywords": "Yeni anahtar kelimeleri virgülle ayırarak girin:",
        "description_label": "Açıklama:",
        "tags_label": "Etiketler (virgülle):",
        "privacy_label": "Gizlilik:",
        "thumbnail_label": "Thumbnail Resim:",
        "category_label": "Kategori:",
        "video_language_label": "Video Dili:",
        "recording_date_label": "Kayıt Tarihi:",
        "switch_account_label": "YouTube Hesabı Değiştir",
        "select_thumbnail": "Thumbnail Seç",
        "image_files_filter": "Resim Dosyaları (*.png *.jpg *.jpeg)",
        "select_platform_title": "Platform Seç",
        "select_platform_prompt": "Sosyal medya platformu seçin:",
        "loading_clips_message": "Klip & altyazılar yükleniyor... Lütfen bekleyin.",
        "moving_media_message": "Medya klibi taşınıyor... Lütfen bekleyin.",
        "processing_subtitles_message": "Altyazılar işleniyor... Lütfen bekleyin.",
        "loading_title": "Yükleniyor",
        "processing_title": "İşleniyor",
        "support_tab": "Destek",
        "check_faq_label": "Lütfen önce SSS sayfamıza bakın:",
        "faq_link_text": "SSS için buraya tıklayın",
        "sr_number_label": "SR Numarası",
        "customer_name_label": "Müşteri Adı",
        "email_label": "E-posta",
        "phone_label": "Telefon",
        "ticket_type_label": "Talep Türü",
        "issue_description_label": "Sorunun Açıklaması",
        "video_name_label": "Video Adı",
        "creation_dt_label": "Oluşturma Tarihi/Saati (tahmini)",
        "desc_label": "Açıklama",
        "send_button": "Talebi Gönder",
        "sr_sent_title": "Talep Gönderildi",
        "sr_sent_msg": "Destek talebiniz başarıyla gönderildi!"

    },

    # Urdu
    "ur": {
        "missing_required_title": "ضروری فیلڈز غائب ہیں",
        "missing_required_msg": "براہ کرم تمام ضروری فیلڈز پُر کریں:\n",
        "issue_option": "مسئلہ",
        "enh_option":   "بہتری",
        "comment_option": "تبصرہ",
        "coming_soon_title":       "جلد آرہا ہے",
        "coming_soon_msg": (
            "{} کے لیے انضمام جلد آرہا ہے۔\n\n"
            "براہ کرم حتمی ویڈیو کو دستی طور پر اپ لوڈ کریں۔\n"
            "ویڈیو کا راستہ: {}"
        ),
        "youtube_shorts_reminder_title": "YouTube Shorts کی یاددہانی",
        "youtube_shorts_reminder_msg": (
            "نوٹ: YouTube Shorts 60 سیکنڈ یا اس سے کم کی ویڈیوز کے لیے ہیں۔"
            "براہ کرم یقینی بنائیں کہ آپ کی ویڈیو YouTube Shorts کی لمبائی کی شرائط پوری کرتی ہے۔"
        ),
        "file_not_found_title":    "⚠️ انتباہ: فائل نہیں ملی",
        "file_not_found_msg": (
            "{} کے لیے فائنل ویڈیو فائل نہیں ملی۔"
            "ہو سکتا ہے کہ آپ نے اسے اس مخصوص پلیٹ فارم کے لیے تیار نہیں کیا ہو۔"
            "براہِ کرم اسے تیار کریں اور دوبارہ کوشش کریں۔"
        ),
        "yes": "جی ہاں",
        "no": "نہیں",
        "video": "ویڈیو",
        "image": "تصویر",
        "info": "معلومات",
        "switch_account": "اکاؤنٹ تبدیل کریں",
        "main_tab_title": "مرکزی",
        "target_language_label": "مطلوبہ زبان:",
        "voice_label": "راوی کی آواز منتخب کریں:",
        "video_title_label": "ویڈیو عنوان:",
        "platform_label": "پلیٹ فارم:",
        "prompt_label": "ویڈیو کے لیے ہدایت درج کریں (کسی بھی زبان میں):",
        "genre_label": "آلاتی صنف منتخب کریں:",
        "modify_label": "کلیدی الفاظ تبدیل کریں؟",
        "bypass_label": "متن·سب ٹائٹل·وائس اوور کو چھوڑیں؟",
        "status_label": "حالت:",
        "save_subtitles_btn": "سب ٹائٹل محفوظ کریں اور دوبارہ بنائیں",
        "start_video_btn": "ویڈیو بنانا شروع کریں",
        "play_video_btn_final": "ویڈیو چلائیں",
        "replace_clip_btn": "منتخب کلپ تبدیل کریں",
        "delete_clip_btn": "منتخب کلپس حذف کریں",
        "base_directory_label": "بنیادی پوشہ:",
        "base_browse_btn": "براؤز کریں",
        "video_image_folder_label": "ویڈیو امیج فولڈر:",
        "output_directory_label": "آؤٹ پٹ ڈائریکٹری:",
        "music_folder_label": "موسیقی فولڈر:",
        "voiceover_directory_label": "وائس اوور فولڈر:",
        "review_script_tab": "اسکرپٹ کا جائزہ/ ترمیم",
        "review_clips_tab": "کلپس·سب ٹائٹل کا جائزہ/ ترمیم",
        "test_voice_button": "آواز آزمائیں",
        "generate_final_video_btn": "حتمی ویڈیو بنائیں",
        "final_video_tab": "حتمی ویڈیو",
        "upload_video_btn": "سوشل میڈیا پر اپ لوڈ کریں",
        "clip_table_headers": [
            "منتخب کریں", "پری ویو", "قسم", "فائل", "دورانیہ",
            "آغاز", "اختتام", "منتخب کریں", "موسیقی پری ویو",
            "موسیقی فائل", "میوزک دورانیہ", "میوزک آغاز",
            "میوزک اختتام", "سب ٹائٹل", "سب ٹائٹل آغاز",
            "سب ٹائٹل اختتام"
        ],
        "editable_field_tooltip": "قابل ترمیم فیلڈ",
        "readonly_field_tooltip": "صرف پڑھنے کے لیے",
        "bypass_mode_message": (
            "آپ نے اسکرپٹ·سب ٹائٹل·وائس اوور موڈ چھوڑنے کا انتخاب کیا ہے؛\n"
            "اسکرپٹ/سب ٹائٹل/وائس اوور تیار نہیں ہوا۔\n"
            "'کلپس·سب ٹائٹل جائزہ/ترمیم' ٹیب میں میڈیا دیکھیں۔\n"
            "جائزہ مکمل → 'حتمی ویڈیو بنائیں' دبائیں → پاپ اپ میں 'ٹھیک ہے' دبائیں →\n"
            "'حتمی ویڈیو' ٹیب پر خودکار منتقل۔"
        ),
        "normal_mode_message": (
            "براہ کرم تیار کردہ مواد کا جائزہ لیں:\n"
            "1. 'اسکرپٹ جائزہ/ترمیم' میں اسکرپٹ دیکھیں/ترمیم کریں۔\n"
            "2. 'سب ٹائٹل محفوظ کریں اور دوبارہ بنائیں' دبائیں → 'کلپس·سب ٹائٹل جائزہ/ترمیم' ٹیب میں جائیں۔\n"
            "جائزہ مکمل → 'حتمی ویڈیو بنائیں' دبائیں → پاپ اپ میں 'ٹھیک ہے' دبائیں."
        ),
        "add_media_btn": "میڈیا شامل کریں",
        "add_music_btn": "موسیقی شامل کریں",
        "no_file_placeholder": "کوئی فائل نہیں",
        "none_text": "کوئی نہیں",
        "switch_account_tooltip": "دوسرے YouTube اکاؤنٹ سے سائن ان کرنے کے لیے چیک کریں۔",
        "target_language_tooltip": "انٹرفیس ترجمے کے لیے مطلوبہ زبان منتخب کریں۔",
        "prompt_tooltip": (
            "ویڈیو کے مواد کا مکمل ہدایت نامہ فراہم کریں۔\n"
            "اہم موضوعات، انداز، اور تمام ضروری تفصیلات شامل کریں۔\n"
            "آپ کسی بھی زبان میں لکھ سکتے ہیں؛ ویڈیو منتخب زبان میں بنے گا۔"
        ),
        "modify_tooltip": (
            "'ہاں' (ڈیفالٹ) کلیدی الفاظ میں ترمیم کی اجازت دیتا ہے؛\n"
            "'نہیں' اصل الفاظ کو برقرار رکھتا ہے۔\n"
            "زیادہ الفاظ زیادہ میڈیا لائیں گے؛ زیادہ مخصوص الفاظ بہتر نتائج دیں گے۔"
        ),
        "modify_yes_tooltip": "ہاں: ترمیم کی اجازت",
        "modify_no_tooltip": "نہیں: اصل استعمال کریں",
        "bypass_tooltip": (
            "'ہاں' متن·سب ٹائٹل·وائس اوور پیداوار چھوڑ دے گا۔\n"
            "مثال: مراقبے کی ویڈیوز.\n"
            "'نہیں'(ڈیفالٹ) سب پیداوار کریں."
        ),
        "bypass_yes_tooltip": "ہاں: چھوڑ دیں",
        "bypass_no_tooltip": "نہیں: پیداوار کریں",
        "play_button": "چلائیں",
        "pause_button": "روکیں",
        "forward_button": "آگے (+10 س)",
        "backward_button": "پیچھے (-10 س)",
        "browse_button": "براؤز کریں",
        "success_text": "کامیابی",
        "video_preview_title": "ویڈیو پری ویو: ",
        "music_preview_title": "موسیقی پری ویو: ",
        "voice_selector_title": "وائس سیلیکٹر",
        "upload_details_title": "اپ لوڈ تفصیلات",
        "modify_keywords_title": "کلیدی الفاظ تبدیل کریں",
        "uploading_video": "ویڈیو اپ لوڈ ہو رہی ہے... براہ کرم انتظار کریں۔",
        "uploading_thumbnail": "تھمب نیل اپ لوڈ ہو رہی ہے... براہ کرم انتظار کریں۔",
        "generating_final_video": "حتمی ویڈیو بنائی جا رہی ہے... براہ کرم انتظار کریں۔",
        "saving_subtitles": "سب ٹائٹلز محفوظ کریں اور SRT دوبارہ بنائیں۔",
        "replacing_media": "منتخب میڈیا تبدیل کیا جا رہا ہے... براہ کرم انتظار کریں۔",
        "deleting_clips": "منتخب کلپس حذف کیے جا رہے ہیں... براہ کرم انتظار کریں۔",
        "inserting_media": "نیا میڈیا شامل کیا جا رہا ہے... براہ کرم انتظار کریں۔",
        "inserting_music": "نئی موسیقی شامل کی جا رہی ہے... براہ کرم انتظار کریں۔",
        "starting_video": "ویڈیو بنانا شروع ہو رہا ہے... براہ کرم انتظار کریں۔",
        "review_content_title": "معلومات - مواد کا جائزہ",
        "title_required": "براہ کرم ویڈیو کا عنوان درج کریں۔",
        "platform_required": "براہ کرم ایک پلیٹ فارم منتخب کریں۔",
        "prompt_required": "براہ کرم ویڈیو سکرپٹ پرامپٹ درج کریں۔",
        "video_not_found": "ویڈیو فائل نہیں ملی: ",
        "playback_error": "❌ ویڈیو چلانے میں خرابی: ",
        "invalid_platform": "❌ غلط پلیٹ فارم کی ترتیبات: ",
        "encoding_complete": "ویڈیو انکوڈنگ کامیابی کے ساتھ مکمل ہوئی۔",
        "encoding_error_status": "❌ علیحدہ عمل میں انکوڈنگ میں خرابی۔",
        "general_error": "❌ ایک خرابی پیش آئی: ",
        "playing_video": "ویڈیو چل رہی ہے: ",
        "subtitles_saved": "سب ٹائٹلز محفوظ ہو گئے اور وائس اوور جنریشن شروع ہو گیا۔",
        "items_deleted": "✅ منتخب آئٹمز حذف کر دیے گئے۔",
        "no_media_found": "❌  میں کوئی میڈیا فائل نہیں ملی",
        "video_processing_error": "❌ ویڈیو پروسیس کرنے میں خرابی (): ",
        "image_processing_error": "❌ امیج پروسیس کرنے میں خرابی (): ",
        "no_valid_clips": "❌ کوئی موزوں کلپ دستیاب نہیں۔",
        "invalid_voiceover": "❌ وائس اوور کی مدت غلط ہے۔ منسوخ کر رہے ہیں۔",
        "no_music_files": "❌ کوئی موسیقی فائل نہیں ملی؛ موسیقی کلپس خالی کر دیے گئے۔",
        "review_aborted": "جائزہ صارف نے منسوخ کیا؛ ویڈیو تخلیق منسوخ۔",
        "video_creation_started": "ویڈیو تخلیق شروع ہو گئی...",
        "creating_video": "شروع - ویڈیو بنائی جا رہی ہے: ",
        "video_in_progress": "جاری ہے - ویڈیو بنائی جا رہی ہے: ",
        "main_execution_error": "❌ مرکزی عمل میں خرابی: ",
        "enter_keywords": "نئے کلیدی الفاظ کو کاما سے جدا کرکے درج کریں:",
        "description_label": "تفصیل:",
        "tags_label": "ٹیگز (کاماز میں جدا):",
        "privacy_label": "رازداری:",
        "thumbnail_label": "تھمب نیل تصویر:",
        "category_label": "زمرہ:",
        "video_language_label": "ویڈیو زبان:",
        "recording_date_label": "ریکارڈنگ کی تاریخ:",
        "loading_clips_message": "کلپس اور سب ٹائٹلز لوڈ ہو رہے ہیں... براہ کرم انتظار کریں۔",
        "moving_media_message": "میڈیا کلپ منتقل کیا جا رہا ہے... براہ کرم انتظار کریں۔",
        "processing_subtitles_message": "سب ٹائٹلز پروسیس ہو رہے ہیں... براہ کرم انتظار کریں۔",
        "loading_title": "لوڈ ہو رہا ہے",
        "processing_title": "عمل جاری ہے",
        "support_tab": "سپورٹ",
        "check_faq_label": "براہ کرم پہلے ہمارا FAQ دیکھیں:",
        "faq_link_text": "FAQ کے لیے یہاں کلک کریں",
        "sr_number_label": "SR نمبر",
        "customer_name_label": "صارف کا نام",
        "email_label": "ای میل",
        "phone_label": "فون",
        "ticket_type_label": "ٹکٹ کی قسم",
        "issue_description_label": "مسئلے کی تفصیل",
        "video_name_label": "ویڈیو کا نام",
        "creation_dt_label": "تخلیق کی تاریخ/وقت (تخمینہ)",
        "desc_label": "تفصیل",
        "send_button": "ٹکٹ بھیجیں",
        "sr_sent_title": "ٹکٹ بھیج دیا گیا",
        "sr_sent_msg": "آپ کی معاونت کی درخواست کامیابی سے بھیج دی گئی ہے!"
    },
    # Persian
    "fa": {
        "missing_required_title": "فیلدهای ضروری مفقود هستند",
        "missing_required_msg": "لطفاً تمام فیلدهای ضروری را پر کنید:\n",
        "issue_option": "مشکل",
        "enh_option":   "بهبود",
        "comment_option": "نظر",
        "coming_soon_title": "به زودی",
        "coming_soon_msg": (
            "یکپارچه‌سازی برای {} به زودی آماده می‌شود.\n\n"
            "لطفاً ویدیوی نهایی را به‌صورت دستی بارگذاری کنید.\n"
            "مسیر ویدیو: {}"
        ),
        "youtube_shorts_reminder_title": "یادآوری YouTube Shorts",
        "youtube_shorts_reminder_msg": (
            "توجه: YouTube Shorts برای ویدیوهای حداکثر ۶۰ ثانیه طراحی شده است. "
            "لطفاً مطمئن شوید ویدیوی شما با محدودیت زمانی YouTube Shorts هماهنگ است."
        ),
        "file_not_found_title": "⚠️ هشدار: فایل یافت نشد",
        "file_not_found_msg": (
            "فایل ویدیوی نهایی برای {} پیدا نشد. "
            "ممکن است برای سکوی موردنظر ساخته نشده باشد. "
            "لطفاً ابتدا آن را تولید کرده و سپس دوباره تلاش کنید."
        ),
        "yes": "بله",
        "no": "خیر",
        "video": "ویدیو",
        "image": "تصویر",
        "info": "اطلاعات",
        "switch_account": "تغییر حساب کاربری",
        "main_tab_title": "اصلی",
        "target_language_label": "زبان هدف:",
        "voice_label": "صدای گوینده را انتخاب کنید:",
        "video_title_label": "عنوان ویدیو:",
        "platform_label": "سکو:",
        "prompt_label": "متن درخواست (Prompt) برای محتوای ویدیو را وارد کنید (به هر زبانی):",
        "genre_label": "سبک موسیقی بی‌کلام را انتخاب کنید:",
        "modify_label": "آیا کلمات کلیدی را تغییر دهید؟",
        "bypass_label": "عبور از متن، زیرنویس‌ها و صداگذاری؟",
        "status_label": "وضعیت:",
        "save_subtitles_btn": "ذخیره و بازتولید زیرنویس‌ها",
        "start_video_btn": "شروع ساخت ویدیو",
        "play_video_btn_final": "پخش ویدیو",
        "replace_clip_btn": "جایگزینی کلیپ انتخابی",
        "delete_clip_btn": "حذف کلیپ(های) انتخابی",
        "base_directory_label": "پوشه اصلی:",
        "base_browse_btn": "مرور",
        "video_image_folder_label": "پوشه تصاویر ویدیو:",
        "output_directory_label": "پوشه خروجی:",
        "music_folder_label": "پوشه موسیقی:",
        "voiceover_directory_label": "پوشه صداگذاری:",
        "review_script_tab": "بازبینی یا ویرایش متن ویدیو",
        "review_clips_tab": "بازبینی یا ویرایش کلیپ‌ها و زیرنویس‌ها",
        "test_voice_button": "تست صدا",
        "generate_final_video_btn": "تولید ویدیوی نهایی",
        "final_video_tab": "ویدیوی نهایی",
        "upload_video_btn": "بارگذاری در شبکه‌های اجتماعی",
        "clip_table_headers": [
            "انتخاب", "پیش‌نمایش رسانه", "نوع رسانه", "فایل رسانه", "مدت رسانه",
            "شروع رسانه", "پایان رسانه", "انتخاب", "پیش‌نمایش موسیقی", "فایل موسیقی",
            "مدت موسیقی", "شروع موسیقی", "پایان موسیقی", "زیرنویس", "شروع زیرنویس", "پایان زیرنویس"
        ],
        # Tooltips
        "editable_field_tooltip": "فیلد قابل ویرایش",
        "readonly_field_tooltip": "فیلد فقط خواندنی",
        "bypass_mode_message": (
            "از آنجا که حالت عبور از متن، زیرنویس‌ها و صداگذاری را انتخاب کرده‌اید، "
            "هیچ متن، زیرنویس یا صداگذاری تولید نشده است.\n"
            "لطفاً رسانه‌های دانلودشده را در برگه «بازبینی یا ویرایش کلیپ‌ها و زیرنویس‌ها» بررسی کنید.\n"
            "سپس برای تولید ویدیوی نهایی روی «تولید ویدیوی نهایی» کلیک کنید.\n"
            "پس از تولید ویدیوی نهایی، روی OK در پیام پاپ‌آپ کلیک کنید.\n"
            "سپس به‌صورت خودکار به برگه «ویدیوی نهایی» هدایت می‌شوید تا پیش‌نمایش ویدیو را ببینید.\n"
            "برای بستن این اعلان، روی OK کلیک کنید."
        ),
        "normal_mode_message": (
            "لطفاً محتوای تولیدشده را بررسی کنید:\n"
            "۱. در برگه «بازبینی یا ویرایش متن ویدیو»، متن تولیدشده را بررسی یا ویرایش کنید.\n"
            "۲. سپس روی دکمه «ذخیره و بازتولید زیرنویس‌ها» کلیک کنید تا به برگه "
            "«بازبینی یا ویرایش کلیپ‌ها و زیرنویس‌ها» بروید.\n"
            "پس از اتمام بررسی، برای تولید ویدیوی نهایی روی دکمه «تولید ویدیوی نهایی» کلیک کنید.\n"
            "وقتی ویدیوی نهایی تولید شد، در پیام پاپ‌آپ روی OK کلیک کنید.\n"
            "سپس به‌طور خودکار به برگه «ویدیوی نهایی» منتقل می‌شوید تا پیش‌نمایش ویدیو را ببینید.\n"
            "برای بستن این اعلان، روی OK کلیک کنید."
        ),
        # Buttons
        "add_media_btn": "افزودن رسانه",
        "add_music_btn": "افزودن موسیقی",
        # Placeholders
        "no_file_placeholder": "بدون فایل",
        "none_text": "هیچ‌کدام",
        # ToolTips
        "switch_account_tooltip": "در صورت تمایل به ورود با حساب یوتیوب دیگری، این گزینه را علامت بزنید.",
        "target_language_tooltip": "زبان هدف را برای ترجمه رابط کاربری انتخاب کنید.",
        "prompt_tooltip": (
            "یک متن درخواست (Prompt) جامع ارائه دهید که شرح‌دهنده محتوای ویدیویی موردنظرتان باشد.\n"
            "موضوعات کلیدی، سبک دلخواه و تمام جزئیات ضروری را برای هدایت ساخت ویدیو مشخص کنید.\n"
            "می‌توانید متن درخواست را به هر زبانی بنویسید؛ ویدیو در زبان انتخابی تولید خواهد شد.\n"
            "خروجی تولیدشده، متنی برای ویدیوی شماست که می‌توانید آن را بعداً بازبینی کنید."
        ),
        "modify_tooltip": (
            "گزینه «بله» (پیش‌فرض) اجازه ویرایش کلمات کلیدی استخراج‌شده از متن را می‌دهد؛ انتخاب «خیر» "
            "همان کلمات کلیدی اصلی را حفظ می‌کند.\n"
            "این کلمات کلیدی تعیین‌کنندهٔ رسانه‌های دانلودشده هستند؛ کلمات کلیدی بیشتر "
            "ممکن است رسانه بیشتری (و ویدیوهای طولانی‌تر) را به همراه داشته باشد، در حالی که کلمات کلیدی دقیق‌تر، محتوای مرتبط‌تری تولید می‌کند.\n"
            "توجه: اگر از زبانی به‌جز انگلیسی استفاده کنید، به‌طور خودکار کلمات کلیدی انگلیسی نیز برای دریافت محتوای بهینه افزوده خواهند شد."
        ),
        "modify_yes_tooltip": "بله: اجازه ویرایش کلمات کلیدی استخراج‌شده.",
        "modify_no_tooltip": "خیر: استفاده از کلمات کلیدی اصلی تولیدشده.",
        "bypass_tooltip": (
            "زمانی که «بله» تنظیم شود، فرایند تولید و پردازش متن، زیرنویس و صداگذاری نادیده گرفته می‌شود.\n"
            "مثال: ویدیوهای مدیتیشن یا آرامش‌بخش.\n"
            "اگر «خیر» (پیش‌فرض) انتخاب شود، متن، زیرنویس و صداگذاری تولید خواهند شد."
        ),
        "bypass_yes_tooltip": "بله: عبور از تولید متن، زیرنویس و صداگذاری.",
        "bypass_no_tooltip": "خیر: تولید متن، زیرنویس و صداگذاری.",

        # Buttons
        "play_button": "پخش",
        "pause_button": "توقف موقت",
        "forward_button": "جلو (+10 ثانیه)",
        "backward_button": "عقب (-10 ثانیه)",
        "browse_button": "مرور",

        # Window Titles
        "success_text": "موفقیت‌آمیز",
        "video_preview_title": "پیش‌نمایش ویدیو: ",
        "music_preview_title": "پیش‌نمایش موسیقی: ",
        "voice_selector_title": "انتخاب صدا",
        "upload_details_title": "جزئیات آپلود",
        "modify_keywords_title": "ویرایش کلمات کلیدی",

        # Progress Messages
        "uploading_video": "در حال آپلود ویدیو در یوتیوب... لطفاً صبر کنید.",
        "uploading_thumbnail": "در حال آپلود تصویر بندانگشتی یوتیوب... لطفاً صبر کنید.",
        "generating_final_video": "در حال تولید ویدیوی نهایی... لطفاً صبر کنید.",
        "saving_subtitles": "در حال ذخیره زیرنویس‌ها و بازتولید فایل SRT",
        "replacing_media": "در حال جایگزینی رسانه انتخاب‌شده... لطفاً صبر کنید.",
        "deleting_clips": "در حال حذف کلیپ(های) انتخاب‌شده... لطفاً صبر کنید.",
        "inserting_media": "در حال افزودن رسانه جدید... لطفاً صبر کنید.",
        "inserting_music": "در حال افزودن موسیقی جدید... لطفاً صبر کنید.",
        "starting_video": "در حال شروع ساخت ویدیو... لطفاً صبر کنید.",

        # Info Messages
        "upload_success": "✅ آپلود ویدیوی یوتیوب با موفقیت انجام شد!",
        "upload_failure": "❌ در هنگام آپلود خطایی رخ داد.",
        "upload_cancelled": "آپلود توسط کاربر لغو شد.",
        "subtitle_error": "❌ هنگام پردازش زیرنویس‌ها خطایی رخ داد: ",
        "select_media_warning": "لطفاً برای جایگزینی، یک سلول رسانه را انتخاب کنید.",
        "unsupported_file": "نوع فایل انتخاب‌شده پشتیبانی نمی‌شود.",
        "replace_media_error": "❌ در هنگام جایگزینی رسانه انتخاب‌شده خطایی رخ داد: ",
        "no_items_selected": "هیچ رسانه، موسیقی یا زیرنویسی برای حذف انتخاب نشده است.",
        "delete_error": "❌ در هنگام حذف کلیپ(ها) خطایی رخ داد: ",
        "insert_media_error": "❌ در هنگام افزودن رسانه جدید خطایی رخ داد: ",
        "video_success_bypass": "ساخت ویدیو با موفقیت پایان یافت (حالت عبور).",
        "video_success": "ساخت ویدیو با موفقیت پایان یافت.",
        "encoding_error": "❌ خطا در کد‌گذاری ویدیو در فرایند مجزا.",
        "review_content_title": "اطلاعات - بررسی محتوا",
        "title_required": "لطفاً یک عنوان برای ویدیو وارد کنید.",
        "platform_required": "لطفاً یک سکو انتخاب کنید.",
        "prompt_required": "لطفاً متن درخواست ویدیویی را وارد کنید.",
        "video_not_found": "فایل ویدیو یافت نشد: ",
        "playback_error": "❌ در هنگام پخش ویدیو خطایی رخ داد: ",
        "invalid_platform": "❌ تنظیمات سکوی نامعتبر برای .",

        # Status Messages
        "encoding_complete": "کد‌گذاری ویدیو با موفقیت به پایان رسید.",
        "encoding_error_status": "❌ خطا در کد‌گذاری ویدیو در فرایند مجزا.",
        "general_error": "❌ یک خطا رخ داده است: ",
        "playing_video": "در حال پخش ویدیو: ",
        "subtitles_saved": "زیرنویس‌ها ذخیره شد و تولید صداگذاری آغاز شد...",
        "items_deleted": "✅ موارد انتخاب‌شده حذف شدند.",
        "no_media_found": "❌ هیچ ویدیو یا تصویری در مسیر زیر یافت نشد: ",
        "video_processing_error": "❌ خطا در پردازش فایل ویدیو: ",
        "image_processing_error": "❌ خطا در پردازش فایل تصویر: ",
        "no_valid_clips": "❌ هیچ کلیپ معتبری در دسترس نیست.",
        "invalid_voiceover": "❌ طول صداگذاری نامعتبر است. عملیات متوقف شد.",
        "no_music_files": "❌ هیچ فایل موسیقی یافت نشد؛ لیست موسیقی خالی شد.",
        "review_aborted": "بررسی توسط کاربر لغو شد. ساخت ویدیو متوقف گردید.",
        "video_creation_started": "ساخت ویدیو آغاز شد...",
        "creating_video": "در حال شروع ساخت ویدیو با عنوان: ",
        "video_in_progress": "در حال انجام - ساخت ویدیو با عنوان: ",
        "main_execution_error": "❌ خطا در فرایند اصلی: ",

        # Dialog Messages
        "enter_keywords": "کلمات کلیدی جدید را با ویرگول از هم جدا کنید:",
        "description_label": "توضیحات:",
        "tags_label": "برچسب‌ها (با ویرگول جدا کنید):",
        "privacy_label": "حریم خصوصی:",
        "thumbnail_label": "تصویر بندانگشتی:",
        "category_label": "دسته‌بندی:",
        "video_language_label": "زبان ویدیو:",
        "recording_date_label": "تاریخ ضبط:",
        "switch_account_label": "تغییر حساب یوتیوب",
        "select_thumbnail": "انتخاب تصویر بندانگشتی",
        "image_files_filter": "فایل‌های تصویری (*.png *.jpg *.jpeg)",
        "select_platform_title": "انتخاب سکو",
        "select_platform_prompt": "یک سکوی اجتماعی انتخاب کنید:",
        "loading_clips_message": "در حال بارگذاری کلیپ‌ها و زیرنویس‌ها... لطفاً صبر کنید.",
        "moving_media_message": "در حال جابه‌جایی کلیپ رسانه... لطفاً صبر کنید.",
        "processing_subtitles_message": "در حال پردازش زیرنویس‌ها... لطفاً صبر کنید.",
        "loading_title": "در حال بارگذاری",
        "processing_title": "در حال پردازش",
        "support_tab": "پشتیبانی",
        "check_faq_label": "لطفاً ابتدا پرسش‌های متداول ما را بررسی کنید:",
        "faq_link_text": "برای مشاهده FAQ اینجا کلیک کنید",
        "sr_number_label": "شماره SR",
        "customer_name_label": "نام مشتری",
        "email_label": "ایمیل",
        "phone_label": "تلفن",
        "ticket_type_label": "نوع تیکت",
        "issue_description_label": "توضیحات مشکل",
        "video_name_label": "نام ویدئو",
        "creation_dt_label": "تاریخ/زمان ایجاد (تقریبی)",
        "desc_label": "توضیحات",
        "send_button": "ارسال تیکت",
        "sr_sent_title": "تیکت ارسال شد",
        "sr_sent_msg": "درخواست پشتیبانی شما با موفقیت ارسال شد!"
    }
}


def get_texts_for_current_language(combo_box=None, auto_translate=False):

    """
    combo_box: QComboBox, any QWidget in your UI, or a bare 2-letter str
    auto_translate: if True, will call translate_text() to fill gaps
    """
    # 1) DERIVE TWO-LETTER LANG CODE
    if isinstance(combo_box, str):
        # caller already passed "es", "ar", etc.
        lang = combo_box.lower()

    elif combo_box is None:
        # no selector → default to English
        lang = "en"

    else:
        # 1A) try direct API on whatever was passed in
        lang = None
        try:
            maybe = combo_box.currentData() or combo_box.currentText()
            lang = maybe
        except Exception:
            try:
                lang = combo_box.text()
            except Exception:
                lang = None

        # 1B) if that failed, climb widget parents and look for your language combo

        if not lang or not isinstance(lang, str):
            w = combo_box
            combo = None
            while w is not None:
                # adjust "languageCombo" to your actual objectName
                combo = w.findChild(QComboBox, "languageCombo")
                if combo:
                    break
                # move up
                w = w.parentWidget() if isinstance(w, QWidget) else None

            if combo:
                try:
                    lang = combo.currentData() or combo.currentText()
                except Exception:
                    lang = None

        # normalize
        lang = (lang or "en").lower()


    # 2) ENGLISH? immediate return

    if lang == "en":
        return DEFAULT_STRINGS

    # 3) HARDCODED DICT?
    if lang in HARDCODED_TRANSLATIONS:
        return HARDCODED_TRANSLATIONS[lang]

    # 4) AUTO-TRANSLATE ON DEMAND?

    if auto_translate:
        out = {}
        for key, default in DEFAULT_STRINGS.items():
            try:
                out[key] = translate_text(default, lang, "en")
            except Exception:
                out[key] = default
        return out

    # 5) FALLBACK → English
    return DEFAULT_STRINGS



class TooltipTranslator(QObject):
    def __init__(self, lang_combo):
        super().__init__()
        self.lang_combo = lang_combo

    def eventFilter(self, watched, event):
        if event.type() == QEvent.ToolTip:
            orig = watched.toolTip()
            # look up the English → key mapping
            key = REVERSE_DEFAULTS.get(orig)
            if not key:
                # no translation for this text? let Qt do its default thing
                return False

            # we *do* have a key, so swap in the translated string
            texts = get_texts_for_current_language(self.lang_combo)
            translated = texts.get(key, orig)
            QToolTip.showText(event.globalPos(), translated, watched)
            # we handled it
            return True

        return super().eventFilter(watched, event)



# from your_i18n_module import get_texts_for_current_language, DEFAULT_STRINGS

class UploadDialog(QDialog):
    def __init__(self,
                 default_description="",
                 default_tags=None,
                 default_privacy="private",
                 default_thumbnail="",
                 parent=None):
        super().__init__(parent)

        # 1) pull translations from the main window’s language selector
        combo = getattr(parent, "target_language_input", None)
        texts = get_texts_for_current_language(combo)

        # 2) remember last‐used thumbnail folder
        self.last_thumbnail_path = default_thumbnail or ""

        # 3) window title
        self.setWindowTitle(
            texts.get("upload_details_title",
                      DEFAULT_STRINGS["upload_details_title"])
        )

        # 4) form layout
        layout = QFormLayout(self)

        # — Description —
        self.description_edit = QPlainTextEdit(self)
        self.description_edit.setPlainText(default_description)
        layout.addRow(
            texts.get("description_label", "Description:"),
            self.description_edit
        )

        # — Tags —
        self.tags_edit = QLineEdit(self)
        self.tags_edit.setMaxLength(500)
        default_tags = default_tags or []
        self.tags_edit.setText(", ".join(default_tags))
        layout.addRow(
            texts.get("tags_label", "Tags (comma separated):"),
            self.tags_edit
        )

        # — Privacy —
        self.privacy_combo = QComboBox(self)
        self.privacy_combo.addItems(["private", "public"])
        idx = self.privacy_combo.findText(default_privacy)
        if idx != -1:
            self.privacy_combo.setCurrentIndex(idx)
        layout.addRow(
            texts.get("privacy_label", "Privacy:"),
            self.privacy_combo
        )

        # — Thumbnail + Browse button —
        self.thumbnail_edit = QLineEdit(self)
        self.thumbnail_edit.setText(default_thumbnail)
        browse_btn = QPushButton(
            texts.get("browse_button", "Browse"), self
        )
        browse_btn.clicked.connect(self.browse_thumbnail)

        thumb_hbox = QHBoxLayout()
        thumb_hbox.addWidget(self.thumbnail_edit)
        thumb_hbox.addWidget(browse_btn)
        layout.addRow(
            texts.get("thumbnail_label", "Thumbnail Image:"),
            thumb_hbox
        )

        # — Category —
        self.category_combo = QComboBox(self)
        #----------------------------
        # Add (visible text, category ID) pairs
        self.category_combo.addItem("Autos & Vehicles", 2)
        self.category_combo.addItem("Comedy", 23)
        self.category_combo.addItem("Education", 27)
        self.category_combo.addItem("Entertainment", 24)
        self.category_combo.addItem("Film & Animation", 1)
        self.category_combo.addItem("Gaming", 20)
        self.category_combo.addItem("Howto & Style", 26)
        self.category_combo.addItem("Music", 10)
        self.category_combo.addItem("News & Politics", 25)
        self.category_combo.addItem("Nonprofits & Activism", 29)
        self.category_combo.addItem("People & Blogs", 22)
        self.category_combo.addItem("Pets & Animals", 15)
        self.category_combo.addItem("Science & Technology", 28)
        self.category_combo.addItem("Sports", 17)
        self.category_combo.addItem("Travel & Events", 19)

        #layout.addRow("Category:", self.category_combo)

        layout.addRow(
            texts.get("category_label", "Category:"),
            self.category_combo
        )

        # Retrieve the integer category ID

        index = self.category_combo.currentIndex()
        category_id = self.category_combo.itemData(index)  # will be an int

        #-------------------------------
        # — Video Language —
        self.language_combo = QComboBox(self)
        self.language_combo.addItems(
            ["en", "es", "ar", "pt", "hi", "de", "zh", "jp", "fr", "ru", "ko", "tr", "ur", "fa"]
        )
        self.language_combo.setCurrentText("en")
        layout.addRow(
            texts.get("video_language_label", "Video Language:"),
            self.language_combo
        )

        # — Recording Date —
        self.recording_date_edit = QDateEdit(self)
        self.recording_date_edit.setCalendarPopup(True)
        self.recording_date_edit.setDate(QDate.currentDate())
        layout.addRow(
            texts.get("recording_date_label", "Recording Date:"),
            self.recording_date_edit
        )

        # — Switch YouTube Account —
        self.switch_account_checkbox = QCheckBox(
            texts.get("switch_account_label", "Switch YouTube Account"),
            self
        )
        self.switch_account_checkbox.setToolTip(
            texts.get("switch_account_tooltip",
                      DEFAULT_STRINGS["switch_account_tooltip"])
        )
        layout.addRow(
            texts.get("switch_account", DEFAULT_STRINGS["switch_account"]),
            self.switch_account_checkbox
        )

        # — OK / Cancel buttons —
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel, parent=self
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

        print("DEBUG: UploadDialog initialized successfully.")

    def browse_thumbnail(self):
        """
        Open a file dialog for images, remember last folder,
        and set thumbnail_edit.
        """
        combo = getattr(self.parent(), "target_language_input", None)
        texts = get_texts_for_current_language(combo)

        start_dir = (
            self.last_thumbnail_path
            or QStandardPaths.writableLocation(QStandardPaths.DesktopLocation)
        )

        file_path, _ = QFileDialog.getOpenFileName(
            self,
            texts.get("select_thumbnail",
                      DEFAULT_STRINGS["select_thumbnail"]),
            start_dir,
            texts.get("image_files_filter",
                      DEFAULT_STRINGS["image_files_filter"])
        )
        if not file_path:
            return

        # remember for next time
        self.last_thumbnail_path = file_path
        self.thumbnail_edit.setText(file_path)

    def getData(self):
        """
        Returns:
          (description: str,
           tags: [str],
           privacy: str,
           thumbnail: str,
           categoryId: str,
           language: str,
           recording_date: str,
           switch_account: bool)
        """
        import re

        description = self.description_edit.toPlainText().strip()
        tags = [
            t.strip()
            for t in self.tags_edit.text().split(",")
            if t.strip()
        ]
        privacy = self.privacy_combo.currentText()
        thumbnail = self.thumbnail_edit.text().strip()

        # Retrieve categoryId directly from the combo item's userData
        idx = self.category_combo.currentIndex()
        categoryId = str(self.category_combo.itemData(idx))  # Convert to string if needed

        language = self.language_combo.currentText()
        recording_date = self.recording_date_edit.date().toString("yyyy-MM-dd")
        switch_account = self.switch_account_checkbox.isChecked()

        print("DEBUG: UploadDialog.getData returning:")
        print("    description:", repr(description))
        print("    tags:", repr(tags))
        print("    privacy:", repr(privacy))
        print("    thumbnail:", repr(thumbnail))
        print("    categoryId:", repr(categoryId))
        print("    language:", repr(language))
        print("    recording date:", repr(recording_date))
        print("    switchAccount:", repr(switch_account))

        return (
            description,
            tags,
            privacy,
            thumbnail,
            categoryId,
            language,
            recording_date,
            switch_account
        )


def choose_social_media_platform(parent):

    #texts = get_texts_for_current_language(self.target_language_input)
    texts = get_texts_for_current_language(parent.target_language_input)
    # Define a list of platforms; you may add more later.
    platforms = ["YouTube", "Youtube_Shorts", "Instagram", "TikTok", "Facebook", "720p"]

    print("DEBUG: Presenting social media platform choices:", platforms)
    # Use QInputDialog.getItem to prompt the user with a drop-down
    item, ok = QInputDialog.getItem(
        parent,
        parent.tr(texts.get("select_platform_title", DEFAULT_STRINGS["select_platform_title"])),
        parent.tr(texts.get("select_platform_prompt", DEFAULT_STRINGS["select_platform_prompt"])),
        platforms,
        0,  # default index
        False  # not editable
    )
    "select_platform_prompt"
    print("DEBUG: User selected:", repr(item), "OK =", ok)
    if ok and item:
        return item  # or item.lower() if you want a specific format later
    else:
        return None


def get_output_filename(title, platform, output_dir, ext=".mp4"):
    """
    Create a filename such as "Singing Birds_youtube.mp4".
    """
    return os.path.join(output_dir, f"{title}_{platform}{ext}")


def ensure_platform_file(title, desired_platform, output_dir):
    """
    Look for the desired platform file.
    If it doesn't exist, try to copy it from an allowed alternative platform:
     - For "facebook", only copy from "youtube" (if it exists)
     - For "youtube", only copy from "facebook"
     - For "youtube_shorts", copy from "tiktok" or "instagram"
     - For "tiktok", copy from "youtube_shorts" or "instagram"
     - For "instagram", copy from "youtube_shorts" or "tiktok"
    Returns the file path (existing or newly copied) or None if not found.
    """
    # Build the desired filename.
    desired_file = get_output_filename(title, desired_platform, output_dir)
    if os.path.exists(desired_file):
        print(f"[INFO] {desired_platform} file already exists: {desired_file}")
        return desired_file

    # Get alternative platforms based on our rules. If no rule is set, use an empty list.
    allowed_alternatives = ALTERNATIVE_PLATFORMS.get(desired_platform, [])

    for alt_platform in allowed_alternatives:
        alt_file = get_output_filename(title, alt_platform, output_dir)
        if os.path.exists(alt_file):
            try:
                shutil.copy(alt_file, desired_file)
                print(f"[INFO] Copied {alt_platform} file to {desired_platform}: {desired_file}")
                return desired_file
            except Exception as e:
                print(f"[❌ ERROR] Could not copy file from {alt_platform} to {desired_platform}: {e}")
                # If copying fails, you might choose to continue to the next alternative.
                continue

    print(f"[INFO] No allowed alternative file found for {desired_platform}.")
    return None


def safe_str(obj) -> str:
    """
    Safely convert obj to str. If obj has a callable .text() method (e.g., a QLineEdit),
    call that and convert to str. Otherwise, just return str(obj).
    """
    if isinstance(obj, str):
        return obj
    if hasattr(obj, 'text') and callable(obj.text):
        return str(obj.text())
    return str(obj)

def archive_subdirs(base_dir: str,
                    video_filename: str,
                    subdirs=("OutFiles", "InVidFiles", "InMusicFiles")) -> None:
    """
    Inside base_dir create   <video_filename>.<timestamp>
    and move the listed sub-directories there.
    """

    if not base_dir or not os.path.isdir(base_dir):
        print(f"⚠️  archive_subdirs: '{base_dir}' is not a valid directory.")
        return

    # sanitise the name: keep letters, digits, '_', '-'
    safe_name = re.sub(r"[^A-Za-z0-9_\-]", "", os.path.splitext(video_filename)[0]) or "untitled"
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")

    dest_dir = os.path.join(base_dir, f"{safe_name}.{timestamp}")
    try:
        os.makedirs(dest_dir, exist_ok=False)
    except FileExistsError:
        # extremely unlikely but still possible – back-off with counter
        i = 1
        while True:
            alt = f"{dest_dir}_{i}"
            try:
                os.makedirs(alt, exist_ok=False)
                dest_dir = alt
                break
            except FileExistsError:
                i += 1

    for sub in subdirs:
        src = os.path.join(base_dir, sub)
        if os.path.exists(src):
            try:
                shutil.move(src, dest_dir)
                print(f"  ↪ moved {src}  →  {dest_dir}")
            except Exception as e:
                print(f"❌ could not move '{src}': {e}")
        else:
            print(f"  ⏩ skipped {src} (does not exist)")

    print(f"✅ Archiving complete.  Working dirs are now in\n   {dest_dir}")

class VideoCreatorGUI(QMainWindow):

    def __init__(self):
        super().__init__()
        self.texts = DEFAULT_STRINGS  # default
        self.last_output_path = ""
        self._player = QMediaPlayer()
        # make sure we clean up exactly once, even if other code also
        # connects to aboutToQuit – Qt will call all slots.
        QApplication.instance().aboutToQuit.connect(self.on_app_quit)
        self.uploading = False
        self.setWindowTitle("Video Creator")
        screen_rect = QApplication.primaryScreen().availableGeometry()

        # Calculate a size slightly smaller than the screen to ensure fit (e.g., 90% width and height)
        width = int(screen_rect.width() * 0.95)
        height = int(screen_rect.height() * 0.95)

        size = QSize(width, height)
        centered = QStyle.alignedRect(
            Qt.LeftToRight,
            Qt.AlignCenter,
            size,
            screen_rect
        )
        self.setGeometry(centered)

        self.resize(width, height)
        self.setMinimumWidth(int(width * 0.95))  # keep min width reasonable

        # Create a central tab widget.
        self.tabs = QTabWidget()

        bar = self.tabs.tabBar()
        bar.setElideMode(Qt.ElideNone)



        self.tabs.setStyleSheet("""
            /* ─── All tabs ────────────────────────────────────── */
            QTabBar::tab {
                background: #E0E0E0;
                color: #333;
                font-size: 11px;
                padding: 10px 16px;
                min-width: 145px;
                min-height: 12px;
                border: 1px solid #AAA;
                border-bottom: none;
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                margin-right: -1px;
                margin-bottom: 0px;
            }

            /* ─── Selected (active) tab ─────────────────────── */
            QTabBar::tab:selected {
                background: #5d8aa8;
                color: white;
                font-size: 11px;
                padding: 10px 16px;
                min-width: 145px;
                min-height: 12px;
                border: 1px solid #AAA;
                border-color: #4a739b;
                border-bottom: 2px solid #4a739b;
                margin-top: 0px;
            }

            /* ─── Unselected candidates ─────────────────────── */
            QTabBar::tab:!selected {
                margin-top: 2px;
            }

            /* ─── The content pane under the tabs ──────────── */
            QTabWidget::pane {
                border: 1px solid #AAA;
                top: -1px;
                padding: 12px;
            }
        """)

        # == Insert a top widget with a logo on the right ==
        self.top_widget = QWidget()
        top_layout = QHBoxLayout(self.top_widget)
        top_layout.setContentsMargins(0, 0, 0, 0)

        # (Optionally, something on the left or just a spacer)
        left_spacer = QLabel("")
        top_layout.addWidget(left_spacer)
        top_layout.addStretch(1)  # push the logo to the far right

        # Logo on the right
        self.logo_label = QLabel()
        pixmap = QPixmap(APP_LOGO)
        # Optionally scale the logo if needed:
        pixmap = pixmap.scaled(40, 40, Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.logo_label.setPixmap(pixmap)
        top_layout.addWidget(self.logo_label)

        #self.logo_label.setScaledContents(True)  # Let the label resize the image internally
        #self.logo_label.setFixedSize(120, 50)  # Force the QLabel to that size (or use setMaximumSize)

        # Now create a central widget that holds top_widget plus the tab widget.
        central_widget = QWidget(self)
        main_vlayout = QVBoxLayout(central_widget)
        main_vlayout.setContentsMargins(0, 0, 0, 0)
        # 1) Add the top widget (with the logo)
        main_vlayout.addWidget(self.top_widget)


        main_vlayout.addWidget(self.tabs)  # your QTabWidget
        # Finally, set the central_widget as the QMainWindow’s central widget
        self.setCentralWidget(central_widget)
        # SURGICAL FIX: Set the background color on the entire QMainWindow:
        self.setStyleSheet("QMainWindow { background-color: rgba(250,242,231,255); }")

        #self.setCentralWidget(self.tabs)
        self.status_text = QPlainTextEdit()
        self.status_text.setReadOnly(True)
        self.media_clips = []  # Initialize media_clips as an empty list
        #print("VideoCreatorGUI initialized with media_clips:", self.media_clips)

        # Add QLineEdit widgets for video & music folder references
        # so that calling .text() is valid in bypass mode
        #self.video_image_folder = QLineEdit(self)
        #self.music_folder = QLineEdit(self)

        # If you want them to start as empty strings, you can do so:
        #self.video_image_folder.setText("")
        #self.music_folder.setText("")

        # … inside your init/UI setup …

        # 1) Build your language list
        self.language_options = [
            {"label": "English    (Default)",   "code": "en", "flag": QIcon("flags/us.png")},
            {"label": "Arabic     العربية",     "code": "ar", "flag": QIcon("flags/sa.png")},
            {"label": "Spanish    Español",     "code": "es", "flag": QIcon("flags/es.png")},
            {"label": "Frensh     Français",    "code": "fr", "flag": QIcon("flags/fr.png")},
            {"label": "German     Deutsch",     "code": "de", "flag": QIcon("flags/de.png")},
            {"label": "Portuguese Português",   "code": "pt", "flag": QIcon("flags/pt.png")},
            {"label": "Russian    Русский",     "code": "ru", "flag": QIcon("flags/ru.png")},
            {"label": "Chinese    中文",         "code": "zh", "flag": QIcon("flags/cn.png")},
            {"label": "Japanese   日本語",       "code": "ja", "flag": QIcon("flags/jp.png")},
            {"label": "Hindi      हिन्दी",         "code": "hi", "flag": QIcon("flags/in.png")},
            {"label": "Korean     한국어",       "code": "ko", "flag": QIcon("flags/kr.png")},
            {"label": "Turkish    Türkçe",      "code": "tr", "flag": QIcon("flags/tr.png")},
            {"label": "Urdu       اردو",        "code": "ur", "flag": QIcon("flags/pk.png")},
            {"label": "Persian    فارسی",       "code": "fa", "flag": QIcon("flags/ir.png")}
        ]

        # 2) Create the combo box
        self.target_language_input = QComboBox()
        self.target_language_input.setIconSize(QSize(26, 26))
        self.target_language_input.setMaxVisibleItems(len(self.language_options))
        self.target_language_input.setFixedHeight(30)
        self.target_language_input.setStyleSheet(
            "QComboBox { font-size: 11px; padding: 1px 4px; }"
            "QComboBox QAbstractItemView { font-size: 11px; }"
        )

        # Populate the combo box
        self.target_language_input.clear()
        for lang in self.language_options:
            self.target_language_input.addItem(
                lang["flag"],
                lang["label"],
                userData=lang["code"]
            )

        # … continue adding your other widgets to self.main_layout …
        self._tt_translator = TooltipTranslator(self.target_language_input)
        QApplication.instance().installEventFilter(self._tt_translator)

        # -------------------- First Tab: Main Controls --------------------
        # Main tab.
        self.main_tab = QWidget()
        self.main_tab.setProperty("tabFunction", "main")
        self.tabs.addTab(self.main_tab, "Main")
        main_layout = QVBoxLayout()
        self.main_tab.setLayout(main_layout)

        language_layout = QHBoxLayout()
        self.target_language_label_widget = QLabel(DEFAULT_STRINGS["target_language_label"])


        language_layout.addWidget(self.target_language_label_widget)
        language_layout.addWidget(self.target_language_input)
        main_layout.addLayout(language_layout)

        # Get the language code from the combo box's userData instead of using self.target_languages.
        target_lang = self.target_language_input.currentData() or "en"

        # print(f"DEBUG: Inside Main tab. target_lang: {target_lang}")

        texts = get_texts_for_current_language(self.target_language_input)

        self.target_language_label_widget.setToolTip(
            texts.get("target_language_tooltip", DEFAULT_STRINGS["target_language_tooltip"]))
        # Voice selection row.
        voice_layout = QHBoxLayout()
        self.voice_label = QLabel(DEFAULT_STRINGS["voice_label"])
        self.video_title_label = QLabel(DEFAULT_STRINGS["video_title_label"])
        self.voice_selector = VoiceSelector()
        self.voice_input = self.voice_selector.voice_input
        voice_layout.addWidget(self.voice_label)
        voice_layout.addWidget(self.voice_input)
        self.test_voice_button = QPushButton(DEFAULT_STRINGS["test_voice_button"])
        self.test_voice_button.setStyleSheet(BTN_STYLE)

        self.test_voice_button.clicked.connect(self.voice_selector.test_selected_voice)
        voice_layout.addWidget(self.test_voice_button)
        main_layout.addLayout(voice_layout)


        # Video title input.
        self.video_title_label = QLabel(DEFAULT_STRINGS["video_title_label"])
        self.video_title_input = QLineEdit()
        main_layout.addWidget(self.video_title_label)
        main_layout.addWidget(self.video_title_input)

        # Default value for video_title
        self.video_title = "default_video"

        # Connect the textChanged signal to your new set_video_title method
        self.video_title_input.textChanged.connect(self.set_video_title)

        # Platform input.
        self.platform_label = QLabel(DEFAULT_STRINGS["platform_label"])
        self.platform_input = QComboBox()
        self.platform_input.addItems(["youtube", "youtube_shorts", "tiktok", "facebook", "instagram", "720p"])
        main_layout.addWidget(self.platform_label)
        main_layout.addWidget(self.platform_input)

        # Video script prompt input.
        prompt_container = QWidget()
        prompt_layout = QHBoxLayout(prompt_container)
        prompt_layout.setSpacing(3)
        prompt_layout.setContentsMargins(0, 0, 0, 0)
        prompt_layout.setSizeConstraint(QLayout.SetFixedSize)

        self.prompt_label = QLabel(DEFAULT_STRINGS["prompt_label"])
        prompt_layout.addWidget(self.prompt_label)
        prompt_info = QToolButton()
        prompt_info.setIcon(QApplication.style().standardIcon(QStyle.SP_MessageBoxInformation))
        prompt_info.setAutoRaise(True)
        #prompt_info.setToolTip(
        #    "Provide a comprehensive prompt describing the video content you wish to create.\n"
        #    "Include key topics, desired style, and all essential details to guide the video generation process.\n"
        #    "You may write the prompt in any language; the video will be produced in the language selected.\n"
        #    "The generated output will form a video script that you can review later."
        #)
        #global target_lang
        target_lang = self.target_language_input.currentData() or "en"

        #print(f"DEBUG: Inside Main tab. target_lang: {target_lang}")

        texts = get_texts_for_current_language(self.target_language_input)

        prompt_info.setToolTip(texts.get("prompt_tooltip", DEFAULT_STRINGS["prompt_tooltip"]))
        prompt_layout.addWidget(prompt_info)
        main_layout.addWidget(prompt_container)
        self.prompt_input = QPlainTextEdit()
        self.prompt_input.setFixedHeight(50)  # Adjust value as needed (e.g., 100 pixels)
        main_layout.addWidget(self.prompt_input)

        # Instrumental Genre selection.
        genre_layout = QHBoxLayout()
        self.genre_label = QLabel(DEFAULT_STRINGS["genre_label"])
        self.genre_input = QComboBox()
        self.genre_input.addItems(["Ambient", "Classical", "Electronic", "Folk", "Jazz", "Lo-fi",
                                   "New Age", "Post-Rock", "Soundtrack", "World Music"])
        default_genre = "Soundtrack"
        default_genre_index = self.genre_input.findText(default_genre)
        if default_genre_index >= 0:
            self.genre_input.setCurrentIndex(default_genre_index)
        genre_layout.addWidget(self.genre_label)
        genre_layout.addWidget(self.genre_input)
        main_layout.addLayout(genre_layout)

        # Modify Keywords container.
        modify_container = QWidget()
        modify_layout = QHBoxLayout(modify_container)
        modify_layout.setSpacing(3)
        modify_layout.setContentsMargins(0, 0, 0, 0)
        modify_layout.setSizeConstraint(QLayout.SetFixedSize)
        self.modify_label = QLabel(texts.get("modify_label", DEFAULT_STRINGS["modify_label"]))

        modify_layout.addWidget(self.modify_label)
        modify_info = QToolButton()
        modify_info.setIcon(QApplication.style().standardIcon(QStyle.SP_MessageBoxInformation))
        modify_info.setAutoRaise(True)
        modify_info.setToolTip(texts.get("modify_tooltip", DEFAULT_STRINGS["modify_tooltip"]))
        modify_layout.addWidget(modify_info)

        self.modify_yes = QRadioButton(texts.get("yes", DEFAULT_STRINGS["yes"]))
        self.modify_yes.setToolTip(texts.get("modify_yes_tooltip", DEFAULT_STRINGS["modify_yes_tooltip"]))
        self.modify_no = QRadioButton(texts.get("no", DEFAULT_STRINGS["no"]))
        self.modify_no.setToolTip(texts.get("modify_no_tooltip", DEFAULT_STRINGS["modify_no_tooltip"]))
        self.modify_yes.setChecked(True)
        self.modify_group = QButtonGroup()
        self.modify_group.addButton(self.modify_yes)
        self.modify_group.addButton(self.modify_no)

        modify_layout.addWidget(self.modify_yes)
        modify_layout.addWidget(self.modify_no)

        main_layout.addWidget(modify_container)

        # Bypass container.
        bypass_container = QWidget()
        bypass_layout = QHBoxLayout(bypass_container)
        bypass_layout.setSpacing(3)
        bypass_layout.setContentsMargins(0, 0, 0, 0)
        bypass_layout.setSizeConstraint(QLayout.SetFixedSize)

        self.bypass_label = QLabel(DEFAULT_STRINGS["bypass_label"])
        bypass_layout.addWidget(self.bypass_label)

        bypass_info = QToolButton()
        bypass_info.setIcon(QApplication.style().standardIcon(QStyle.SP_MessageBoxInformation))
        bypass_info.setAutoRaise(True)
        bypass_info.setToolTip(texts.get("bypass_tooltip", DEFAULT_STRINGS["bypass_tooltip"]))
        bypass_layout.addWidget(bypass_info)

        self.bypass_yes = QRadioButton(texts.get("yes", DEFAULT_STRINGS["yes"]))
        self.bypass_yes.setToolTip(texts.get("bypass_yes_tooltip", DEFAULT_STRINGS["bypass_yes_tooltip"]))
        self.bypass_no = QRadioButton(texts.get("no", DEFAULT_STRINGS["no"]))
        self.bypass_no.setToolTip(texts.get("bypass_no_tooltip", DEFAULT_STRINGS["bypass_no_tooltip"]))
        self.bypass_no.setChecked(True)
        self.bypass_group = QButtonGroup()
        self.bypass_group.addButton(self.bypass_yes)
        self.bypass_group.addButton(self.bypass_no)

        bypass_layout.addWidget(self.bypass_yes)
        bypass_layout.addWidget(self.bypass_no)

        main_layout.addWidget(bypass_container)

        # Directories Section
        self.directories_layout = QGridLayout()
        main_layout.addLayout(self.directories_layout)

        # Base Directory Row:
        self.base_directory_label = QLabel(DEFAULT_STRINGS["base_directory_label"])
        self.base_directory = QLineEdit()
        self.base_browse_button = QPushButton(DEFAULT_STRINGS["base_browse_btn"])
        self.base_browse_button.setStyleSheet(BTN_STYLE)
        self.base_browse_button.clicked.connect(self.browse_base_directory)
        # Place label in column 0, line edit in column 1, and Browse button in column 2.
        self.directories_layout.addWidget(self.base_directory_label, 0, 0)
        self.directories_layout.addWidget(self.base_directory, 0, 1)
        self.directories_layout.addWidget(self.base_browse_button, 0, 2)

        # Video Image Folder Row.
        self.video_image_folder_label = QLabel(DEFAULT_STRINGS["video_image_folder_label"])
        self.video_image_folder = QLineEdit()
        self.video_image_folder.setReadOnly(True)
        self.directories_layout.addWidget(self.video_image_folder_label, 1, 0)
        self.directories_layout.addWidget(self.video_image_folder, 1, 1)

        # Output Directory Row.
        self.output_directory_label = QLabel(DEFAULT_STRINGS["output_directory_label"])
        self.output_directory = QLineEdit()
        self.output_directory.setReadOnly(True)
        self.directories_layout.addWidget(self.output_directory_label, 2, 0)
        self.directories_layout.addWidget(self.output_directory, 2, 1)

        #self.output_directory_path = self.output_directory.text().strip()

        # Music Folder Row.
        self.music_folder_label = QLabel(DEFAULT_STRINGS["music_folder_label"])
        self.music_folder = QLineEdit()
        self.music_folder.setReadOnly(True)
        self.directories_layout.addWidget(self.music_folder_label, 3, 0)
        self.directories_layout.addWidget(self.music_folder, 3, 1)

        # Voiceover Directory Row.
        self.voiceover_directory_label = QLabel(DEFAULT_STRINGS["voiceover_directory_label"])
        self.voiceover_directory = QLineEdit()
        self.voiceover_directory.setReadOnly(True)
        self.directories_layout.addWidget(self.voiceover_directory_label, 4, 0)
        self.directories_layout.addWidget(self.voiceover_directory, 4, 1)

        self.base_directory.textChanged.connect(self.update_derived_directories)

        # Status Section.
        self.status_label = QLabel(DEFAULT_STRINGS["status_label"])
        main_layout.addWidget(self.status_label)
        self.status_text = QPlainTextEdit()
        self.status_text.setReadOnly(True)
        self.status_text.setFixedHeight(30)  # Adjust value as needed (e.g., 100 pixels)
        main_layout.addWidget(self.status_text)

        # Start and Play buttons.
        self.start_button = QPushButton(DEFAULT_STRINGS["start_video_btn"])
        self.start_button.setStyleSheet(BTN_STYLE)
        self.start_button.clicked.connect(self.start_video_creation)
        main_layout.addWidget(self.start_button)
        #------------------------------------
        # Removed Play Video button from Main
        #
        # ===================== Second Tab: Review / Edit Script =====================

        # Subtitles tab.
        self.subtitles_tab = QWidget()
        self.subtitles_tab.setProperty("tabFunction", "script")
        self.tabs.addTab(self.subtitles_tab, "Review or Edit Script")
        self.subtitles_layout = QVBoxLayout()
        self.subtitles_tab.setLayout(self.subtitles_layout)
        self.subtitles_editor = QTextEdit()
        self.subtitles_layout.addWidget(self.subtitles_editor)
        self.save_button = QPushButton(DEFAULT_STRINGS["save_subtitles_btn"])
        self.save_button.setStyleSheet(BTN_LF_STYLE)
        self.save_button.clicked.connect(self.save_and_regenerate)
        self.subtitles_layout.addWidget(self.save_button)
        self.tabs.currentChanged.connect(self.on_tab_changed)

        # ===================== Third Tab: Review / Edit Clips & Subtitles =====================
        # Clips and subtitles tab.
        self.clip_sub_tab = QWidget()
        self.clip_sub_tab.setProperty("tabFunction", "clips")
        self.tabs.addTab(self.clip_sub_tab, "Review or Edit Clips and Subtitles")
        clip_sub_layout = QVBoxLayout()
        self.clip_sub_tab.setLayout(clip_sub_layout)

        # Initialize the clip table using our custom MediaTableReorder.
        # This table now lets you drag from column 0 (Select) and only reorders columns 0–6.
        # Initialize the clip table
        self.clip_table = MediaTableReorder(self)
        self.clip_table.setColumnCount(16)

        # Use the imported texts
        headers = texts.get("clip_table_headers", DEFAULT_STRINGS["clip_table_headers"])

        self.clip_table.setHorizontalHeaderLabels(headers)
        self.clip_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.clip_table.setEditTriggers(QAbstractItemView.DoubleClicked | QAbstractItemView.SelectedClicked)
        clip_sub_layout.addWidget(self.clip_table)

        # Control layout for buttons
        clip_control_layout = QHBoxLayout()
        self.replace_clip_btn = QPushButton(DEFAULT_STRINGS["replace_clip_btn"])
        self.replace_clip_btn.setStyleSheet(BTN_LF_STYLE)
        self.delete_clip_btn = QPushButton(DEFAULT_STRINGS["delete_clip_btn"])
        self.delete_clip_btn.setStyleSheet(BTN_LF_STYLE)
        clip_control_layout.addWidget(self.replace_clip_btn)
        clip_control_layout.addWidget(self.delete_clip_btn)
        clip_sub_layout.addLayout(clip_control_layout)

        # Connect button actions
        self.replace_clip_btn.clicked.connect(self.replace_selected_clip)
        self.delete_clip_btn.clicked.connect(self.delete_selected_items)

        # Final video generation button
        self.generate_final_video_btn = QPushButton(DEFAULT_STRINGS["generate_final_video_btn"])
        self.generate_final_video_btn.setStyleSheet(BTN_LF_STYLE)
        clip_sub_layout.addWidget(self.generate_final_video_btn)

        # ------------------Fourth Tab: Create Final Video ------------------------------
        texts = get_texts_for_current_language(self.target_language_input)
        self.final_video_tab = QWidget()
        self.final_video_tab.setProperty("tabFunction", "final_video")
        #self.tabs.addTab(self.final_video_tab, DEFAULT_STRINGS.get("final_video_tab", "Final Video"))
        self.tabs.addTab(self.final_video_tab,texts.get("final_video_tab", DEFAULT_STRINGS["final_video_tab"]))
        final_layout = QVBoxLayout(self.final_video_tab)

        # Create a QStackedWidget to hold the VLC widget and the preview label
        self.video_stack = QStackedWidget(self.final_video_tab)
        self.video_stack.setMinimumSize(800, 450)  # adjust as needed
        final_layout.addWidget(self.video_stack)

        # Create the VLC-based embedded player widget
        self.vlcWidget = VLCVideoWidget(self.video_stack)
        self.vlcWidget.setMinimumSize(800, 450)  # adjust as needed
        self.video_stack.addWidget(self.vlcWidget)

        # Create the QLabel for video preview
        self.video_preview_label = QLabel(self.video_stack)
        self.video_preview_label.setMinimumSize(800, 450)  # Match the size of the VLC widget
        self.video_preview_label.setAlignment(Qt.AlignCenter)
        self.video_preview_label.setText("Video Preview")  # Placeholder text
        self.video_preview_label.setStyleSheet("background-color: rgba(0, 0, 0, 0.5);")  # Semi-transparent background
        self.video_preview_label.setVisible(False)  # Initially hidden
        self.video_stack.addWidget(self.video_preview_label)

        # Create a control panel for video controls
        self.control_panel = QHBoxLayout()


        # Play Button
        #self.play_button = QPushButton("Play")
        self.play_button = QPushButton(texts.get("play_button", DEFAULT_STRINGS["play_button"]))

        self.play_button.clicked.connect(self.playVideoVLC)
        self.control_panel.addWidget(self.play_button)

        # Pause Button
        #self.pause_button = QPushButton("Pause")
        self.pause_button = QPushButton(texts.get("pause_button", DEFAULT_STRINGS["pause_button"]))

        self.pause_button.clicked.connect(self.pauseVideo)
        self.control_panel.addWidget(self.pause_button)

        # Forward Button
        #self.forward_button = QPushButton("Forward (+10 s)")
        self.forward_button = QPushButton(texts.get("forward_button", DEFAULT_STRINGS["forward_button"]))

        self.forward_button.clicked.connect(self.forwardVideo)
        self.control_panel.addWidget(self.forward_button)

        # Backward Button
        #self.backward_button = QPushButton("Backward (-10 s)")
        self.backward_button = QPushButton(texts.get("backward_button", DEFAULT_STRINGS["backward_button"]))

        self.backward_button.clicked.connect(self.backwardVideo)
        self.control_panel.addWidget(self.backward_button)

        # Add the control panel to the final layout
        final_layout.addLayout(self.control_panel)

        # Now add the Play Video button.
        self.play_video_btn_final = QPushButton(DEFAULT_STRINGS.get("play_video_btn_final", "Play Video"))
        self.play_video_btn_final.setStyleSheet(BTN_LF_STYLE)
        final_layout.addWidget(self.play_video_btn_final)

        # Connect the button to our new VLC-based playback method:
        self.play_video_btn_final.clicked.connect(self.playVideoVLC)

        # Optionally, add an upload widget/button to support social media integration.
        self.upload_video_btn = QPushButton(DEFAULT_STRINGS.get("upload_video_btn", "Upload to Social Media"))
        self.upload_video_btn.setStyleSheet(BTN_LF_STYLE)
        final_layout.addWidget(self.upload_video_btn)
        self.upload_video_btn.clicked.connect(self.on_upload_video)

        if hasattr(self, "generate_final_video_btn"):
            self.generate_final_video_btn.clicked.connect(self.on_generate_final_video)

        # ---------------------------------------------------------------------------
        # Fifth Tab: Support / SR Ticket Creation
        # ---------------------------------------------------------------------------
            # ===================== Fifth Tab: Support =====================
            self.support_tab = QWidget()
            self.support_tab.setProperty("tabFunction", "support")
            # Temporarily set tab text. We'll localize in update_translated_texts
            self.tabs.addTab(self.support_tab, DEFAULT_STRINGS["support_tab"])
            support_layout = QVBoxLayout(self.support_tab)

            # Check FAQ label & link as instance attrs, so we can update them in update_translated_texts
            self.check_faq_label = QLabel(DEFAULT_STRINGS["check_faq_label"])
            support_layout.addWidget(self.check_faq_label)

            self.faq_link_label = QLabel(
                f'<a href="{FAQ_LINK}" style="color:blue;">{DEFAULT_STRINGS["faq_link_text"]}</a>'
            )
            self.faq_link_label.setOpenExternalLinks(True)
            support_layout.addWidget(self.faq_link_label)

            # SR form
            form_widget = QWidget()
            form_layout = QFormLayout(form_widget)
            support_layout.addWidget(form_widget)

            self.sr_number_label = QLabel(DEFAULT_STRINGS["sr_number_label"])
            self.sr_number_value = QLabel("")
            form_layout.addRow(self.sr_number_label, self.sr_number_value)

            self.customer_name_label = QLabel(DEFAULT_STRINGS["customer_name_label"] + " *")
            self.customer_name_input = QLineEdit()
            form_layout.addRow(self.customer_name_label, self.customer_name_input)

            self.email_label = QLabel(DEFAULT_STRINGS["email_label"] + " *")
            self.email_input = QLineEdit()
            form_layout.addRow(self.email_label, self.email_input)

            self.phone_label = QLabel(DEFAULT_STRINGS["phone_label"])
            self.phone_input = QLineEdit()
            form_layout.addRow(self.phone_label, self.phone_input)

            self.ticket_type_label = QLabel(DEFAULT_STRINGS["ticket_type_label"] + " *")
            self.ticket_type_combo = QComboBox()
            #self.ticket_type_combo.addItems(["Issue", "Enhancement", "Comment"])
            form_layout.addRow(self.ticket_type_label, self.ticket_type_combo)

            self.issue_description_label = QLabel(DEFAULT_STRINGS["issue_description_label"] + " *")
            self.issue_description_input = QPlainTextEdit()
            form_layout.addRow(self.issue_description_label, self.issue_description_input)

            self.video_name_label = QLabel(DEFAULT_STRINGS["video_name_label"] + " *")
            self.video_name_input = QLineEdit()
            form_layout.addRow(self.video_name_label, self.video_name_input)

            self.creation_dt_label = QLabel(DEFAULT_STRINGS["creation_dt_label"] + " *")
            # self.creation_dt_input = QLineEdit()
            self.creation_dt_input = QDateTimeEdit()
            # *** Set the desired display format ***
            # MM: Month (01-12)
            # dd: Day (01-31)
            # yy: Year (00-99)
            # HH: Hour (00-23) - Use hh for 01-12 with AP for AM/PM
            # mm: Minute (00-59)
            # zzz: Timezone name (e.g., "EDT", "PST"). Note: This depends on system locale and can be inconsistent.
            # Alternatively, use 'z' for timezone offset (e.g., "+0500")
            # Or simply state "(System Timezone)" as a static part if 'zzz' is unreliable.
            # Let's use 'zzz' as it's closest to your request, but be aware of its behavior.
            #  "AP" = AM/PM in uppercase

            format_string = "MM-dd-yy @ hh:mm AP"

            self.creation_dt_input.setDisplayFormat(format_string)

            # *** Optional: Set an initial value (e.g., current date/time) ***
            self.creation_dt_input.setDateTime(QDateTime.currentDateTime())

            # You can also set minimum/maximum dates if needed
            self.creation_dt_input.setMinimumDateTime(QDateTime(2023, 1, 1, 0, 0))
            self.creation_dt_input.setMaximumDateTime(QDateTime.currentDateTime().addYears(1))

            form_layout.addRow(self.creation_dt_label, self.creation_dt_input)

            self.desc_label = QLabel(DEFAULT_STRINGS["desc_label"] + " *")
            self.desc_input = QPlainTextEdit()
            form_layout.addRow(self.desc_label, self.desc_input)

            self.ticket_type_combo.currentIndexChanged.connect(self.on_ticket_type_changed)

            self.on_ticket_type_changed()  # Hide or show fields initially

            self.send_button = QPushButton(DEFAULT_STRINGS["send_button"])
            self.send_button.setStyleSheet(BTN_LF_STYLE)
            form_layout.addRow(self.send_button)
            self.send_button.clicked.connect(self.on_send_support_ticket)

            # Connect language changes
            self.target_language_input.currentIndexChanged.connect(self.update_translated_texts)

            # Final translations
            self.update_translated_texts()

    #--------------------------------------------------------------------------------
    # METHOD: generate_sr_number
    #--------------------------------------------------------------------------------

    def generate_sr_number(self, sr_type: str) -> str:
        """
        Generate system SR numbers and auto-persist the counters.
        """
        global issue_counter, enh_counter, com_counter

        sr_type = sr_type.lower() if sr_type else "issue"

        if sr_type == "issue":
            sr_id = f"ISS-{issue_counter:07d}"
            issue_counter += 1
        elif sr_type == "enhancement":
            sr_id = f"ENH-{enh_counter:07d}"
            enh_counter += 1
        else:  # treat everything else as 'comment'
            sr_id = f"COM-{com_counter:07d}"
            com_counter += 1

        # _save_counters()  # persist immediately (cheap: one tiny JSON)
        return sr_id

    #--------------------------------------------------------------------------------
    # METHOD: on_ticket_type_changed
    #--------------------------------------------------------------------------------

    def on_ticket_type_changed(self):
        global issue_counter, enh_counter, com_counter
        """
        Called when the user changes the Ticket Type combo.
        Retrieves the userData (issue/enhancement/comment),
        generates a new SR number, and shows/hides relevant fields.
        """
        # Retrieve the behind-the-scenes type
        sr_type = self.ticket_type_combo.currentData()  # "issue", "enhancement", or "comment"

        # Generate new SR ID
        sr_num = self.generate_sr_number(sr_type)
        self.sr_number_value.setText(sr_num)

        if sr_type == "issue":
            issue_counter -= 1
            # Show issue-only fields
            self.issue_description_label.show()
            self.issue_description_input.show()
            self.video_name_label.show()
            self.video_name_input.show()
            self.creation_dt_label.show()
            self.creation_dt_input.show()

            # Hide enhancement/comment fields
            self.desc_label.hide()
            self.desc_input.hide()
        else:
            if sr_type == "enhancement":
                enh_counter -= 1
            else:
                com_counter -= 1
            # For enhancement or comment, hide the issue fields
            self.issue_description_label.hide()
            self.issue_description_input.hide()
            self.video_name_label.hide()
            self.video_name_input.hide()
            self.creation_dt_label.hide()
            self.creation_dt_input.hide()

            # Show the generic description field
            self.desc_label.show()
            self.desc_input.show()

    #--------------------------------------------------------------------------------
    # METHOD: on_send_support_ticket
    #--------------------------------------------------------------------------------

    def send_email(self, ticket_details):
        print("DEBUG: Inside send_email")
        msg = MIMEMultipart()
        msg['From'] = FROM_EMAIL
        msg['To'] = SUPPORT_EMAIL
        msg['Cc'] = ticket_details.get("customer_email", "")
        msg['Subject'] = f"Support Ticket {ticket_details.get('sr_num')} - {ticket_details.get('sr_type').title()}"

        print(f"DEBUG: after msg: {msg}")
        body_lines = [
            f"Ticket Number: {ticket_details.get('sr_num')}",
            f"Type: {ticket_details.get('sr_type')}",
            f"Customer Name: {ticket_details.get('customer_name')}",
            f"Customer Email: {ticket_details.get('customer_email')}"
        ]
        print(f"DEBUG: after body_lines: {body_lines}")

        description_key = 'issue_description' if ticket_details.get('sr_type') == "issue" else 'desc'
        description = ticket_details.get(description_key, '')

        # Detect language and translate if not English
        try:
            detected_lang = detect(description)
            print(f"DEBUG: Detected language: {detected_lang}")
            if detected_lang != 'en':
                prompt = f"Translate the following text to English and specify the original language:\n\n\"{description}\""
                translation = generate_text_chatgpt(prompt)
                print(f"DEBUG: Translation result: {translation}")
                description += f"\n\n[Translated from {detected_lang.upper()}]:\n{translation}"
        except Exception as e:
            print(f"DEBUG: Language detection or translation failed: {e}")

        if ticket_details.get('sr_type') == "issue":
            body_lines.append(f"Issue Description: {description}")
            body_lines.append(f"Video Name: {ticket_details.get('video_name')}")
            body_lines.append(f"Creation Date/Time: {ticket_details.get('creation_dt')}")
        else:
            body_lines.append(f"Description: {description}")

        print("DEBUG: after ticket_details")
        body = "\n".join(body_lines)
        print(f"DEBUG: body: {body}")
        msg.attach(MIMEText(body, 'plain'))

        recipients = [SUPPORT_EMAIL]
        cc_email = ticket_details.get("customer_email")
        print(f"DEBUG: recipients: {recipients}, cc_email: {cc_email}")
        if cc_email:
            recipients.append(cc_email)

        try:
            print(f"DEBUG: before smtplib.SMTP call. SMTP_SERVER:{SMTP_SERVER}, SMTP_PORT:{SMTP_PORT}")
            server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
            print(f"DEBUG: server={server}")
            server.starttls()
            print(f"DEBUG: after server.starttls(): form email: {FROM_EMAIL}, Email password: {EMAIL_PASSWORD}")
            server.login(FROM_EMAIL, EMAIL_PASSWORD)
            print(f"DEBUG: after server.login, before sendmail. recipients: {recipients}, Msg: {msg.as_string()}")
            server.sendmail(FROM_EMAIL, recipients, msg.as_string())
            print("DEBUG: after sendmail, before server.quit()")
            server.quit()
            return True
        except Exception as e:
            print("Failed to send email:", e)
            traceback.print_exc()
            return False

    # In your existing on_send_support_ticket method, call the send_email function:

    def on_send_support_ticket(self):
        """
        Validate fields and send the ticket via email.
        Uses userData to identify which type was chosen.
        """
        # Retrieve the displayed and actual selected type
        displayed_text = self.ticket_type_combo.currentText()
        sr_type = self.ticket_type_combo.currentData()  # "issue", "enhancement", or "comment"
        #sr_num = self.sr_number_value.text().strip()
        sr_num = self.generate_sr_number(sr_type)

        # Get translations for potential messages
        texts = get_texts_for_current_language(self.target_language_input)
        missing_required_title = texts.get("missing_required_title", "Missing Required Fields")
        missing_required_msg = texts.get("missing_required_msg", "Please fill all required fields:\n")

        # Check required fields
        required_errors = []

        if not self.customer_name_input.text().strip():
            required_errors.append(self.customer_name_label.text())
        if not self.email_input.text().strip():
            required_errors.append(self.email_label.text())

        if sr_type == "issue":
            if not self.issue_description_input.toPlainText().strip():
                required_errors.append(self.issue_description_label.text())
            if not self.video_name_input.text().strip():
                required_errors.append(self.video_name_label.text())

            # *** Validation for QDateTimeEdit ***
            # Check if the displayed text is empty (unlikely if initialized, but safe)
            # Or check if the selected QDateTime is valid (QDateTimeEdit usually keeps it valid)
            if not self.creation_dt_input.dateTime().isValid():
                # This check is more robust if there were ways to make it invalid
                required_errors.append(self.creation_dt_label.text())
            elif not self.creation_dt_input.text().strip():
                # This check works if you haven't initialized it or allow clearing
                required_errors.append(self.creation_dt_label.text())
            # If you initialize it and it can't be cleared, the check might not be needed.
            # Let's keep the text().strip() check as it aligns with your original code's style,
            # but understand that with QDateTimeEdit, it's less likely to fail if initialized.
            if not self.creation_dt_input.text().strip():
                required_errors.append(self.creation_dt_label.text())
        else:
            if not self.desc_input.toPlainText().strip():
                required_errors.append(self.desc_label.text())

        # If missing required fields, warn the user
        if required_errors:
            QMessageBox.warning(
                self,
                missing_required_title,
                missing_required_msg + "\n".join(required_errors)
            )
            return  # <-- FIXED: previously this return was incorrectly indented

        # Gather information for the email
        customer_email = self.email_input.text().strip()
        ticket_details = {
            "sr_num": sr_num,
            "sr_type": sr_type,
            "customer_name": self.customer_name_input.text().strip(),
            "customer_email": customer_email,
        }

        if sr_type == "issue":
            ticket_details["issue_description"] = self.issue_description_input.toPlainText().strip()
            ticket_details["video_name"] = self.video_name_input.text().strip()
            ticket_details["creation_dt"] = self.creation_dt_input.text().strip()
        else:
            ticket_details["desc"] = self.desc_input.toPlainText().strip()

        # sending logic using the implemented send_email function
        print(f"Sending SR: {sr_num} of type={sr_type} to {SUPPORT_EMAIL}, CC={customer_email}")
        if self.send_email(ticket_details):  # Make sure send_email is a method on `self`
            sr_sent_title = texts.get("sr_sent_title", DEFAULT_STRINGS["sr_sent_title"])
            sr_sent_msg = texts.get("sr_sent_msg", DEFAULT_STRINGS["sr_sent_msg"])
            _save_counters()
            QMessageBox.information(self, sr_sent_title, sr_sent_msg)
        else:
            QMessageBox.critical(self, "Error", "Failed to send the support ticket. Please try again later.")

    def set_video_title(self, text):
        self.video_title = text.strip()  # Remove leading/trailing whitespace

    def refresh_texts(self):
        # optional: if you want to keep a self.texts cache for create_video()
        self.texts = get_texts_for_current_language(self.target_language_input)

    def update_media_order(self, new_media_order):
        """
        Update the underlying media clip ordering based on new_media_order.
        new_media_order is a list of media file paths read from the table.
        """
        if new_media_order:
            self.media_clips = new_media_order
            print("DEBUG: Updated media clip order:", self.media_clips)

    def recalcMediaTimings(self):
        """
        Recalculate the cumulative timing for media clips.
        For each row (assumed to correspond to a media clip), update the
        "Start Time" (column 2) and "End Time" (column 3) cells.
        Videos use get_video_duration(media_path); images default to 5 seconds.
        """
        cumulative = 0.0
        row_count = self.clip_table.rowCount()
        for row in range(row_count):
            # Retrieve media file from column 0 UserRole.
            item = self.clip_table.item(row, 0)
            if item is None:
                continue
            media_path = item.data(Qt.UserRole)
            if media_path:
                # Check file extension for duration.
                if media_path.lower().endswith((".mp4", ".avi", ".mov", ".mkv")):
                    try:
                        duration = get_video_duration(media_path)
                    except Exception as e:
                        print(f"❌ Error getting duration for {media_path}: {e}")
                        duration = 0.0
                else:
                    duration = 5.0  # default duration for images
                start_time = cumulative
                cumulative += duration
                end_time = cumulative
                startItem = QTableWidgetItem(format_seconds(start_time))
                startItem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 2, startItem)
                endItem = QTableWidgetItem(format_seconds(end_time))
                endItem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 3, endItem)

    # Method to update the video preview image
    def update_video_preview(self):
        video_title = self.video_title_input.text().strip()
        platform = self.platform_input.currentText().strip()
        out_dir = self.output_directory_path
        final_video_file = os.path.normpath(os.path.join(out_dir, f"{video_title}_{platform}.mp4"))

        # Load a thumbnail or still image from the final video
        if os.path.exists(final_video_file):
            # Here you can use a method to extract a frame or use a static image
            thumbnail = self.get_video_thumbnail(final_video_file)  # Assuming this method exists
            if thumbnail and not thumbnail.isNull():
                # Scale the thumbnail to fit the entire preview area
                self.video_preview_label.setPixmap(
                    thumbnail.scaled(self.video_preview_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation))
                self.video_preview_label.setVisible(True)  # Show the preview label
                self.video_stack.setCurrentWidget(self.video_preview_label)  # Show the preview label
            else:
                self.video_preview_label.setText("No preview available.")
                self.video_preview_label.setVisible(True)  # Show the preview label
                self.video_stack.setCurrentWidget(self.video_preview_label)  # Show the preview label
        else:
            self.video_preview_label.setText("Final video not found.")
            self.video_preview_label.setVisible(True)  # Show the preview label
            self.video_stack.setCurrentWidget(self.video_preview_label)  # Show the preview label

    # Modify the playVideoVLC method to hide the preview label when playing the video
    def playVideoVLC(self):
        print("DEBUG: Inside playVideoVLC....")
        if hasattr(self, "uploading") and self.uploading:
            print("DEBUG: Upload in progress, skipping playback.")
            return
        video_title = self.video_title_input.text().strip()
        print(f"DEBUG: Video title: {video_title}")
        if not video_title:
            QMessageBox.warning(self, "⚠️ Warning", "Please enter a video title.")
            return
        platform = self.platform_input.currentText().strip()
        print(f"DEBUG: platform: {platform}")
        out_dir = self.output_directory_path  # use the updated global string
        print(f"DEBUG: out_dir: {out_dir}")
        final_video_file = os.path.normpath(os.path.join(out_dir, f"{video_title}_{platform}.mp4"))
        print(f"DEBUG: final_video_file: {final_video_file}")
        if not os.path.exists(final_video_file):
            QMessageBox.warning(self, "⚠️ Warning", f"Video file not found: {final_video_file}")
            return
        print("DEBUG: final_video_file Exist:", final_video_file)

        # Hide the preview label when playing the video
        self.video_preview_label.setVisible(False)
        self.video_stack.setCurrentWidget(self.vlcWidget)  # Switch to VLC widget

        try:
            print("Playing via VLC fallback:", final_video_file)
            self.vlcWidget.play(final_video_file)  # Ensure this method exists in your VLCVideoWidget
            print("DEBUG: After call to vlcWidget.play:", final_video_file)
        except Exception as e:
            print(f"❌ Error during playback: {e}")
            QMessageBox.critical(self, "❌ Playback Error", f"❌ An error occurred while trying to play the video: {e}")

    def pauseVideo(self):
        print("DEBUG: Pausing video.")
        try:
            self.vlcWidget.pause()  # Call the pause method on the VLCVideoWidget
        except Exception as e:
            print(f"❌ Error during pause: {e}")
            QMessageBox.critical(self, "❌ Pause Error", f"❌ An error occurred while trying to pause the video: {e}")

    def forwardVideo(self):
        print("DEBUG: Forwarding video.")
        try:
            current_position = self.vlcWidget.get_time()  # Get current position in milliseconds
            self.vlcWidget.set_time(current_position + 10000)  # Forward 10 seconds
        except Exception as e:
            print(f"❌ Error during forward: {e}")
            QMessageBox.critical(self, "❌ Forward Error", f"❌ An error occurred while trying to forward the video: {e}")

    def backwardVideo(self):
        print("DEBUG: Backwarding video.")
        try:
            current_position = self.vlcWidget.get_time()  # Get current position in milliseconds
            self.vlcWidget.set_time(current_position - 10000)  # Backward 10 seconds
        except Exception as e:
            print(f"❌ Error during backward: {e}")
            QMessageBox.critical(self, "❌ Backward Error",
                                 f"❌ An error occurred while trying to backward the video: {e}")

    def playVideoEmbedded(self):
        print("DEBUG: Inside playVideoEmbedded")
        video_title = self.video_title_input.text().strip()
        print(f"DEBUG: video_title: {video_title}")
        if not video_title:
            QMessageBox.warning(self, "⚠️ Warning", "Please enter a video title.")
            return

        platform = self.platform_input.currentText().strip()
        print(f"DEBUG: platform: {platform}")

        # Use the global (instance) string variable instead of the widget.
        try:
            print("DEBUG: Using output_directory_path:", self.output_directory_path)
            out_dir = self.output_directory_path  # already a stripped string.
            final_video_file = os.path.normpath(os.path.join(out_dir, f"{video_title}_{platform}.mp4"))
            print(f"DEBUG: final_video_file: {final_video_file}")
        except Exception as e:
            print("DEBUG: Exception constructing file path:", e)
            QMessageBox.critical(self, "❌ Error", f"❌ Error constructing file path: {e}")
            return

        if not os.path.exists(final_video_file):
            QMessageBox.warning(self, "⚠️ Warning", f"Video file not found: {final_video_file}")
            return

        # Construct the media object.
        media_url = QUrl.fromLocalFile(final_video_file)
        print(f"DEBUG: media_url: {media_url}")
        media = QMediaContent(media_url)
        print(f"DEBUG: media: {media}")

        # Prepare the player for playback.
        print("DEBUG: Preparing previewPlayer.")
        if not self.previewPlayer:
            print("DEBUG: ❌ ERROR: previewPlayer is not properly set up!")
            return
        self.previewPlayer.stop()
        self.previewPlayer.setMedia(QMediaContent())  # Clear any existing media.

        self.switchTab("final_video")  # Show the video widget
        QTimer.singleShot(1000, lambda: self._startEmbeddedPlayback(media, final_video_file))
        print("DEBUG: Playback scheduled via QTimer.singleShot.")

    def _startEmbeddedPlayback(self, media, final_video_file):
        try:
            self.previewPlayer.setMedia(media)
            self.previewPlayer.setVolume(50)

            # Ensure the video preview widget is visible and updated.
            self.videoPreviewWidget.show()
            self.videoPreviewWidget.raise_()
            self.videoPreviewWidget.update()

            self.previewPlayer.play()
            self.status_text.appendPlainText(f"Playing video: {final_video_file}")
            print("DEBUG: Playback started successfully.")
        except Exception as e:
            print("DEBUG: Exception in _startEmbeddedPlayback:", e)
            QMessageBox.critical(self, "❌ Error", f"❌ Playback error: {e}")

    def authenticate_youtube_user(self, switch_account=False):
        """Authenticate the user via OAuth2 and return valid credentials.
        If switch_account is True, any stored token is ignored (deleted) so the user can switch accounts."""
        import os, pickle
        from google.auth.transport.requests import Request
        from google_auth_oauthlib.flow import InstalledAppFlow

        token_file = "token_youtube.pickle"
        creds = None
        print("DEBUG: Starting YouTube authentication; token file:", token_file)

        # If switching account, remove existing token file.
        if switch_account and os.path.exists(token_file):
            try:
                os.remove(token_file)
                print("DEBUG: switch_account enabled; removed existing token file.")
            except Exception as e:
                print("⚠️ WARNING: Could not remove token file for switch_account:", e)

        try:
            if os.path.exists(token_file):
                print("DEBUG: Token file found. Loading credentials from file.")
                with open(token_file, "rb") as token:
                    creds = pickle.load(token)
            else:
                print("DEBUG: Token file NOT found.")
            if not creds or not creds.valid:
                if creds and creds.expired and creds.refresh_token:
                    try:
                        print("DEBUG: Credentials expired. Refreshing credentials.")
                        creds.refresh(Request())
                    except Exception as e:
                        print("DEBUG: Token refresh failed:", e)
                        try:
                            os.remove(token_file)
                            print("DEBUG: Removed invalid token file.")
                        except Exception as del_err:
                            print("⚠️ WARNING: Could not delete token file:", del_err)
                        creds = None
                if not creds:
                    print("DEBUG: No valid credentials available; starting OAuth2 flow.")
                    flow = InstalledAppFlow.from_client_secrets_file(CLIENT_SECRETS_FILE, YOUTUBE_SCOPES)
                    creds = flow.run_local_server(port=8080)
                with open(token_file, "wb") as token:
                    pickle.dump(creds, token)
                    print("DEBUG: Credentials saved to token file.")
        except Exception as e:
            print("❌ Error during YouTube authentication:", e)
            raise
        print("DEBUG: YouTube authentication finished. creds type:", type(creds))
        return creds


    def upload_video_to_platform(self, final_video_file, platform):
        platform = platform.lower()
        print("DEBUG: In upload_video_to_platform. Platform:", platform)
        if platform in ["youtube", "youtube_shorts"]:
            # Get default upload details from GUI.
            default_description = ""
            if hasattr(self, "script_editor"):
                default_description = self.script_editor.toPlainText()
            default_tags = ["Video", "Upload"]
            if hasattr(self, "modified_keywords"):
                default_tags = self.modified_keywords

            print("DEBUG: Parent for UploadDialog is:", type(self))
            print("DEBUG: Launching UploadDialog with default_description:", repr(default_description),
                  "default_tags:", repr(default_tags))

            try:
                if platform.lower() in ["youtube_shorts"]:
                    note = ("NOTE: YouTube Shorts are intended for videos of 60 seconds or less. "
                            "Please ensure that your video meets the length requirement for YouTube Shorts.")
                    #QMessageBox.information(self, self.tr("YouTube Shorts Reminder"), self.tr(note))
                    QMessageBox.information(
                        self,
                        self.youtube_shorts_reminder_title,
                        self.youtube_shorts_reminder_msg
                    )
                # For testing, pass parent=None to avoid potential parenting issues.
                dialog = UploadDialog(default_description=default_description,
                                      default_tags=default_tags,
                                      default_privacy="private",
                                      parent=None)
                print("DEBUG: UploadDialog instance created successfully.")
            except Exception as e:
                print("❌ ERROR: Exception while creating UploadDialog:", e)
                return False

            try:
                result = dialog.exec_()
                print("DEBUG: UploadDialog exec_() result:", result)
            except Exception as e:
                print("❌ ERROR: Exception while executing UploadDialog:", e)
                return False

            if result == QDialog.Accepted:
                # Fully unpack all returned values.
                (description, tags, privacyStatus, thumbnail, categoryId,
                 language, recording_date, switch_account) = dialog.getData()
                print("DEBUG: Details received from UploadDialog:")
                print("    description:", repr(description))
                print("    tags:", repr(tags))
                print("    privacyStatus:", repr(privacyStatus))
                print("    categoryId:", repr(categoryId))
                print("    language:", repr(language))
                print("    recording_date:", repr(recording_date))
                print("    switch_account:", repr(switch_account))

                # Ensure YouTube description is no more than 4500 characters.
                max_length = 5000
                if len(description) > max_length:
                    print(f"WARNING: Description is {len(description)} chars, exceeding {max_length}, truncating.")
                    description = description[:max_length]

                # Pass all required parameters to upload_to_youtube.
                return self.upload_to_youtube(
                    final_video_file,
                    self.video_title_input.text().strip(),
                    description,
                    tags,
                    privacyStatus,
                    categoryId,
                    language,
                    recording_date,
                    switch_account
                )
            else:
                print("DEBUG: UploadDialog was cancelled by user.")
                return False

        elif platform.lower() in ["facebook", "instagram", "tiktok", "720p"]:
            normalized_path = final_video_file.replace("/", "\\")
            #QMessageBox.information(
            #    self,
            #    self.tr("Coming Soon"),
            #    self.tr(
            #        "The integration for {} is coming soon.\n\nPlease manually upload the final video.\nVideo path: {}"
            #    ).format(platform.capitalize(), normalized_path)
            #)
            QMessageBox.information(
                self,
                self.coming_soon_title,
                self.coming_soon_msg.format(platform.capitalize(),
                                            final_path.replace("/", "\\"))
            )
            self.uploading = False
            return
        else:
            print("Manual Upload:", platform)
            return False

    # Definition of upload_to_youtube (for reference):
    def upload_to_youtube(self, final_video_file, title, description, tags, privacyStatus,
                          categoryId, language, recording_date, switch_account=False):
        """
        Upload video to YouTube using the user’s credentials.
        Extended to include extra fields such as Category, Video Language, and Recording Date.
        """
        texts = get_texts_for_current_language(self.target_language_input)

        max_length = 5000
        if len(description) > max_length:
            print(f"WARNING: Description is {len(description)} chars, exceeding {max_length}, truncating.")
            description = description[:max_length]

        print("DEBUG: Starting upload_to_youtube")
        print("DEBUG: final_video_file:", repr(final_video_file))
        print("DEBUG: title:", repr(title))
        print("DEBUG: description:", repr(description))
        print("DEBUG: tags:", repr(tags))
        print("DEBUG: privacyStatus:", repr(privacyStatus))
        print("DEBUG: categoryId:", repr(categoryId))
        print("DEBUG: language:", repr(language))
        print("DEBUG: recording_date:", repr(recording_date))

        try:
            creds = self.authenticate_youtube_user(switch_account=switch_account)
            self.last_youtube_credentials = creds
        except Exception as e:
            print("Authentication failed:", e)
            return False, None

        try:
            print("DEBUG: Building YouTube service...")
            from googleapiclient.discovery import build
            youtube = build("youtube", "v3", credentials=creds)
        except Exception as e:
            print("❌ Error building YouTube service:", e)
            return False, None

        body = {
            "snippet": {
                "title": title,
                "description": description,
                "tags": tags,
                "categoryId": categoryId,
                "defaultLanguage": language,
                "defaultAudioLanguage": language,
            },
            "status": {
                "privacyStatus": privacyStatus
            },
            "recordingDetails": {
                "recordingDate": recording_date,
            }
        }

        print("DEBUG: Final request body:", body)

        try:
            print("DEBUG: Creating MediaFileUpload object...")
            from googleapiclient.http import MediaFileUpload
            media = MediaFileUpload(final_video_file, chunksize=-1, resumable=True)
        except Exception as e:
            print("❌ Error creating MediaFileUpload object:", e)
            return False, None

        try:
            print("DEBUG: Creating upload request...")
            request = youtube.videos().insert(
                part="snippet,status,recordingDetails",
                body=body,
                media_body=media
            )
        except Exception as e:
            print("❌ Error creating upload request:", e)
            return False, None

        #progress_dialog = self.
        # (self.tr("Uploading Video to YouTube... Please wait."))
        progress_dialog = self.show_progress(texts.get("uploading_video", DEFAULT_STRINGS["uploading_video"]))

        progress_dialog.setRange(0, 100)
        progress_dialog.show()

        response = None
        print("Uploading video to YouTube...")
        try:
            while response is None:
                status, response = request.next_chunk()
                if status:
                    prog_val = int(status.progress() * 100)
                    print("Upload progress: {}%".format(prog_val))
                    progress_dialog.setValue(prog_val)
                    QApplication.processEvents()  # Keep UI responsive.
                    if progress_dialog.wasCanceled():
                        print("Upload canceled by user.")
                        progress_dialog.close()
                        return False, None
            progress_dialog.setValue(100)
            progress_dialog.close()
            video_id = response.get("id")
            print("Upload complete! Video ID:", video_id)
            QMessageBox.information(self, texts.get("info", DEFAULT_STRINGS["info"]),
                                    texts.get("upload_success", DEFAULT_STRINGS["upload_success"]))
            return True, video_id
        except Exception as e:
            progress_dialog.close()
            print("❌ Error during upload:", e)
            return False, None

    def get_output_filename(title, platform, output_dir, ext=".mp4"):
        """
        Create a filename such as "Singing Birds_youtube.mp4".
        Ensures a consistent naming and joining of paths.
        """
        return os.path.join(output_dir, f"{title}_{platform}{ext}")

    def ensure_platform_file(title, desired_platform, output_dir):
        """
        Checks for an existing file for the desired platform.
        If the file does not exist, it searches for any alternative file from the supported platforms.
        If found, a copy is created for the desired platform.
        Returns the file path (existing or newly copied) or None if not found.
        """
        desired_file = get_output_filename(title, desired_platform, output_dir)

        if os.path.exists(desired_file):
            print(f"[INFO] {desired_platform} file already exists: {desired_file}")
            return desired_file

        # Look for an existing video from one of the alternative platforms
        for alt_platform in PLATFORMS:
            if alt_platform == desired_platform:
                continue
            alt_file = get_output_filename(title, alt_platform, output_dir)
            if os.path.exists(alt_file):
                try:
                    shutil.copy(alt_file, desired_file)
                    print(f"[INFO] Copied {alt_platform} file to {desired_platform}: {desired_file}")
                except Exception as e:
                    print(f"[❌ ERROR] Could not copy file from {alt_platform} to {desired_platform}: {e}")
                return desired_file

        print(f"[INFO] No alternative file found for {desired_platform}.")
        return None

    # ---------------------
    # In your class:
    # ---------------------
    def on_upload_video(self):


        texts = get_texts_for_current_language(self.target_language_input)
        print("DEBUG: on_upload_video: start")

        # Prevent double-clicks
        if getattr(self, "_uploading", False):
            print("DEBUG: already uploading – returning")
            return
        self._uploading = True
        self.upload_video_btn.setEnabled(False)

        try:
            # Step 1: Normalize output directory
            print("DEBUG: Step 1 – normalize output_directory")

            # Safely read raw_output_path from either a QLineEdit or a str
            if hasattr(self.output_directory, "text"):
                raw_output_path = self.output_directory.text().strip()
            else:
                raw_output_path = str(self.output_directory).strip()

            # remember it
            self.last_output_path = raw_output_path

            # normalize for OS
            out_dir = os.path.normpath(raw_output_path)

            # Step 2: Choose platform
            print("DEBUG: Step 2 – choose platform")
            platform = choose_social_media_platform(self)
            print(f"DEBUG: platform = {platform}")

            # Step 3: Get video title
            print("DEBUG: Step 3 – get video_title")
            video_title = self.video_title_input.text().strip()

            # Step 4: Ensure final video file exists
            print("DEBUG: Step 4 – ensure_platform_file")
            final_video_file = ensure_platform_file(
                video_title,
                platform.lower(),
                out_dir
            )
            if not final_video_file:
                print("DEBUG: Step 4a – final_video_file missing, warning user")
                #QMessageBox.warning(
                #    self,
                #    texts.get("file_not_found_title", "⚠️ WARNING: File Not Found"),
                #    texts.get(
                #        "file_not_found_msg",
                #        f"Final video file for {platform.capitalize()} not found."
                #    )
                #)
                QMessageBox.warning(
                    self,
                    self.file_not_found_title,
                    self.file_not_found_msg.format(platform.capitalize())
                )
                return

            final_video_file = os.path.normpath(final_video_file)
            print(f"DEBUG: Step 4b – final_video_file = {final_video_file}")

            # Step 5: Early-exit for non-YouTube
            print("DEBUG: Step 5 – non-YouTube early exit check")
            if platform.lower() in ("facebook", "instagram", "tiktok", "720p"):
                msg = texts.get(
                    "coming_soon_msg",
                    "The integration for {} is coming soon.\n\n"
                    "Please manually upload the final video.\nVideo path: {}"
                ).format(
                    platform.capitalize(),
                    final_video_file.replace("/", "\\")
                )
                #QMessageBox.information(
                #    self,
                #    texts.get("coming_soon_title", "Coming Soon"),
                #    msg
                #)
                QMessageBox.information(
                    self,
                    self.coming_soon_title,
                    self.coming_soon_msg.format(
                        platform.capitalize(),
                        final_video_file.replace("/", "\\")
                    )
                )
                return

            # Step 6: Build default_tags
            print("DEBUG: Step 6 – build default_tags")
            if hasattr(self, "modified_keywords") and self.modified_keywords:
                mk = self.modified_keywords
                if isinstance(mk, str):
                    default_tags = [
                        t.strip()
                        for t in mk.replace("\n", ",").split(",")
                        if t.strip()
                    ]
                else:
                    default_tags = list(mk)
            else:
                extracted = seo_extract_keywords(video_title)
                default_tags = [
                    kw.strip()
                    for kw in extracted.replace("\n", ",").split(",")
                    if kw.strip()
                ]

            # Step 7: Load default_description
            print("DEBUG: Step 7 – load default_description")
            srt_txt = os.path.join(
                out_dir,
                f"{video_title}_subtitles.txt"
            )
            if os.path.exists(srt_txt):
                with open(srt_txt, "r", encoding="utf-8") as f:
                    default_description = f.read()
            else:
                default_description = ""
            print("DEBUG: default_description loaded")

            # Step 8: Prompt “Modify Keywords?”
            print("DEBUG: Step 8 – optional modify keywords")
            if self.modify_yes.isChecked():
                new_str, ok = QInputDialog.getText(
                    self,
                    texts.get(
                        "modify_label",
                        DEFAULT_STRINGS["modify_label"]
                    ),
                    texts.get(
                        "enter_keywords",
                        DEFAULT_STRINGS["enter_keywords"]
                    ),
                    QLineEdit.Normal,
                    ", ".join(default_tags)
                )
                if ok:
                    default_tags = [
                        kw.strip()
                        for kw in new_str.replace("\n", ",").split(",")
                        if kw.strip()
                    ]
                    print("DEBUG: Modified Keywords:", default_tags)

            # Step 9: Auto-translate/combine keywords
            print("DEBUG: Step 9 – translate_and_combine_keywords")
            combined = translate_and_combine_keywords(default_tags)
            default_tags = [
                t.strip()
                for t in combined.split(",")
                if t.strip()
            ]
            print("DEBUG: Final default_tags:", default_tags)

            # Step 10: Show UploadDialog
            print("DEBUG: Step 10 – launch UploadDialog")
            dialog = UploadDialog(
                default_description=default_description,
                default_tags=default_tags,
                default_privacy="private",
                default_thumbnail="",
                parent=self
            )
            if dialog.exec_() == QDialog.Accepted:
                print("DEBUG: Step 10a – dialog accepted")
                (description, tags, privacyStatus,
                 thumbnail, categoryId, language,
                 recording_date, switch_account) = dialog.getData()
                print("DEBUG: switch_account =", switch_account)
                self.switch_youtube_account = switch_account

                # Step 11: Clean tags
                print("DEBUG: Step 11 – clean tags")
                cleaned_tags = []
                for tag in tags:
                    ct = tag.replace(".", "").strip()
                    if 0 < len(ct) <= 50:
                        cleaned_tags.append(ct)
                tags = cleaned_tags
                print("DEBUG: Cleaned tags:", tags)

                # Step 12: Upload to YouTube
                print("DEBUG: Step 12 – upload_to_youtube")
                result, video_id = self.upload_to_youtube(
                    final_video_file,
                    video_title,
                    description, tags, privacyStatus,
                    categoryId, language, recording_date,
                    switch_account=self.switch_youtube_account
                )
                print("DEBUG: upload_to_youtube returned", result, video_id)

                # Step 13: Thumbnail upload
                print("DEBUG: Step 13 – thumbnail upload")
                if (result and video_id and thumbnail
                        and os.path.exists(thumbnail)):
                    try:
                        from googleapiclient.http import MediaFileUpload
                        from googleapiclient.discovery import build

                        progress_dialog = self.show_progress(
                            texts.get("uploading_thumbnail",
                                      DEFAULT_STRINGS["uploading_thumbnail"])
                        )
                        progress_dialog.setRange(0, 100)
                        progress_dialog.show()
                        print("DEBUG: Uploading thumbnail…")

                        youtube = build('youtube', 'v3',
                                        credentials=self.last_youtube_credentials)
                        youtube.thumbnails().set(
                            videoId=video_id,
                            media_body=MediaFileUpload(thumbnail)
                        ).execute()

                        print("DEBUG: Thumbnail upload successful.")
                        progress_dialog.setValue(100)
                        progress_dialog.close()

                        QMessageBox.information(
                            self,
                            texts.get("info",DEFAULT_STRINGS["info"]),
                            texts.get("upload_success",DEFAULT_STRINGS["upload_success"])
                        )
                    except Exception as e:
                        print("❌ ERROR: Thumbnail upload failed:", e)
                elif not (result and video_id):
                    QMessageBox.critical(
                        self,
                        texts.get("upload_failure_title", "❌ Upload Failure"),
                        texts.get("upload_failure",
                                  DEFAULT_STRINGS["upload_failure"])
                    )

        except Exception:
            print("❌ Python exception in on_upload_video:")
            traceback.print_exc()

        finally:
            # Restore UI state
            print("DEBUG: on_upload_video: finally – resetting UI")
            self._uploading = False
            self.upload_video_btn.setEnabled(True)

    def authenticate_instagram_user(self):
        """
        Pseudocode for user authentication via Instagram.
        Steps:
          - Direct the user to Instagram’s OAuth URL in a web view or external browser.
          - Receive a redirect with a code.
          - Exchange the code for a user access token.
        Return the access token.
        """
        # For a production app, you’ll use a proper OAuth flow
        access_token = "USER_PROVIDED_INSTAGRAM_ACCESS_TOKEN"
        return access_token

    def upload_to_instagram(self, final_video_file):
        """
        Upload video to Instagram.
        Note: Instagram requires that the video be hosted at a publicly accessible URL.
        Thus, you may need to upload the final_video_file to a cloud storage or server first.
        """
        access_token = self.authenticate_instagram_user()
        ig_user_id = "USER_INSTAGRAM_ID"  # Should be obtained via OAuth
        # Step 1: Upload your video to a public host (not shown)
        video_public_url = "https://your-public-host.com/path/to/video.mp4"

        # Step 2: Create a media container
        upload_url = f"https://graph.facebook.com/v16.0/{ig_user_id}/media"
        data = {
            "media_type": "VIDEO",
            "video_url": video_public_url,
            "caption": "Your caption here",
            "access_token": access_token
        }
        r = requests.post(upload_url, data=data)
        if r.status_code != 200:
            print("❌ Instagram container error:", r.text)
            return False
        container_id = r.json().get("id")

        # Step 3: Publish the container
        publish_url = f"https://graph.facebook.com/v16.0/{ig_user_id}/media_publish"
        data = {
            "creation_id": container_id,
            "access_token": access_token
        }
        r = requests.post(publish_url, data=data)
        if r.status_code == 200:
            print("Instagram upload successful.")
            return True
        else:
            print("❌ Instagram publish error:", r.text)
            return False

    def authenticate_tiktok_user(self):
        """
        Pseudocode for TikTok authentication.
        You need to direct the user to TikTok’s OAuth login, obtain a code, exchange it for an access token.
        """
        access_token = "USER_TIKTOK_ACCESS_TOKEN"
        return access_token

    def upload_to_tiktok(self, final_video_file):
        """
        Upload the video to TikTok.
        Note: This outline assumes TikTok provides an endpoint for direct file upload.
        """
        access_token = self.authenticate_tiktok_user()
        upload_endpoint = "https://open-api.tiktok.com/video/upload/"
        files = {"video": open(final_video_file, "rb")}
        params = {"access_token": access_token}
        r = requests.post(upload_endpoint, params=params, files=files)
        if r.status_code != 200:
            print("❌ TikTok upload error:", r.text)
            return False
        # Assume a successful response returns a video_id.
        video_id = r.json().get("video_id")
        # If TikTok requires a publish step:
        publish_endpoint = "https://open-api.tiktok.com/video/publish/"
        data = {"video_id": video_id, "access_token": access_token, "caption": "Your caption here"}
        r = requests.post(publish_endpoint, data=data)
        if r.status_code == 200:
            print("TikTok upload successful.")
            return True
        else:
            print("❌ TikTok publish error:", r.text)
            return False

    def authenticate_facebook_user(self):
        """
        Use a Facebook OAuth flow to obtain a page access token.
        For this example, assume the user logs in and you receive a token.
        """
        access_token = "USER_FACEBOOK_PAGE_ACCESS_TOKEN"  # Retrieved via OAuth process
        return access_token

    def upload_to_facebook(self, final_video_file):
        """
        Upload a video to Facebook using the Graph Video API.
        """
        access_token = self.authenticate_facebook_user()
        page_id = "YOUR_FACEBOOK_PAGE_ID"  # You can let the user enter this or choose from a list, etc.
        upload_url = f"https://graph-video.facebook.com/v16.0/{page_id}/videos"

        files = {"source": open(final_video_file, "rb")}
        data = {
            "access_token": access_token,
            "title": "Your Video Title",
            "description": "Your video description",
            "published": "true",
        }
        response = requests.post(upload_url, files=files, data=data)
        if response.status_code == 200:
            print("Facebook upload successful.", response.json())
            return True
        else:
            print("Facebook upload failed:", response.text)
            return False

    def on_generate_final_video(self):

        texts = get_texts_for_current_language(self.target_language_input)

        # Optionally, you may want to re-use the logic from _on_review_response
        #progress = self.show_progress(self.tr("Generating Final Video... Please wait."))
        progress = self.show_progress(texts.get("generating_final_video", DEFAULT_STRINGS["generating_final_video"]))

        if self.bypass_yes.isChecked():
            self.continue_video_creation_bypass()
        else:
            self.continue_video_creation()

        #progress.close()
        self._cleanup_progress()

        # Switch automatically to the new "Final Video" tab.
        final_video_index = self.tabs.indexOf(self.final_video_tab)
        if final_video_index != -1:
            self.tabs.setCurrentIndex(final_video_index)
        # Call this method after generating the final video
        self.update_video_preview()

    def show_progress(self, message: str) -> QProgressDialog:
        self._cleanup_progress()
        texts = get_texts_for_current_language(self.target_language_input)
        dlg = QProgressDialog(message, None, 0, 0, self)
        dlg.setWindowModality(Qt.ApplicationModal)
        dlg.setWindowTitle(
            texts.get("processing_title", DEFAULT_STRINGS["processing_title"])
        )
        dlg.setCancelButton(None)
        dlg.setMinimumDuration(0)

        # Make it frameless and stay on top

        dlg.setWindowFlags(
            dlg.windowFlags()
            | Qt.FramelessWindowHint
            | Qt.WindowStaysOnTopHint
        )


        # Updated stylesheet

        dlg.setStyleSheet("""
            QProgressDialog {
                background-color: rgba(240, 240, 240, 220);
                border-radius: 10px;
                padding: 20px;
            }

            QLabel {
                color: black;
                font-size: 12px;
                font-weight: bold;
            }
        """)


        # initially set plain text

        dlg.setLabelText(message)
        dlg.show()
        dlg.setValue(0)
        QApplication.processEvents()

        # ─── grab the internal QLabel and allow HTML ────────────

        lbl = dlg.findChild(QLabel)
        if lbl:
            lbl.setTextFormat(Qt.RichText)
            lbl.setWordWrap(True)
        # ─────────────────────────────────────────────────────────

        # prepare toggle values for flashing text

        orig  = message
        flash = f'<font color="#5d8aa8">{message}</font>'
        state = [False]

        # ─── flash timer ────────────────────────────────────────

        timer = QTimer(dlg)
        timer.setInterval(500)

        def _flash():
            state[0] = not state[0]
            if lbl:
                lbl.setText(flash if state[0] else orig)

        timer.timeout.connect(_flash)
        timer.start()

        # ─────────────────────────────────────────────────────────

        self.progress     = dlg
        self._flash_timer = timer
        return dlg



    def _cleanup_progress(self):
        """Stop & delete any existing progress dialog & its timer."""
        t = getattr(self, "_flash_timer", None)
        if t:
            t.stop()
            t.deleteLater()
            self._flash_timer = None
        d = getattr(self, "progress", None)
        if d:
            d.close()
            d.deleteLater()
            self.progress = None

    def dropEvent(self, event):
        texts = get_texts_for_current_language(self.parent.target_language_input)
        if not event.isAccepted() and event.source() == self:
            drop_row = self.rowAt(event.pos().y())
            if drop_row == -1:
                drop_row = self.rowCount() - 1

            rows = sorted(set(item.row() for item in self.selectedItems()))
            if not rows:
                return

            source_row = rows[0]

            # Prevent dropping onto itself
            if source_row == drop_row:
                event.ignore()
                return

            print(f"Moving row {source_row} to {drop_row}")

            try:
                # After you compute `texts` …
                self.progress = self.show_progress(
                    texts.get("moving_media_message",
                              DEFAULT_STRINGS["moving_media_message"])
                )
                # keep it window-modal and on-top if you like
                self.progress.setWindowModality(Qt.WindowModal)
                self.progress.setWindowFlags(
                    self.progress.windowFlags() | Qt.WindowStaysOnTopHint
                )
                # prevent wrapping
                self.progress.setMinimumWidth(250)
                QApplication.processEvents()

                self.last_scroll_position = self.verticalScrollBar().value()

                if hasattr(self.parent, 'media_clips'):
                    media_clips = self.parent.media_clips
                    if source_row < len(media_clips):
                        final_drop_row = drop_row
                        if drop_row > source_row:
                            final_drop_row -= 1

                        clip = media_clips.pop(source_row)
                        insert_pos = min(final_drop_row, len(media_clips))
                        media_clips.insert(insert_pos, clip)

                        event.accept()
                        self.dragging = False

                        # Use timer to close progress dialog after refresh
                        QTimer.singleShot(1, lambda: self._refresh_after_drop(final_drop_row))

                        print(f"Drop completed successfully")
                    else:
                        self._cleanup_progress()
                        #progress.close()
                        event.ignore()
                else:
                    #progress.close()
                    self._cleanup_progress()
                    event.ignore()

            except Exception as e:
                print(f"Error during drop operation: {e}")
                self._cleanup_progress()
                #progress.close()
                event.ignore()
                self.dragging = False

    def translate_text(text, target_lang, source_lang="en"):
        try:
            model_name = f"Helsinki-NLP/opus-mt-{source_lang}-{target_lang}"
            # Check GPU availability and set device.
            if torch.cuda.is_available():
                device = 0  # Use the first GPU (you can change this if you have multiple GPUs).
                print("Using GPU for translation.")
            else:
                device = -1  # Use CPU if no GPU is available.
                print("Using CPU for translation.")
            translator = pipeline("translation", model=model_name, device=device)
            result = translator(text, max_length=512)
            return result[0]['translation_text']
        except Exception as e:
            print(f"Translation exception: {e}")
            return text

        # Update translated texts for all GUI widgets.

    def update_translated_texts(self):
        # Get the language code from the combo box's userData instead of using self.target_languages.
        texts = get_texts_for_current_language(self.target_language_input)

        # Update tab titles, labels and buttons.
        self.tabs.setTabText(0, texts.get("main_tab_title", DEFAULT_STRINGS["main_tab_title"]))
        self.voice_label.setText(texts.get("voice_label", DEFAULT_STRINGS["voice_label"]))
        self.video_title_label.setText(texts.get("video_title_label", DEFAULT_STRINGS["video_title_label"]))
        self.platform_label.setText(texts.get("platform_label", DEFAULT_STRINGS["platform_label"]))
        self.prompt_label.setText(texts.get("prompt_label", DEFAULT_STRINGS["prompt_label"]))
        self.genre_label.setText(texts.get("genre_label", DEFAULT_STRINGS["genre_label"]))
        self.modify_label.setText(texts.get("modify_label", DEFAULT_STRINGS["modify_label"]))
        self.bypass_label.setText(texts.get("bypass_label", DEFAULT_STRINGS["bypass_label"]))
        self.start_button.setText(texts.get("start_video_btn", DEFAULT_STRINGS["start_video_btn"]))
        self.save_button.setText(texts.get("save_subtitles_btn", DEFAULT_STRINGS["save_subtitles_btn"]))
        self.replace_clip_btn.setText(texts.get("replace_clip_btn", DEFAULT_STRINGS["replace_clip_btn"]))
        self.delete_clip_btn.setText(texts.get("delete_clip_btn", DEFAULT_STRINGS["delete_clip_btn"]))
        self.generate_final_video_btn.setText(
            texts.get("generate_final_video_btn", DEFAULT_STRINGS["generate_final_video_btn"]))
        self.upload_video_btn.setText(texts.get("upload_video_btn", DEFAULT_STRINGS["upload_video_btn"]))
        self.play_video_btn_final.setText(texts.get("play_video_btn_final", DEFAULT_STRINGS["play_video_btn_final"]))

        # Update directory labels.
        self.base_directory_label.setText(texts.get("base_directory_label", DEFAULT_STRINGS["base_directory_label"]))
        self.base_browse_button.setText(texts.get("base_browse_btn", DEFAULT_STRINGS["base_browse_btn"]))
        self.video_image_folder_label.setText(
            texts.get("video_image_folder_label", DEFAULT_STRINGS["video_image_folder_label"]))
        self.output_directory_label.setText(
            texts.get("output_directory_label", DEFAULT_STRINGS["output_directory_label"]))
        self.music_folder_label.setText(texts.get("music_folder_label", DEFAULT_STRINGS["music_folder_label"]))
        self.voiceover_directory_label.setText(
            texts.get("voiceover_directory_label", DEFAULT_STRINGS["voiceover_directory_label"]))

        # Update Status label.
        self.status_label.setText(texts.get("status_label", DEFAULT_STRINGS["status_label"]))

        # Update target language label widget.
        if hasattr(self, "target_language_label_widget"):
            self.target_language_label_widget.setText(
                texts.get("target_language_label", DEFAULT_STRINGS["target_language_label"]))
        else:
            print("target_language_label_widget not defined.")

        # Finally, update the test voice button text.
        self.test_voice_button.setText(texts.get("test_voice_button", DEFAULT_STRINGS["test_voice_button"]))

        # Update tab titles for other tabs.
        self.tabs.setTabText(1, texts.get("review_script_tab", DEFAULT_STRINGS["review_script_tab"]))
        self.tabs.setTabText(2, texts.get("review_clips_tab", DEFAULT_STRINGS["review_clips_tab"]))
        self.tabs.setTabText(3, texts.get("final_video_tab", DEFAULT_STRINGS["final_video_tab"]))

        # Final-Video tab title
        idx = self.tabs.indexOf(self.final_video_tab)
        if idx != -1:
            self.tabs.setTabText(idx,
                                 texts.get("final_video_tab", DEFAULT_STRINGS["final_video_tab"])
                                 )

        # VLC control buttons
        self.play_button.setText(texts.get("play_button", DEFAULT_STRINGS["play_button"]))
        self.pause_button.setText(texts.get("pause_button", DEFAULT_STRINGS["pause_button"]))
        self.forward_button.setText(texts.get("forward_button", DEFAULT_STRINGS["forward_button"]))
        self.backward_button.setText(texts.get("backward_button", DEFAULT_STRINGS["backward_button"]))

        # The big “Play Video” button
        self.play_video_btn_final.setText(
            texts.get("play_video_btn_final", DEFAULT_STRINGS["play_video_btn_final"])
        )

        # The Upload button
        self.upload_video_btn.setText(
            texts.get("upload_video_btn", DEFAULT_STRINGS["upload_video_btn"])
        )

        # Now update your Yes/No radio buttons

        self.modify_yes.setText(texts.get("yes", DEFAULT_STRINGS["yes"]))
        self.modify_no.setText(texts.get("no", DEFAULT_STRINGS["no"]))
        self.bypass_yes.setText(texts.get("yes", DEFAULT_STRINGS["yes"]))
        self.bypass_no.setText(texts.get("no", DEFAULT_STRINGS["no"]))

        # Store dialog templates for later calls:

        self.coming_soon_title = texts["coming_soon_title"]
        self.coming_soon_msg = texts["coming_soon_msg"]
        self.youtube_shorts_reminder_title = texts["youtube_shorts_reminder_title"]
        self.youtube_shorts_reminder_msg = texts["youtube_shorts_reminder_msg"]
        self.file_not_found_title = texts["file_not_found_title"]
        self.file_not_found_msg = texts["file_not_found_msg"]

        # Now the 5th tab: Support
        support_tab_index = self.tabs.indexOf(self.support_tab)
        if support_tab_index != -1:
            self.tabs.setTabText(support_tab_index, texts.get("support_tab", DEFAULT_STRINGS["support_tab"]))

        self.sr_number_label.setText(texts.get("sr_number_label", DEFAULT_STRINGS["sr_number_label"]))
        self.customer_name_label.setText(
            texts.get("customer_name_label", DEFAULT_STRINGS["customer_name_label"]) + " *")
        self.email_label.setText(texts.get("email_label", DEFAULT_STRINGS["email_label"]) + " *")
        self.phone_label.setText(texts.get("phone_label", DEFAULT_STRINGS["phone_label"]))
        self.ticket_type_label.setText(texts.get("ticket_type_label", DEFAULT_STRINGS["ticket_type_label"]) + " *")
        self.issue_description_label.setText(
            texts.get("issue_description_label", DEFAULT_STRINGS["issue_description_label"]) + " *")
        self.video_name_label.setText(texts.get("video_name_label", DEFAULT_STRINGS["video_name_label"]) + " *")
        self.creation_dt_label.setText(texts.get("creation_dt_label", DEFAULT_STRINGS["creation_dt_label"]) + " *")
        self.desc_label.setText(texts.get("desc_label", DEFAULT_STRINGS["desc_label"]) + " *")
        self.send_button.setText(texts.get("send_button", DEFAULT_STRINGS["send_button"]))

        check_faq_text = texts.get("check_faq_label", DEFAULT_STRINGS["check_faq_label"])
        self.check_faq_label.setText(check_faq_text)

        faq_link = texts.get("faq_link_text", DEFAULT_STRINGS["faq_link_text"])
        self.faq_link_label.setText(f'<a href="{FAQ_LINK}" style="color:blue;">{faq_link}</a>')

        # 1) Retrieve the localized strings for Issue / Enhancement / Comment
        issue_str = texts.get("issue_option", DEFAULT_STRINGS["issue_option"])
        enh_str = texts.get("enh_option", DEFAULT_STRINGS["enh_option"])
        comment_str = texts.get("comment_option", DEFAULT_STRINGS["comment_option"])

        # 2) Remember the current userData or index, so you can preserve selection
        current_data = self.ticket_type_combo.currentData()

        # 3) Clear and re-add items with userData
        self.ticket_type_combo.clear()
        self.ticket_type_combo.addItem(issue_str, userData="issue")
        self.ticket_type_combo.addItem(enh_str, userData="enhancement")
        self.ticket_type_combo.addItem(comment_str, userData="comment")
        # Then connect on_ticket_type_changed
        self.ticket_type_combo.currentIndexChanged.connect(self.on_ticket_type_changed)
        # 4) Restore the previous selection if you like:
        for i in range(self.ticket_type_combo.count()):
            if self.ticket_type_combo.itemData(i) == current_data:
                self.ticket_type_combo.setCurrentIndex(i)
                break
        # 5) For the missing-fields dialog
        #    you can store them if you prefer:
        self.missing_required_title = texts.get("missing_required_title", DEFAULT_STRINGS["missing_required_title"])
        self.missing_required_msg = texts.get("missing_required_msg", DEFAULT_STRINGS["missing_required_msg"])

    def set_video_title(self, text):
        self.video_title = text.strip()

    def update_output_directory(self):
        base_dir = self.base_directory.text().strip()
        if base_dir:
            self.output_directory = os.path.join(base_dir, "OutFiles")
        else:
            self.output_directory = ""

    def on_tab_changed(self, index):
        texts = get_texts_for_current_language(self.target_language_input)

        # Get the current widget and its "tabFunction" property.
        current_widget = self.tabs.widget(index)
        tab_function = current_widget.property("tabFunction")
        print(f"Switching to tab with tabFunction: {tab_function}")

        # ─── Full-screen / Windowed toggle ────────────────────────────
        if tab_function in ("clips", "final_video"):
            # True full-screen:
            #self.showFullScreen()
            # Or, if you prefer maximized with titlebar, uncomment this instead:
            self.showMaximized()
        else:
            # restore to normal window
            self.showNormal()
        # ────────────────────────────────────────────────────────────────

        # ─── Per-tab processing ────────────────────────────────────────
        if tab_function == "script":
            # 1) Show the flashing progress dialog
            progress = self.show_progress(
                texts.get("processing_subtitles_message",
                          DEFAULT_STRINGS["processing_subtitles_message"])
            )
            # 2) Optionally override its title
            progress.setWindowTitle(
                texts.get("processing_title",
                          DEFAULT_STRINGS["processing_title"])
            )
            QApplication.processEvents()

            # 3) Do your work
            print("Before load_subtitles")
            self.load_subtitles()
            print("After load_subtitles")

            # 4) Close and clean up
            self._cleanup_progress()

        elif tab_function == "clips":
            # 1) Show the flashing progress dialog
            progress = self.show_progress(
                texts.get("loading_clips_message",
                          DEFAULT_STRINGS["loading_clips_message"])
            )

            # 2) Override the window title if you like
            progress.setWindowTitle(
                texts.get("loading_title",
                          DEFAULT_STRINGS["loading_title"])
            )

            QApplication.processEvents()
            # 3) Do the work
            print("Before load_clips_and_subtitles")
            #self.load_subtitles()
            self.load_clips_and_subtitles()
            print("After load_clips_and_subtitles")

            # 4) Close and clean up the progress UI
            self._cleanup_progress()

        elif tab_function == "final_video":
            # full-screen is already applied above; no extra loading step
            pass

        elif tab_function == "main":
            # now back to windowed, user can build a new video
            print("Main tab selected. (No additional processing required.)")

        else:
            # any other custom tabs…
            pass
        # ────────────────────────────────────────────────────────────────

    def load_subtitles(self, srt_file_path=None):
        """
        Load subtitles safely when switching tabs.
        If srt_file_path is provided, it is used; else the default is built.
        """
        if not hasattr(self, "subtitles_editor") or self.subtitles_editor is None:
            print("⚠️ subtitles_editor is not initialized yet. Skipping load_subtitles().")
            return None  # Prevent crash

        # Ensure video_title is set
        if not hasattr(self, "video_title") or not self.video_title or self.video_title.strip() == "default_video":
            self.video_title = self.video_title_input.text().strip() if self.video_title_input.text().strip() else "default_video"

        # Ensure output_directory is a string (extract text if it’s a QLineEdit)
        if isinstance(self.output_directory, QLineEdit):
            self.output_directory = self.output_directory.text().strip()
        if not self.output_directory:
            self.output_directory = os.getcwd()  # Default to current directory
            print(f"⚠️ Warning: output_directory not set, using {self.output_directory}")

        # Build default subtitles file path if not provided
        if srt_file_path is None:
            srt_file_path = os.path.join(self.output_directory, f"{self.video_title}_subtitles.txt")

        print(f"🔍 Looking for subtitle file at: {srt_file_path}")

        try:
            if os.path.exists(srt_file_path):
                with open(srt_file_path, "r", encoding="utf-8") as file:
                    subtitle_text = file.read()
                self.subtitles_editor.setText(subtitle_text)
                print("✅ Subtitles loaded successfully!")
                return subtitle_text.splitlines()  # Return list of lines or however you expect subtitles
            else:
                self.subtitles_editor.setText(f"Subtitle file not found: {srt_file_path}")
                print("❌ Subtitle file missing!")
                return None
        except Exception as e:
            print(f"❌ Error in load_subtitles(): {e}")
            return None

    def on_voiceover_complete(self):
        print("✅ Voiceover generation completed! Reloading subtitles...")
        self.load_clips_and_subtitles()

    from PyQt5.QtWidgets import QComboBox, QMessageBox

    def save_and_regenerate(self):
        texts = get_texts_for_current_language(self.target_language_input)
        progress = self.show_progress(
            texts.get("saving_subtitles",
                      DEFAULT_STRINGS["saving_subtitles"])
        )

        try:
            # 1) Ensure output dir
            if not self.output_directory:
                print("❌ Output directory not set. Cannot save subtitles.")
                return

            # 2) Save the .txt
            subtitles_file = os.path.join(
                self.output_directory,
                f"{self.video_title}_subtitles.txt"
            )
            try:
                with open(subtitles_file, "w", encoding="utf-8") as file:
                    file.write(self.subtitles_editor.toPlainText())
                print(f"💾 Subtitle file successfully saved to: {subtitles_file}")
            except Exception as e:
                print(f"❌ Error saving subtitles: {e}")
                return

            # 3) Pick the voice
            if hasattr(self, "voice_selector") and hasattr(self.voice_selector, "voice_input"):
                vi = self.voice_selector.voice_input
                if isinstance(vi, QComboBox):
                    selected_voice = vi.currentText().strip()
                else:
                    selected_voice = vi.text().strip()
            else:
                print("❌ Error: Voice selection not initialized!")
                return

            if not selected_voice:
                print("❌ Error: No voice selected! Please choose a valid voice.")
                return

            print(f"🎙️ Using voice: {selected_voice} for text-to-speech.")

            # 4) Launch TTS thread
            voice_path = os.path.join(
                self.output_directory,
                f"{self.video_title}_voiceover.mp3"
            )
            self.voiceover_thread = VoiceoverThread(
                self.subtitles_editor.toPlainText(),
                voice_path,
                selected_voice
            )
            # when done, regenerate SRT & reload table
            self.voiceover_thread.finished.connect(
                self._on_voiceover_finished
            )
            self.voiceover_thread.start()

            # 5) Switch tabs immediately (voice is async)
            self.subtitles_tab.setEnabled(False)
            self.clip_sub_tab.setEnabled(True)
            self.tabs.setCurrentIndex(2)  # Clips tab

        except Exception as e:
            QMessageBox.critical(
                self, "❌ Error",
                f"❌ An error occurred during subtitle processing: {e}"
            )
        finally:
            self._cleanup_progress()

    def _on_voiceover_finished(self):
        """
        Called when the voiceover MP3 has finished generating.
        Now the MP3 exists, so we can generate a correct SRT
        and reload the clip/subtitle table.
        """
        print("✅ Voiceover generation completed!")

        try:
            # regenerate SRT with correct durations
            self.generate_srt()
        except Exception as e:
            print(f"⚠️ WARNING: generate_srt() failed: {e}")

        try:
            # now parse that new SRT and repopulate the table
            self.load_clips_and_subtitles()
        except Exception as e:
            print(f"⚠️ WARNING: load_clips_and_subtitles() failed: {e}")


    def load_clips_and_subtitles(self):
        """
        Reloads the clips and subtitles (if available) for the review tab.
        Uses safe_str to avoid calling .text() on a string in bypass mode.
        """
        print("DEBUG: Inside load_clips_and_subtitles.")
        if getattr(self, 'bypass_mode', False):
            print("Bypass mode active; populating review tab with downloaded media only.")
            try:
                # Convert the folder widgets/strings safely to str and strip whitespace
                media_folder = safe_str(self.video_image_folder).strip()
                print(f"Media folder from safe_str: {media_folder}")
                if media_folder and os.path.exists(media_folder):
                    media_files = []
                    try:
                        for f in os.listdir(media_folder):
                            if f.lower().endswith(('.mp4', '.avi', '.mov', '.jpg', '.jpeg', '.png')):
                                media_files.append(os.path.join(media_folder, f))
                    except Exception as list_e:
                        print(f"❌ Error reading media folder: {list_e}")
                else:
                    media_files = []

                # Convert the music folder safely
                music_folder = safe_str(self.music_folder).strip()
                print(f"Music folder from safe_str: {music_folder}")
                if music_folder and os.path.exists(music_folder):
                    music_files = []
                    try:
                        for f in os.listdir(music_folder):
                            if f.lower().endswith('.mp3'):
                                music_files.append(os.path.join(music_folder, f))
                    except Exception as list_e:
                        print(f"❌ Error reading music folder: {list_e}")
                else:
                    music_files = []

                print(f"Found {len(media_files)} media files and {len(music_files)} music files in bypass mode.")

                # Create a placeholder subtitles list (one empty string per media file).
                subtitles = [''] * len(media_files)

                # Store lists as attributes
                self.media_clips = media_files
                self.music_clips = music_files
                self.wip_subtitles = subtitles  # Store subtitles as an instance variable

                # Populate the clips table.
                self.populate_clip_table()  # Use self.media_clips and self.music_clips
                self.clip_table.viewport().update()  # Force UI refresh
                print("✅ Clips table populated in bypass mode!")
            except Exception as e:
                print(f"❌ Exception while populating clips table in bypass mode: {e}")
            return

        # Normal (non-bypass) branch.
        srt_file = os.path.join(self.output_directory, f"{self.video_title}_subtitles.srt")
        if not os.path.exists(srt_file):
            print(f"❌ Subtitle SRT file not found: {srt_file}")
            return

        try:

            with open(srt_file, "r", encoding="utf-8") as file:
                srt_content = file.readlines()
            subtitles = self.parse_srt(srt_content)
            self.wip_subtitles = subtitles  # Store subtitles as an instance variable

            # Populate the clips table.
            self.populate_clip_table()  # Use self.media_clips and self.music_clips
            self.clip_table.viewport().update()  # Force UI refresh
            print("✅ Clips and subtitles table updated!")
        except Exception as e:
            print(f"❌ Error loading subtitles: {e}")

    def parse_srt(self, srt_content):
        """ Parses SRT content into subtitle entries for the table. """
        subtitles = []
        index = 0

        while index < len(srt_content):
            try:
                if "-->" in srt_content[index]:  # Timestamp line
                    start_time, end_time = srt_content[index].strip().split(" --> ")
                    subtitle_text = []
                    index += 1

                    # Collect all subtitle lines (handle multi-line subtitles properly)
                    while index < len(srt_content) and srt_content[index].strip():
                        subtitle_text.append(srt_content[index].strip())
                        index += 1

                    # Ensure multi-line subtitles are combined correctly
                    subtitle_text = " ".join(subtitle_text)

                    # ✅ Ensure timestamps are properly formatted as float
                    start_time_seconds = self.convert_srt_timestamp_to_seconds(start_time)
                    end_time_seconds = self.convert_srt_timestamp_to_seconds(end_time)

                    subtitles.append((start_time_seconds, end_time_seconds, subtitle_text))

                index += 1  # Move to the next block
            except IndexError:
                break
            except ValueError as e:
                print(f"❌ Error parsing subtitle at index {index}: {e}")

        print(f"✅ Parsed {len(subtitles)} subtitles from SRT file")
        return subtitles

    def convert_srt_timestamp_to_seconds(self, timestamp):
        """ Convert SRT timestamp format to total seconds (float). Handles both hh:mm:ss,ms and decimal seconds formats. """
        try:
            if ":" in timestamp:  # If it contains ":", it's in hh:mm:ss,ms format
                h, m, s = timestamp.replace(",", ".").split(":")
                return int(h) * 3600 + int(m) * 60 + float(s)
            else:  # It's already in decimal seconds format
                return float(timestamp)
        except Exception as e:
            print(f"❌ Error converting timestamp '{timestamp}': {e}")
            return 0.0


    def generate_srt(self):
        if not self.output_directory:
            print("❌ Output directory not set. Cannot generate SRT.")
            return

        # 1) Get the script text
        script = self.subtitles_editor.toPlainText().strip()
        if not script:
            print("❌ No script text found. Aborting SRT generation.")
            return

        # 2) Paths & voiceover duration
        subtitles_file = os.path.join(
            self.output_directory,
            f"{self.video_title}_subtitles.srt"
        )
        voiceover_file = os.path.join(
            self.output_directory,
            f"{self.video_title}_voiceover.mp3"
        )
        voiceover_duration = (
            get_audio_duration(voiceover_file)
            if os.path.exists(voiceover_file)
            else 60.0
        )
        print(f"🎬 Generating SRT ({voiceover_duration:.3f}s) → {subtitles_file}")

        try:
            # 3) Split into lines of <= max_line_len chars
            max_line_len = 45
            words = script.split()
            lines = []
            curr = []
            for w in words:
                cand = " ".join(curr + [w])
                if len(cand) <= max_line_len:
                    curr.append(w)
                else:
                    line = " ".join(curr)
                    lines.append(line)
                    print(f"DEBUG: Line {len(lines)} ({len(line)} chars): {line}")
                    curr = [w]
            if curr:
                line = " ".join(curr)
                lines.append(line)
                print(f"DEBUG: Line {len(lines)} ({len(line)} chars): {line}")

            line_count = len(lines)
            if line_count == 0:
                print("❌ No subtitle lines generated. Aborting.")
                return

            # 4) Evenly divide the voiceover across all lines
            dur_per_line = voiceover_duration / line_count
            print(f"DEBUG: {line_count} lines → {dur_per_line:.3f}s per line")

            # 5) Write the .srt
            with open(subtitles_file, "w", encoding="utf-8") as f:
                start = 0.0
                for idx, text in enumerate(lines):
                    end = start + dur_per_line
                    # snap last line to exact end
                    if idx == line_count - 1:
                        end = voiceover_duration

                    f.write(f"{start:.3f} --> {end:.3f}\n")
                    f.write(text + "\n\n")
                    print(f"DEBUG: wrote block {idx + 1}: {start:.3f}→{end:.3f}")
                    start = end

            print(f"✅ SRT file successfully generated: {subtitles_file}")

        except Exception as e:
            print(f"❌ Error generating subtitles: {e}")

    def openPreview(self, file_path, media_type):
        """
        Open a preview for the given media file.
        For images, display the image in a pop-up dialog.
        For video and music, open using the system default application.
        """

        #print(f"DEBUG: Inside openPreview. file_path: {file_path}, media_type: {media_type}")

        if media_type == "Image":
            previewDialog = QDialog(self)
            previewDialog.setWindowTitle("Image Preview: " + os.path.basename(file_path))
            layout = QVBoxLayout(previewDialog)
            label = QLabel(previewDialog)
            pixmap = QPixmap(file_path)
            if pixmap.isNull():
                label.setText("Unable to load image.")
            else:
                label.setPixmap(pixmap.scaled(800, 600, Qt.KeepAspectRatio, Qt.SmoothTransformation))
            layout.addWidget(label)
            previewDialog.resize(800, 600)
            previewDialog.exec_()
        else:
            print(f"DEBUG: Inside openPreview. Before QDesktopServices.openUrl. file_path: {file_path}")
            # For video and music, use the system default application.
            QDesktopServices.openUrl(QUrl.fromLocalFile(file_path))
            #self._player = QMediaPlayer(self)  # keep a reference!
            #self._player.setMedia(QMediaContent(QUrl.fromLocalFile(file_path)))
            #self._player.play()

    # ---------------------------------------------------------------------------
    # Helper method to add directory input.
    def add_directory_input(self, layout, label_text, line_edit, row, browse_action):

        texts = get_texts_for_current_language(self.target_language_input)

        label = QLabel(label_text)
        layout.addWidget(label, row, 0)
        layout.addWidget(line_edit, row, 1)
        if browse_action:
            #browse_button = QPushButton("Browse")
            browse_button = QPushButton(texts.get("browse_button", DEFAULT_STRINGS["browse_button"]))

            browse_button.btn.setStyleSheet(BTN_STYLE)
            browse_button.clicked.connect(browse_action)
            layout.addWidget(browse_button, row, 2)

    # ---------------------------------------------------------------------------
    # Directory browser.
    def browse_base_directory(self):
        folder = QFileDialog.getExistingDirectory(self, "Select Base Directory")
        self.base_directory.setText(folder)

        pass

    # ---------------------------------------------------------------------------

    def update_derived_directories(self):
        # Get the base directory from the base_directory widget.
        base_dir = self.base_directory.text().strip()

        # If base_dir is provided, derive out_dir; otherwise, use a previously stored value or a hard-coded default.
        if base_dir:
            out_dir = f"{base_dir}/OutFiles"
        else:
            stored = getattr(self, "output_directory_path", "").strip()
            if stored:
                out_dir = stored
            else:
                out_dir = "C:/Default/OutFiles"  # Fallback default

        # Force update the output_directory widget to use the derived out_dir.
        try:
            self.output_directory.setText(out_dir)
        except Exception as e:
            # If for some reason self.output_directory is not a widget, log a warning.
            print("⚠️ WARNING: Could not call setText on output_directory:", e)

        # Also update the voiceover_directory widget (they should be identical).
        try:
            self.voiceover_directory.setText(out_dir)
        except Exception as e:
            print("⚠️ WARNING: Could not call setText on voiceover_directory:", e)

        # Update other related directories if base_dir is provided.
        if base_dir:
            try:
                self.video_image_folder.setText(f"{base_dir}/InVidFiles")
            except Exception as e:
                print("⚠️ WARNING: Could not update video_image_folder:", e)
            try:
                self.music_folder.setText(f"{base_dir}/InMusicFiles")
            except Exception as e:
                print("⚠️ WARNING: Could not update music_folder:", e)

        # Save the derived out_dir in a separate attribute so it persists.
        self.output_directory_path = out_dir

        print("DEBUG: Derived output_directory:", out_dir)
        print("DEBUG: voiceover_directory:",
              self.voiceover_directory.text() if hasattr(self.voiceover_directory,
                                                         "text") else self.voiceover_directory)

        # Retrieve the video title.
        video_title = self.video_title_input.text().strip() if hasattr(self, "video_title_input") else ""
        update_log_file(out_dir, video_title)

    # ---------------------------------------------------------------------------
    # Test selected voice.
    def test_selected_voice(self, voice_name):
        selected_voice = self.voice_selector.get_selected_voice()
        print(f"Voice name type: {type(voice_name)}")  # Debugging line

        # Ensure voice_name is a string
        if isinstance(voice_name, bool):
            print("❌ Error: voice_name is a boolean, expected a string.")
            return

        if not isinstance(voice_name, str):
            print("❌ Error: voice_name is not a string.")
            return

        try:
            communicator = Communicate(text="Hello! This is a voice test. How do I sound?", voice=voice_name)
            print(f"Testing voice: {voice_name}")
            communicator.save("test_voice.mp3")  # Save to file
            os.system("test_voice.mp3")  # Play the audio file
        except Exception as e:
            print(f"❌ Error during voice test: {e}")

    def update_table_row(self, row, new_file, media_type):
        """
        Updates only the specified row in the table after a media file is replaced.
        For Video/Image (columns 0–6): updates the preview (col 1), media type (col 2),
        file name (col 3), and duration (col 4).
        For Music (columns 7–12): updates the preview (col 8), file name (col 9),
        and duration (col 10). (The select checkboxes and cumulative timings in columns 7 and 11–12
        are handled elsewhere.)
        """
        print(f"DEBUG: Inside update_table_row for row {row} with file: {new_file} and media_type: {media_type}")
        ext = os.path.splitext(new_file)[1].lower()
        video_extensions = {".mp4", ".avi", ".mov", ".mkv"}

        if media_type == "Music":
            # Update Music media type row:
            # (Assuming column 7 holds the Music select checkbox, so leave it as is.)
            # Update preview in column 8.
            old_widget = self.clip_table.cellWidget(row, 8)
            if old_widget is not None:
                self.clip_table.removeCellWidget(row, 8)
                old_widget.deleteLater()
            # Use a music-specific icon. Assume you've loaded it and stored on self.music_icon.
            if hasattr(self, "music_icon"):
                thumbnail = self.music_icon.scaled(100, 75, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            else:
                thumbnail = QPixmap(100, 75)
                thumbnail.fill(Qt.gray)
            prevLabel = ClickablePreviewLabel(new_file, "Music", self)
            prevLabel.setPixmap(thumbnail)
            prevLabel.setToolTip(os.path.basename(new_file))
            self.clip_table.setCellWidget(row, 8, prevLabel)

            # Update music file name in column 9.
            self.clip_table.setItem(row, 9, QTableWidgetItem(os.path.basename(new_file)))
            # Update duration in column 10 using get_audio_duration.
            try:
                m_duration = get_audio_duration(new_file)
            except Exception as e:
                print(f"DEBUG: ❌ Error extracting music duration from {new_file}: {e}")
                m_duration = 0.0
            self.clip_table.setItem(row, 10, QTableWidgetItem(format_seconds(m_duration)))

        else:
            # Process Video or Image update (columns 0–6).
            is_video = ext in video_extensions
            # Remove any old widget in the media preview cell (column 1).
            old_widget = self.clip_table.cellWidget(row, 1)
            if old_widget is not None:
                self.clip_table.removeCellWidget(row, 1)
                old_widget.deleteLater()

            if is_video:
                thumbnail = self.get_video_thumbnail(new_file)
                if thumbnail is None or thumbnail.isNull():
                    print(f"❌ Error: Could not generate thumbnail for {new_file}. Using default icon.")
                    thumbnail = QPixmap(100, 75)
                    thumbnail.fill(Qt.gray)
                else:
                    # Ensure the thumbnail is scaled correctly
                    thumbnail = thumbnail.scaled(100, 75, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            else:
                thumbnail = QPixmap(new_file)
                if thumbnail.isNull():
                    print(f"❌ Error: Could not load image {new_file}. Using default placeholder.")
                    thumbnail = QPixmap(100, 75)
                    thumbnail.fill(Qt.gray)
                else:
                    thumbnail = thumbnail.scaled(100, 75, Qt.KeepAspectRatio, Qt.SmoothTransformation)

            prevLabel = ClickablePreviewLabel(new_file, media_type, self)
            prevLabel.setPixmap(thumbnail)
            prevLabel.setToolTip(os.path.basename(new_file))
            self.clip_table.setCellWidget(row, 1, prevLabel)

            # Update media type (col 2) and media file (col 3).
            self.clip_table.setItem(row, 2, QTableWidgetItem(media_type))
            self.clip_table.setItem(row, 3, QTableWidgetItem(os.path.basename(new_file)))

            # Update duration: if Video, extract real duration; if Image, use default 5 s.
            if is_video:
                try:
                    with VideoFileClip(new_file) as video_clip:
                        duration = video_clip.duration
                    print(f"DEBUG: Extracted video duration: {duration}s")
                except Exception as e:
                    print(f"DEBUG: ❌ Error extracting duration from video: {e}")
                    duration = 0.0
            else:
                duration = 5.0
            self.clip_table.setItem(row, 4, QTableWidgetItem(format_seconds(duration)))

        print(f"DEBUG: Row {row} updated successfully.")

    def get_video_thumbnail(self, video_path):
        """
        Extracts a frame from the video using ffmpeg to generate a temporary JPEG thumbnail.
        Loads the thumbnail as a QPixmap scaled to 800x450.
        Returns a QPixmap on success or None upon failure.
        """


        try:
            #print(f"DEBUG: Extracting thumbnail via ffmpeg from: {video_path}")

            # Ensure video file exists
            if not os.path.exists(video_path):
                print(f"❌ Error: File does not exist: {video_path}")
                return None

            # Create a temporary file that will hold the JPEG thumbnail
            temp_file = tempfile.NamedTemporaryFile(suffix='.jpg', delete=False)
            temp_path = temp_file.name
            temp_file.close()  # Close the file so ffmpeg can write to it

            # Run ffmpeg to extract the first frame at a higher resolution
            command = ["ffmpeg", "-y", "-i", video_path, "-ss", "00:00:01", "-vframes", "1", "-s", "1280x720",
                       temp_path]
            subprocess.check_call(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

            # Load the temporary JPEG into a QPixmap.
            pixmap = QPixmap(temp_path)
            os.remove(temp_path)  # Clean up temporary file immediately.

            if pixmap.isNull():
                print(f"❌ Error: QPixmap could not load the thumbnail from {video_path}.")
                return None

            # Scale the image to the desired size (800x450). Adjust flags as desired.
            scaled_pix = pixmap.scaled(800, 450, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            #print(f"DEBUG: ffmpeg thumbnail successfully created (size: {scaled_pix.size()}).")
            return scaled_pix

        except subprocess.CalledProcessError as cpe:
            print(f"❌ Error: ffmpeg failed for {video_path} with error: {cpe}")
            return None
        except Exception as e:
            print(f"❌ Exception generating thumbnail for {video_path}: {e}")
            return None

    def update_media_preview(self, row, file_path, media_type):
        """
        Update the preview for the given row in the table.
        """
        try:
            preview_label = ClickablePreviewLabel(file_path, media_type, self)

            if media_type == "Video":
                thumbnail = self.get_video_thumbnail(file_path)
                if thumbnail is None or thumbnail.isNull():
                    print(f"❌ Error: Could not generate thumbnail for {file_path}. Using default icon.")
                    thumbnail = QPixmap(100, 75)
                    thumbnail.fill(Qt.gray)
            else:
                thumbnail = QPixmap(file_path)
                if thumbnail.isNull():
                    print(f"❌ Error: Could not load image {file_path}. Using default placeholder.")
                    thumbnail = QPixmap(100, 75)
                    thumbnail.fill(Qt.gray)
                else:
                    thumbnail = thumbnail.scaled(100, 75, Qt.KeepAspectRatio, Qt.SmoothTransformation)

            preview_label.setPixmap(thumbnail)
            preview_label.setToolTip(os.path.basename(file_path))
            # Force the GUI widget to refresh.
            preview_label.update()
            self.clip_table.setCellWidget(row, 1, preview_label)
            print(f"✅ Successfully updated preview for row {row}: {file_path}")

        except Exception as e:
            print(f"❌ Exception in update_media_preview: {e}")

    # Slot to replace a selected clip.

    def replace_selected_clip(self):
        """
        Replaces a media/image or music file for the selected row.
        Deletes the old file (if under our managed folders), copies the new one in,
        updates lists and UI.
        """
        texts = get_texts_for_current_language(self.target_language_input)
        progress = self.show_progress(
            texts.get("replacing_media", DEFAULT_STRINGS["replacing_media"])
        )
        try:
            row = self.clip_table.currentRow()
            if row < 0:
                QMessageBox.warning(
                    self,
                    texts.get("warning_title", "⚠️ Warning"),
                    texts.get("select_cell_warning", "Please select a media cell to replace.")
                )
                return

            # Determine if we're replacing music or media
            music_chk = self.clip_table.cellWidget(row, 7)
            is_music = bool(music_chk and music_chk.isChecked())

            # Grab the old path from the correct list
            old_path = None
            if is_music:
                if hasattr(self, "music_clips") and row < len(self.music_clips):
                    old_path = self.music_clips[row]
            else:
                if hasattr(self, "media_clips") and row < len(self.media_clips):
                    old_path = self.media_clips[row]

            # Ask user for new file
            file_filter = (
                "Music Files (*.mp3 *.wav *.flac *.aac *.ogg)"
                if is_music else
                "Media Files (*.mp4 *.avi *.mov *.mkv *.jpg *.jpeg *.png)"
            )
            src, _ = QFileDialog.getOpenFileName(
                self,
                texts.get("select_new_media", "Select New Media File"),
                "",
                file_filter
            )
            if not src:
                return
            src = os.path.normpath(src)

            # Resolve and normalize target folder
            folder = self.music_folder if is_music else self.video_image_folder
            if not isinstance(folder, str) and hasattr(folder, "text"):
                folder = folder.text()
            folder = os.path.normpath(folder)
            os.makedirs(folder, exist_ok=True)

            # Build a unique destination path for the new file
            base, ext = os.path.splitext(os.path.basename(src))
            dest = os.path.join(folder, base + ext)
            count = 1
            while os.path.exists(dest):
                dest = os.path.join(folder, f"{base}_{count}{ext}")
                count += 1

            # ---- NEW: delete the old file from disk if it lives under our folder ----
            if isinstance(old_path, str):
                old_norm = os.path.normpath(old_path)
                # check via commonpath that old_norm is inside folder
                try:
                    if os.path.commonpath([folder, old_norm]) == folder and os.path.isfile(old_norm):
                        os.remove(old_norm)
                except Exception as e:
                    print(f"DEBUG: could not delete old file {old_norm}: {e}")
            # -------------------------------------------------------------------------

            # Copy the new file into place
            shutil.copy2(src, dest)

            # Update the internal lists
            if is_music:
                # ensure list is long enough
                if not hasattr(self, "music_clips") or self.music_clips is None:
                    self.music_clips = [None] * self.clip_table.rowCount()
                self.music_clips[row] = dest
            else:
                if not hasattr(self, "media_clips") or self.media_clips is None:
                    self.media_clips = [None] * self.clip_table.rowCount()
                self.media_clips[row] = dest

                # If it’s a video, recalc duration
                if ext.lower() in (".mp4", ".avi", ".mov", ".mkv"):
                    try:
                        dur = get_video_duration(dest)
                    except:
                        dur = 0.0
                    if not hasattr(self, "media_durations") or self.media_durations is None:
                        self.media_durations = [0.0] * self.clip_table.rowCount()
                    self.media_durations[row] = dur
                    self.clip_table.setItem(row, 4, QTableWidgetItem(format_seconds(dur)))

            # Refresh the row and UI
            self.update_table_row(row, dest, "Music" if is_music else "Video")
            if music_chk:
                music_chk.setChecked(False)
            vid_chk = self.clip_table.cellWidget(row, 0)
            if vid_chk:
                vid_chk.setChecked(False)

            self.update_table_timings()
            self.update_all_thumbnails()
            self.populate_clip_table()

        except Exception as e:
            QMessageBox.critical(
                self,
                texts.get("error_title", "❌ Error"),
                texts.get("error_replacing_media",
                          "An error occurred while replacing media: {}").format(e)
            )
        finally:
            #progress.close()
            self._cleanup_progress()

    def unload_media_player(self):
        if getattr(self, "player", None) is not None:
            # if you're currently playing a preview or have any loaded media:
            if self.player.state() != QMediaPlayer.StoppedState:
                self.player.stop()
            # Now remove references so the OS frees the file lock
            self.player.setMedia(None)
            self.player.deleteLater()
            self.player = None

    def delete_selected_items(self):
        """
        Deletes any checked‐off media or music files from disk (if in our managed folders),
        removes them from the underlying lists, removes those rows from the table
        (so thumbnails go away!), then refreshes timings/thumbnails for any remainder.
        """
        self.unload_media_player()  # Make sure no active MediaPlayer locks these files

        texts = get_texts_for_current_language(self.target_language_input)
        progress = self.show_progress(texts.get("deleting_clips", DEFAULT_STRINGS["deleting_clips"]))

        try:
            vf = self.video_image_folder
            if not isinstance(vf, str) and hasattr(vf, "text"):
                vf = vf.text()
            vf = os.path.normpath(vf)

            mf = self.music_folder
            if not isinstance(mf, str) and hasattr(mf, "text"):
                mf = mf.text()
            mf = os.path.normpath(mf)

            # 1) Gather rows + store the paths
            media_rows = []
            music_rows = []
            media_paths = []
            music_paths = []

            for r in range(self.clip_table.rowCount()):
                # If media checkbox is checked
                widget0 = self.clip_table.cellWidget(r, 0)
                if widget0 and hasattr(widget0, "isChecked") and widget0.isChecked():
                    media_rows.append(r)
                    if r < len(self.media_clips):
                        media_paths.append(self.media_clips[r])
                    else:
                        media_paths.append(None)

                # If music checkbox is checked
                widget7 = self.clip_table.cellWidget(r, 7)
                if widget7 and hasattr(widget7, "isChecked") and widget7.isChecked():
                    music_rows.append(r)
                    if r < len(self.music_clips):
                        music_paths.append(self.music_clips[r])
                    else:
                        music_paths.append(None)

            if not media_rows and not music_rows:
                QMessageBox.information(
                    self,
                    texts.get("delete_title", "Delete Items"),
                    texts.get("nothing_to_delete", "No media or music selected for deletion.")
                )
                return

            # 2) Remove table rows & internal list entries
            all_rows = sorted(media_rows + music_rows, reverse=True)
            for row_index in all_rows:
                if 0 <= row_index < self.clip_table.rowCount():
                    self.clip_table.removeRow(row_index)

            for r in sorted(media_rows, reverse=True):
                if 0 <= r < len(self.media_clips):
                    del self.media_clips[r]

            for r in sorted(music_rows, reverse=True):
                if 0 <= r < len(self.music_clips):
                    del self.music_clips[r]

            # Give the GUI a moment to finish any ongoing thumbnail generation
            QCoreApplication.processEvents()

            # 3) Delete files on disk (after they are removed from UI references)
            for i, row_index in enumerate(media_rows):
                path = media_paths[i]
                if path and os.path.exists(path):
                    try_delete_file(path, attempts=3, delay=1)

            for i, row_index in enumerate(music_rows):
                path = music_paths[i]
                if path and os.path.exists(path):
                    try_delete_file(path, attempts=3, delay=1)

            # 4) Now re-populate the table for any remaining entries
            self.populate_clip_table()
            self.rebuild_durations_cache_and_update_timings()
            self.update_all_thumbnails()

        except Exception as e:
            QMessageBox.critical(
                self,
                texts.get("error_title", "❌ Error"),
                texts.get("error_deleting_clips", "Error deleting clips: {}").format(e)
            )
        finally:
            self._cleanup_progress()

    def rebuild_durations_cache_and_update_timings(self):
        """Rebuilds durations for media, updates the timing columns."""
        if hasattr(self, "media_clips") and self.media_clips is not None:
            self.media_durations = []
            row_count = self.clip_table.rowCount()
            for row in range(row_count):
                # For video rows, try to get the duration, otherwise default to 0.
                type_item = self.clip_table.item(row, 2)
                media_type = type_item.text().strip().lower() if type_item else ""
                if media_type == "video":
                    if row < len(self.media_clips) and self.media_clips[row]:
                        file_path = (self.media_clips[row] if isinstance(self.media_clips[row], str)
                                     else getattr(self.media_clips[row], "filename", str(self.media_clips[row])))
                        try:
                            duration = get_video_duration(file_path)
                        except Exception as e:
                            print(f"❌ Error recalculating duration for row {row}: {e}")
                            duration = 0.0
                        self.media_durations.append(duration)
                    else:
                        self.media_durations.append(0.0)
                else:
                    item = self.clip_table.item(row, 4)
                    m_dur_text = item.text().strip() if item else "0:00"
                    parts = m_dur_text.split(":")
                    if len(parts) == 2:
                        try:
                            mmin, msec = map(int, parts)
                            duration = mmin * 60 + msec
                        except Exception as e:
                            print(f"❌ Duration parsing error for row {row}: {e}")
                            duration = 0.0
                    else:
                        duration = 0.0
                    self.media_durations.append(duration)
        self.update_table_timings()

    def shift_and_clear_rows(self, rows_to_delete, columns, is_media=False):
        """
        Shift and clear specified columns for the given rows.
        """
        for row in sorted(rows_to_delete):
            for r in range(row, self.clip_table.rowCount() - 1):
                for col in columns:
                    next_item = self.clip_table.item(r + 1, col)
                    if next_item:
                        self.clip_table.setItem(r, col, QTableWidgetItem(next_item.text()))
                    else:
                        self.clip_table.setItem(r, col, QTableWidgetItem(""))

                # Handle widgets separately if needed
                if is_media and 1 in columns:  # Media Preview
                    next_widget = self.clip_table.cellWidget(r + 1, 1)
                    if next_widget:
                        self.clip_table.setCellWidget(r, 1, next_widget)
                    else:
                        self.clip_table.setItem(r, 1, QTableWidgetItem(""))

                if 8 in columns:  # Music Preview
                    next_widget = self.clip_table.cellWidget(r + 1, 8)
                    if next_widget:
                        self.clip_table.setCellWidget(r, 8, next_widget)
                    else:
                        self.clip_table.setItem(r, 8, QTableWidgetItem(""))

            # Clear the last row's specified columns
            for col in columns:
                self.clip_table.setItem(self.clip_table.rowCount() - 1, col, QTableWidgetItem(""))

            # Remove widgets from the last row if needed
            if is_media and 1 in columns:
                self.clip_table.removeCellWidget(self.clip_table.rowCount() - 1, 1)
            if 8 in columns:
                self.clip_table.removeCellWidget(self.clip_table.rowCount() - 1, 8)

    def get_pixmap_from_base64(base64_string):
        """Convert a base64 string to a QPixmap."""
        image_data = base64.b64decode(base64_string)
        pixmap = QPixmap()
        pixmap.loadFromData(image_data)
        return pixmap

    def populate_clip_table_Prev(self):
        """
        Populates the clip table with 16 columns:
          0: Select(Media) – composite widget (checkbox + drag icon)
          1: Media Preview
          2: Media Type
          3: Media File
          4: Media Dur
          5: Media Start
          6: Media End
          7: Select(Music)
          8: Music Preview
          9: Music File
         10: Music Dur
         11: Music Start
         12: Music End
         13: Subtitle
         14: SubStart
         15: SubEnd
        """
        print("DEBUG: Inside populate_clip_table()")

        # Forcibly convert folder references to strings, no matter what they are:
        try:
            self.video_image_folder = safe_str(self.video_image_folder)
            self.music_folder = safe_str(self.music_folder)
        except Exception as e:
            print(f"❌ Exception converting folder references to string in populate_clip_table: {e}")

        texts = get_texts_for_current_language(self.target_language_input)

        # 1) Setup headers
        headers = texts.get("clip_table_headers", DEFAULT_STRINGS["clip_table_headers"])
        self.clip_table.setColumnCount(len(headers))
        self.clip_table.setHorizontalHeaderLabels(headers)
        for col in range(len(headers)):
            hdr_item = self.clip_table.horizontalHeaderItem(col)
            if col in (0, 1, 7, 8):
                hdr_item.setBackground(QBrush(QColor("lightgreen")))
                hdr_item.setToolTip(
                    texts.get("editable_field_tooltip", DEFAULT_STRINGS["editable_field_tooltip"])
                )
            else:
                hdr_item.setBackground(QBrush(QColor("lightgrey")))
                hdr_item.setToolTip(
                    texts.get("readonly_field_tooltip", DEFAULT_STRINGS["readonly_field_tooltip"])
                )

        # 2) Prepare source lists
        media_clips = list(self.media_clips)
        music_clips = list(self.music_clips)
        subtitles = list(self.wip_subtitles)

        max_rows = max(len(media_clips), len(music_clips), len(subtitles))

        # Add 5 extra rows for potential "Add Media/Music" usage
        EXTRA_ROWS = 5
        max_rows += EXTRA_ROWS
        self.clip_table.setRowCount(max_rows)

        # Pad out lists so they match row count
        media_clips += [""] * (max_rows - len(media_clips))
        music_clips += [""] * (max_rows - len(music_clips))
        subtitles += [""] * (max_rows - len(subtitles))

        # 3) Double the row height
        vhdr = self.clip_table.verticalHeader()
        if not hasattr(self, "_base_row_height"):
            self._base_row_height = vhdr.defaultSectionSize()
        vhdr.setDefaultSectionSize(self._base_row_height * 2)

        # 4) Icons & durations
        video_exts = (".mp4", ".avi", ".mov", ".mkv")
        video_icon = get_pixmap_from_base64(video_icon_base64)
        music_icon = get_pixmap_from_base64(music_icon_base64)
        media_durations = []
        music_durations = []

        for row in range(max_rows):
            # ── MEDIA (cols 0–6)
            clip = media_clips[row]
            if clip:
                is_video = clip.lower().endswith(video_exts)
                mtype = "Video" if is_video else "Image"

                # col 0: checkbox + draggable
                self.clip_table.setCellWidget(row, 0, MediaDraggableWidget(clip))

                # col 1: preview thumbnail
                if is_video:
                    thumb = self.get_video_thumbnail(clip) or video_icon
                else:
                    pix = QPixmap(clip)
                    thumb = pix if not pix.isNull() else QPixmap(100, 75)

                thumb = thumb.scaled(100, 75, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                lbl = ClickablePreviewLabel(clip, mtype, self.clip_table)
                lbl.setPixmap(thumb)
                lbl.setToolTip(os.path.basename(clip))
                self.clip_table.setCellWidget(row, 1, lbl)

                # col 2: translated type
                trans = texts.get(mtype.lower(), mtype)
                item = QTableWidgetItem(trans)
                item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 2, item)

                # col 3: filename
                fname = os.path.basename(clip)
                item = QTableWidgetItem(fname)
                item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 3, item)

                # col 4: duration
                if is_video:
                    try:
                        dur = get_video_duration(clip)
                    except:
                        dur = 0.0
                else:
                    dur = 5.0  # default for images
                media_durations.append(dur)
                di = QTableWidgetItem(format_seconds(dur))
                di.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 4, di)

            else:
                # empty slot → “Add Media” button
                btn = QPushButton(texts.get("add_media_btn", DEFAULT_STRINGS["add_media_btn"]))
                btn.setStyleSheet(BTN_STYLE)
                btn.clicked.connect(lambda _, r=row: self.insert_media_file(r))
                self.clip_table.setCellWidget(row, 0, btn)

                ph = QTableWidgetItem(texts.get("no_file_placeholder", DEFAULT_STRINGS["no_file_placeholder"]))
                ph.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 1, ph)
                for c in (2, 3, 4):
                    txt = "" if c != 3 else texts.get("none_text", DEFAULT_STRINGS["none_text"])
                    it = QTableWidgetItem(txt)
                    it.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                    self.clip_table.setItem(row, c, it)
                media_durations.append(0.0)

            # ── MUSIC (cols 7–12)
            mclip = music_clips[row]
            if mclip:
                # col 7: checkbox
                chk = QCheckBox()
                self.clip_table.setCellWidget(row, 7, chk)

                # col 8: preview
                thumb = music_icon.scaled(100, 75, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                lbl = ClickablePreviewLabel(mclip, "Music", self.clip_table)
                lbl.setPixmap(thumb)
                lbl.setToolTip(os.path.basename(mclip))
                self.clip_table.setCellWidget(row, 8, lbl)

                # col 9: filename
                item = QTableWidgetItem(os.path.basename(mclip))
                item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 9, item)

                # col 10: duration
                try:
                    md = get_audio_duration(mclip)
                except:
                    md = 0.0
                music_durations.append(md)
                di = QTableWidgetItem(format_seconds(md))
                di.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 10, di)
            else:
                btn = QPushButton(texts.get("add_music_btn", DEFAULT_STRINGS["add_music_btn"]))
                btn.setStyleSheet(BTN_STYLE)
                btn.clicked.connect(lambda _, r=row: self.insert_music_file(r))
                self.clip_table.setCellWidget(row, 7, btn)

                ph = QTableWidgetItem(texts.get("no_file_placeholder", DEFAULT_STRINGS["no_file_placeholder"]))
                ph.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 8, ph)
                for c in (9, 10):
                    txt = "" if c != 10 else "0:00"
                    it = QTableWidgetItem(txt)
                    it.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                    self.clip_table.setItem(row, c, it)
                music_durations.append(0.0)

        # 5) Cumulative media times (cols 5–6)
        cum = 0.0
        for r in range(max_rows):
            si = QTableWidgetItem(format_seconds(cum))
            si.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 5, si)
            cum += media_durations[r]
            ei = QTableWidgetItem(format_seconds(cum))
            ei.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 6, ei)

        # 6) Cumulative music times (cols 11–12)
        cum = 0.0
        for r in range(max_rows):
            si = QTableWidgetItem(format_seconds(cum))
            si.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 11, si)
            cum += music_durations[r]
            ei = QTableWidgetItem(format_seconds(cum))
            ei.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 12, ei)

        # 7) Subtitles (cols 13–15)
        for r in range(max_rows):
            if r < len(subtitles):
                ent = subtitles[r]
                if isinstance(ent, (list, tuple)) and len(ent) == 3:
                    st, et, txt = ent
                else:
                    st, et, txt = (0.0, 0.0, "")
            else:
                st, et, txt = (0.0, 0.0, "")
            it_txt = QTableWidgetItem(txt)
            it_txt.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 13, it_txt)
            it_st = QTableWidgetItem(format_seconds(st))
            it_st.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 14, it_st)
            it_et = QTableWidgetItem(format_seconds(et))
            it_et.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 15, it_et)

        # 8) Adjust header & column widths
        header = self.clip_table.horizontalHeader()
        header.setStretchLastSection(False)
        for c in range(self.clip_table.columnCount()):
            if c not in (3, 9):
                header.setSectionResizeMode(c, QHeaderView.ResizeToContents)

        # Fixed width for cols 3 & 9: ~40 characters + padding
        fm = self.clip_table.fontMetrics()
        avg_char_w = fm.averageCharWidth()
        MAX_CHARS = 20
        padding = 5
        fixed_w = int(avg_char_w * MAX_CHARS + padding)

        self.clip_table.setColumnWidth(3, fixed_w)
        self.clip_table.setColumnWidth(9, fixed_w)
        header.setSectionResizeMode(3, QHeaderView.Fixed)
        header.setSectionResizeMode(9, QHeaderView.Fixed)

        print("DEBUG: Finished populate_clip_table()")

    def populate_clip_table(self):
        """
        Populates the clip table with 16 columns:
          0: Select(Media) – composite widget (checkbox + drag icon)
          1: Media Preview
          2: Media Type
          3: Media File
          4: Media Dur
          5: Media Start
          6: Media End
          7: Select(Music)
          8: Music Preview
          9: Music File
         10: Music Dur
         11: Music Start
         12: Music End
         13: Subtitle
         14: SubStart
         15: SubEnd
        """
        print("DEBUG: Inside populate_clip_table()")

        # Forcibly convert folder references to strings, no matter what they are:
        try:
            self.video_image_folder = safe_str(self.video_image_folder)
            self.music_folder = safe_str(self.music_folder)
        except Exception as e:
            print(f"❌ Exception converting folder references to string in populate_clip_table: {e}")

        texts = get_texts_for_current_language(self.target_language_input)

        # 1) Setup headers
        headers = texts.get("clip_table_headers", DEFAULT_STRINGS["clip_table_headers"])
        self.clip_table.setColumnCount(len(headers))
        self.clip_table.setHorizontalHeaderLabels(headers)
        for col in range(len(headers)):
            hdr_item = self.clip_table.horizontalHeaderItem(col)
            if col in (0, 1, 7, 8):
                hdr_item.setBackground(QBrush(QColor("lightgreen")))
                hdr_item.setToolTip(
                    texts.get("editable_field_tooltip", DEFAULT_STRINGS["editable_field_tooltip"])
                )
            else:
                hdr_item.setBackground(QBrush(QColor("lightgrey")))
                hdr_item.setToolTip(
                    texts.get("readonly_field_tooltip", DEFAULT_STRINGS["readonly_field_tooltip"])
                )

        # 2) Prepare source lists
        media_clips = list(self.media_clips)
        music_clips = list(self.music_clips)
        subtitles = list(self.wip_subtitles)

        max_rows = max(len(media_clips), len(music_clips), len(subtitles))

        # Add 5 extra rows for potential "Add Media/Music" usage
        EXTRA_ROWS = 5
        max_rows += EXTRA_ROWS
        self.clip_table.setRowCount(max_rows)

        # Pad out lists so they match row count
        media_clips += [""] * (max_rows - len(media_clips))
        music_clips += [""] * (max_rows - len(music_clips))
        subtitles += [""] * (max_rows - len(subtitles))

        # 3) Double the row height
        vhdr = self.clip_table.verticalHeader()
        if not hasattr(self, "_base_row_height"):
            self._base_row_height = vhdr.defaultSectionSize()
        vhdr.setDefaultSectionSize(self._base_row_height * 2)

        # 4) Icons & durations
        video_exts = (".mp4", ".avi", ".mov", ".mkv")
        video_icon = get_pixmap_from_base64(video_icon_base64)
        music_icon = get_pixmap_from_base64(music_icon_base64)
        media_durations = []
        music_durations = []

        for row in range(max_rows):
            # ── MEDIA (cols 0–6)
            clip = media_clips[row]
            if clip:
                is_video = clip.lower().endswith(video_exts)
                mtype = "Video" if is_video else "Image"

                # col 0: checkbox + draggable
                self.clip_table.setCellWidget(row, 0, MediaDraggableWidget(clip))

                # col 1: preview thumbnail
                if is_video:
                    thumb = self.get_video_thumbnail(clip) or video_icon
                else:
                    pix = QPixmap(clip)
                    thumb = pix if not pix.isNull() else QPixmap(100, 75)

                thumb = thumb.scaled(100, 75, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                lbl = ClickablePreviewLabel(clip, mtype, self.clip_table)
                lbl.setPixmap(thumb)
                lbl.setToolTip(os.path.basename(clip))
                self.clip_table.setCellWidget(row, 1, lbl)

                # col 2: translated type
                trans = texts.get(mtype.lower(), mtype)
                item = QTableWidgetItem(trans)
                item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 2, item)

                # col 3: filename
                fname = os.path.basename(clip)
                item = QTableWidgetItem(fname)
                item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 3, item)

                # col 4: duration
                if is_video:
                    try:
                        dur = get_video_duration(clip)
                    except:
                        dur = 0.0
                else:
                    dur = 5.0  # default for images
                media_durations.append(dur)
                di = QTableWidgetItem(format_seconds(dur))
                di.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 4, di)

            else:
                # empty slot → “Add Media” button
                btn = QPushButton(texts.get("add_media_btn", DEFAULT_STRINGS["add_media_btn"]))
                btn.setStyleSheet(BTN_STYLE)
                btn.clicked.connect(lambda _, r=row: self.insert_media_file(r))
                self.clip_table.setCellWidget(row, 0, btn)

                ph = QTableWidgetItem(texts.get("no_file_placeholder", DEFAULT_STRINGS["no_file_placeholder"]))
                ph.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 1, ph)
                for c in (2, 3, 4):
                    txt = "" if c != 3 else texts.get("none_text", DEFAULT_STRINGS["none_text"])
                    it = QTableWidgetItem(txt)
                    it.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                    self.clip_table.setItem(row, c, it)
                media_durations.append(0.0)

            # ── MUSIC (cols 7–12)
            mclip = music_clips[row]
            if mclip:
                # col 7: checkbox
                chk = QCheckBox()
                self.clip_table.setCellWidget(row, 7, chk)

                # col 8: preview
                thumb = music_icon.scaled(100, 75, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                lbl = ClickablePreviewLabel(mclip, "Music", self.clip_table)
                lbl.setPixmap(thumb)
                lbl.setToolTip(os.path.basename(mclip))
                self.clip_table.setCellWidget(row, 8, lbl)

                # col 9: filename
                item = QTableWidgetItem(os.path.basename(mclip))
                item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 9, item)

                # col 10: duration
                try:
                    md = get_audio_duration(mclip)
                except:
                    md = 0.0
                music_durations.append(md)
                di = QTableWidgetItem(format_seconds(md))
                di.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 10, di)
            else:
                btn = QPushButton(texts.get("add_music_btn", DEFAULT_STRINGS["add_music_btn"]))
                btn.setStyleSheet(BTN_STYLE)
                btn.clicked.connect(lambda _, r=row: self.insert_music_file(r))
                self.clip_table.setCellWidget(row, 7, btn)

                ph = QTableWidgetItem(texts.get("no_file_placeholder", DEFAULT_STRINGS["no_file_placeholder"]))
                ph.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 8, ph)
                for c in (9, 10):
                    txt = "" if c != 10 else "0:00"
                    it = QTableWidgetItem(txt)
                    it.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                    self.clip_table.setItem(row, c, it)
                music_durations.append(0.0)

        # 5) Cumulative media times (cols 5–6)
        cum = 0.0
        for r in range(max_rows):
            si = QTableWidgetItem(format_seconds(cum))
            si.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 5, si)
            cum += media_durations[r]
            ei = QTableWidgetItem(format_seconds(cum))
            ei.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 6, ei)

        # 6) Cumulative music times (cols 11–12)
        cum = 0.0
        for r in range(max_rows):
            si = QTableWidgetItem(format_seconds(cum))
            si.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 11, si)
            cum += music_durations[r]
            ei = QTableWidgetItem(format_seconds(cum))
            ei.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 12, ei)

        # 7) Subtitles (cols 13–15)
        for r in range(max_rows):
            if r < len(subtitles):
                ent = subtitles[r]
                if isinstance(ent, (list, tuple)) and len(ent) == 3:
                    st, et, txt = ent
                else:
                    st, et, txt = (0.0, 0.0, "")
            else:
                st, et, txt = (0.0, 0.0, "")
            it_txt = QTableWidgetItem(txt)
            it_txt.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 13, it_txt)
            it_st = QTableWidgetItem(format_seconds(st))
            it_st.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 14, it_st)
            it_et = QTableWidgetItem(format_seconds(et))
            it_et.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 15, it_et)

        # 8) Adjust header & column widths
        header = self.clip_table.horizontalHeader()
        header.setStretchLastSection(False)
        for c in range(self.clip_table.columnCount()):
            if c not in (3, 9):
                header.setSectionResizeMode(c, QHeaderView.ResizeToContents)

        # Fixed width for cols 3 & 9: ~40 characters + padding
        fm = self.clip_table.fontMetrics()
        avg_char_w = fm.averageCharWidth()
        MAX_CHARS = 20
        padding = 5
        fixed_w = int(avg_char_w * MAX_CHARS + padding)

        self.clip_table.setColumnWidth(3, fixed_w)
        self.clip_table.setColumnWidth(9, fixed_w)
        header.setSectionResizeMode(3, QHeaderView.Fixed)
        header.setSectionResizeMode(9, QHeaderView.Fixed)


        header = self.clip_table.horizontalHeader()
        for col in range(self.clip_table.columnCount()):
            if col in (3, 9, 13):  # Columns likely to contain long text
                header.setSectionResizeMode(col, QHeaderView.Stretch)
            else:
                header.setSectionResizeMode(col, QHeaderView.ResizeToContents)

        print("DEBUG: Finished populate_clip_table()")


    def update_all_thumbnails(self):
        """
        Updates thumbnails for all media files in the media_clips list.
        """
        for row, file_path in enumerate(self.media_clips):
            if file_path:  # Ensure the file path is valid
                thumbnail = self.get_video_thumbnail(file_path) if file_path.endswith(
                    ('.mp4', '.avi', '.mov', '.mkv')) else QPixmap(file_path)
                if thumbnail is None or thumbnail.isNull():
                    print(f"❌ Error: Could not generate thumbnail for {file_path}. Using default icon.")
                    thumbnail = QPixmap(100, 75)
                    thumbnail.fill(Qt.gray)
                else:
                    thumbnail = thumbnail.scaled(100, 75, Qt.KeepAspectRatio, Qt.SmoothTransformation)

                # Update the preview label in the table
                preview_label = ClickablePreviewLabel(file_path, "Video" if file_path.endswith(
                    ('.mp4', '.avi', '.mov', '.mkv')) else "Image", self)
                preview_label.setPixmap(thumbnail)
                preview_label.setToolTip(os.path.basename(file_path))
                self.clip_table.setCellWidget(row, 1, preview_label)

        print("✅ All thumbnails updated.")

    def insert_media_file(self, row):
        """
        Opens a dialog to pick a video/image, copies it into the normalized
        self.video_image_folder, and updates self.media_clips.
        """
        texts = get_texts_for_current_language(self.target_language_input)
        progress = self.show_progress(texts.get("inserting_media", DEFAULT_STRINGS["inserting_media"]))
        try:
            # 1) Figure out where to store media
            vf = self.video_image_folder
            if not isinstance(vf, str) and hasattr(vf, "text"):
                vf = vf.text()
            vf = os.path.normpath(vf)
            os.makedirs(vf, exist_ok=True)

            # 2) Pick source file
            file_filter = "Media Files (*.mp4 *.avi *.mov *.mkv *.jpg *.jpeg *.png)"
            src, _ = QFileDialog.getOpenFileName(self,
                                                 texts.get("select_media", "Select Media File"),
                                                 "", file_filter
                                                 )
            if not src:
                return
            src = os.path.normpath(src)

            # 3) Build unique destination path
            base, ext = os.path.splitext(os.path.basename(src))
            dest = os.path.join(vf, f"{base}{ext}")
            count = 1
            while os.path.exists(dest):
                dest = os.path.join(vf, f"{base}_{count}{ext}")
                count += 1

            # 4) Copy and record
            shutil.copy2(src, dest)
            if not hasattr(self, "media_clips") or self.media_clips is None:
                self.media_clips = []
            while len(self.media_clips) <= row:
                self.media_clips.append(None)
            self.media_clips[row] = dest

            # 5) Refresh UI
            self.populate_clip_table()
            self.update_all_thumbnails()

        except Exception as e:
            QMessageBox.critical(
                self,
                texts.get("error_title", "❌ Error"),
                texts.get("error_inserting_media", "Error inserting media: {}").format(e)
            )
        finally:
            #progress.close()
            self._cleanup_progress()

    def insert_music_file(self, row):
        """
        Opens a dialog to pick a music file, copies it into the normalized
        self.music_folder, and updates self.music_clips.
        """
        texts = get_texts_for_current_language(self.target_language_input)
        progress = self.show_progress(texts.get("inserting_music", DEFAULT_STRINGS["inserting_music"]))
        try:
            # 1) Resolve music folder
            mf = self.music_folder
            if not isinstance(mf, str) and hasattr(mf, "text"):
                mf = mf.text()
            mf = os.path.normpath(mf)
            os.makedirs(mf, exist_ok=True)

            # 2) Pick source file
            file_filter = "Music Files (*.mp3 *.wav *.flac *.aac *.ogg)"
            src, _ = QFileDialog.getOpenFileName(self,
                                                 texts.get("select_music", "Select Music File"),
                                                 "", file_filter
                                                 )
            if not src:
                return
            src = os.path.normpath(src)

            # 3) Unique destination
            base, ext = os.path.splitext(os.path.basename(src))
            dest = os.path.join(mf, f"{base}{ext}")
            count = 1
            while os.path.exists(dest):
                dest = os.path.join(mf, f"{base}_{count}{ext}")
                count += 1

            # 4) Copy and record
            shutil.copy2(src, dest)
            if not hasattr(self, "music_clips") or self.music_clips is None:
                self.music_clips = []
            while len(self.music_clips) <= row:
                self.music_clips.append(None)
            self.music_clips[row] = dest

            # 5) Refresh UI
            self.populate_clip_table()

        except Exception as e:
            QMessageBox.critical(
                self,
                texts.get("error_title", "❌ Error"),
                texts.get("error_inserting_music", "Error inserting music: {}").format(e)
            )
        finally:
            #progress.close()
            self._cleanup_progress()

    def get_audio_duration(file_path):
        """
        Returns the duration of an audio file in seconds.
        """
        try:
            audio = AudioFileClip(file_path)
            return audio.duration
        except Exception as e:
            print(f"❌ Error getting audio duration: {e}")
            return 0.0

    def update_table_timings(self):
        """
        Recalculates cumulative timings for Media (columns 5–6) and Music (columns 11–12)
        based on the durations in the table.
        For video rows (from Column 2), this function first checks for a cached duration in self.media_durations.
        If the cached duration is zero, it attempts to re-read it from the underlying media_clips list.
        Falls back on the current Column 4 value if needed.
        """
        row_count = self.clip_table.rowCount()
        media_durations = []
        music_durations = []

        for row in range(row_count):
            # Determine media type from Column 2.
            type_item = self.clip_table.item(row, 2)
            media_type = type_item.text().strip().lower() if type_item is not None else ""
            duration = 0.0

            if media_type == "video" and hasattr(self, "media_clips") and row < len(self.media_clips) and \
                    self.media_clips[row]:
                # Prefer cached duration for replaced videos.
                if hasattr(self, "media_durations") and row < len(self.media_durations) and self.media_durations[row]:
                    duration = self.media_durations[row]
                else:
                    # Fall back on computing from the file.
                    media_entry = self.media_clips[row]
                    file_path = media_entry if isinstance(media_entry, str) else getattr(media_entry, "filename",
                                                                                         str(media_entry))
                    try:
                        duration = get_video_duration(file_path)
                    except Exception as e:
                        print(f"❌ Error getting video duration for row {row}: {e}")
                        duration = 0.0
                    # Optionally cache this result.
                    if not hasattr(self, "media_durations") or self.media_durations is None:
                        self.media_durations = [0.0] * row_count
                    if row < len(self.media_durations):
                        self.media_durations[row] = duration
            else:
                # For non-video rows or if duration isn’t available, use Column 4.
                item = self.clip_table.item(row, 4)
                m_dur_text = item.text() if item is not None else "0:00"
                try:
                    mmin, msec = map(int, m_dur_text.split(":"))
                    duration = mmin * 60 + msec
                except Exception:
                    duration = 0.0

            media_durations.append(duration)

            # Read Music duration (from Column 10).
            item = self.clip_table.item(row, 10)
            mus_dur_text = item.text() if item is not None else "0:00"
            try:
                mmin, msec = map(int, mus_dur_text.split(":"))
                music_dur = mmin * 60 + msec
            except Exception:
                music_dur = 0.0
            music_durations.append(music_dur)

        # Update cumulative media timings (columns 5 and 6).
        cum_media = 0.0
        for row in range(row_count):
            self.clip_table.setItem(row, 5, QTableWidgetItem(format_seconds(cum_media)))
            cum_media += media_durations[row]
            self.clip_table.setItem(row, 6, QTableWidgetItem(format_seconds(cum_media)))

        # Update cumulative music timings (columns 11 and 12).
        cum_music = 0.0
        for row in range(row_count):
            self.clip_table.setItem(row, 11, QTableWidgetItem(format_seconds(cum_music)))
            cum_music += music_durations[row]
            self.clip_table.setItem(row, 12, QTableWidgetItem(format_seconds(cum_music)))

    # --- Modified workflow methods to store instance variables ---
    def create_video_with_audio_and_subtitles(self, video_title, subtitles, platform, video_image_folder, music_folder,
                                              output_directory):

        # Store relevant file paths as instance attributes.
        self.voiceover_file = os.path.join(output_directory, f"{video_title}_voiceover.mp3")
        self.subtitles_file = os.path.join(output_directory, f"{video_title}_subtitles.srt")
        self.final_video_file = os.path.join(output_directory, f"{video_title}_{platform}.mp4")

        video_files = sorted([os.path.join(video_image_folder, f) for f in os.listdir(video_image_folder)
                              if f.endswith(('.mp4', '.avi', '.mov'))])
        image_files = sorted([os.path.join(video_image_folder, f) for f in os.listdir(video_image_folder)
                              if f.endswith(('.jpg', '.jpeg', '.png'))])
        if not video_files and not image_files:
            self.status_text.appendPlainText(f"❌ No video or image files found in {video_image_folder}")
            return


        self.platform_settings = output_settings.get(platform, output_settings['youtube'])
        if not self.platform_settings or 'resolution' not in self.platform_settings:
            raise ValueError(f"❌ Invalid platform settings for {platform}.")
        self.resolution = self.platform_settings['resolution']

        # Process video files into clips.
        self.video_clips = []  # store media clips
        for video_file in video_files:
            try:
                video_clip = VideoFileClip(video_file)
                video_clip_resized = resize_clip(video_clip, self.resolution)
                if video_clip_resized is not None:
                    # For video clips, the filename attribute is assumed to be part of the clip
                    video_clip_resized.filename = video_file
                    self.video_clips.append(video_clip_resized)
                # IMPORTANT: close the original clip after resizing
                video_clip.close()
            except Exception as e:
                self.status_text.appendPlainText(f"❌ Error processing video file {video_file}: {e}")

        # Process image files into clips.
        for image_file in image_files:
            try:
                from PIL import Image
                with Image.open(image_file) as img:
                    img_aspect_ratio = img.width / img.height
                    target_aspect_ratio = self.resolution[0] / self.resolution[1]
                    if img_aspect_ratio > target_aspect_ratio:
                        new_width = int(self.resolution[1] * img_aspect_ratio)
                        new_height = self.resolution[1]
                    else:
                        new_width = self.resolution[0]
                        new_height = int(self.resolution[0] / img_aspect_ratio)
                    img_resized = img.resize((new_width, new_height), Image.ANTIALIAS)
                    # Save the resized image to a temporary file.
                    temp_image_path = f"{image_file}_resized.png"
                    img_resized.save(temp_image_path)
                # Create an ImageClip using the temporary file.
                image_clip = ImageClip(temp_image_path, duration=5).resize(newsize=self.resolution)
                # IMPORTANT: assign the original image file's name (or the temp image path) to an attribute.
                image_clip.filename = image_file
                self.video_clips.append(image_clip)
            except Exception as e:
                self.status_text.appendPlainText(f"❌ Error processing image file {image_file}: {e}")

        if not self.video_clips:
            self.status_text.appendPlainText("❌ No valid clips could be processed.")
            return

        # Read script and determine voiceover duration.
        script_file = os.path.join(output_directory, f"{video_title}_subtitles.txt")
        script = read_script_file(script_file)
        self.voiceover_duration = get_audio_duration(self.voiceover_file)
        if self.voiceover_duration <= 0:
            self.status_text.appendPlainText("❌ Invalid voiceover duration. Aborting.")
            return

        self.wip_subtitles = generate_subtitles_local(script, self.subtitles_file, self.voiceover_duration)
        self.subtitle_clips = []
        fontsize = 70 if self.resolution[0] >= 1280 else 48
        video_height = self.resolution[1]
        y_position = video_height * 0.75

        print(f"Inside create_video_with_audio_and_subtitles font: {font}")

        for sub in self.wip_subtitles:
            text_clip = (TextClip(sub[2], fontsize=fontsize, color='white', font=font,
                                  stroke_color='black', stroke_width=2)
                         .set_position(('center', y_position))
                         .set_duration(sub[1] - sub[0])
                         .set_start(sub[0]))
            self.subtitle_clips.append(text_clip)

        # Process Music: get music files from the folder and assign to self.music_clips.
        music_files = sorted([os.path.join(music_folder, f) for f in os.listdir(music_folder)
                              if f.endswith('.mp3')])
        if not music_files:
            self.status_text.appendPlainText("❌ No music files found; setting music clips as empty list.")
            self.music_clips = []
        else:
            self.music_clips = music_files  # For the table, we'll use the file paths

        # Populate the table with media clips, music clips, and subtitles.

        print("Before Review Content....")
        # Close any references.
        for clip in self.video_clips:
            # If it's a real video clip with a .reader
            if hasattr(clip, 'reader') and clip.reader is not None:
                if hasattr(clip.reader, 'close') and callable(clip.reader.close):
                    clip.reader.close()

            # If it has an audio reader
            if hasattr(clip, 'audio') and clip.audio and hasattr(clip.audio, 'reader'):
                if clip.audio.reader and hasattr(clip.audio.reader, 'close') and callable(clip.audio.reader.close):
                    clip.audio.reader.close()

        # Show the review notice, as before
        self.request_review_notice(callback=self.continue_video_creation)
        return

    def load_srt_file(self, srt_file):
        """ Ensures we always load the latest SRT file. """
        try:
            with open(srt_file, "r", encoding="utf-8") as file:
                return file.readlines()
        except FileNotFoundError:
            print(f"❌ SRT file not found: {srt_file}")
            return None

    def continue_video_creation_bypass(self):
        """
        Callback invoked after the user reviews the downloaded media in bypass mode.
        This method converts the instance media lists into lists of file paths (filtering out empty placeholders),
        then loads and concatenates those clips to create the final video.
        """
        texts = get_texts_for_current_language(self.target_language_input)
        try:
            # Convert self.media_clips to a list of valid file paths.
            media_file_paths = []
            for clip in self.media_clips:
                if isinstance(clip, str):
                    cp = clip.strip()
                    if cp:
                        media_file_paths.append(cp)
                elif hasattr(clip, "filename"):
                    cp = clip.filename
                    if cp and cp.strip():
                        media_file_paths.append(cp)
                else:
                    print("⚠️ Warning: Cannot determine file path for a media clip; skipping.")

            # Do the same for self.music_clips.
            music_file_paths = []
            for mf in self.music_clips:
                if isinstance(mf, str):
                    mp = mf.strip()
                    if mp:
                        music_file_paths.append(mp)
                elif hasattr(mf, "filename"):
                    mp = mf.filename
                    if mp and mp.strip():
                        music_file_paths.append(mp)
                else:
                    print("⚠️ Warning: Cannot determine file path for a music clip; skipping.")

            print("Final media list:", media_file_paths)
            print("Final music list:", music_file_paths)

            # Continue using the file paths for the final video creation.
            base_directory = self.base_directory.text()
            video_title = self.video_title_input.text() if hasattr(self, "video_title_input") else "video"
            video_image_folder = os.path.join(base_directory, "InVidFiles")
            music_folder = os.path.join(base_directory, "InMusicFiles")
            output_directory = os.path.join(base_directory, "OutFiles")

            default_platform = next(iter(output_settings))
            platform = self.platform_input.currentText().strip()
            platform_settings = output_settings.get(platform, output_settings[default_platform])
            resolution = platform_settings['resolution']
            final_video_file = os.path.join(output_directory, f"{video_title}_{platform}.mp4")

            # Build a list of video clips from media_file_paths.
            video_clips = []
            videoExtensions = {".mp4", ".avi", ".mov", ".mkv"}
            for file_path in media_file_paths:
                ext = os.path.splitext(file_path)[1].lower()
                if ext in videoExtensions:
                    try:
                        print(f"Loading video file: {file_path}")
                        clip = VideoFileClip(file_path)
                        clip_resized = resize_clip(clip, resolution)
                        if clip_resized is not None:
                            video_clips.append(clip_resized)
                        else:
                            print(f"Clip {file_path} could not be resized.")
                    except Exception as e:
                        print(f"❌ Error processing video file {file_path}: {e}")
                else:
                    # For image files, load via PIL and convert to a clip.
                    try:
                        from PIL import Image
                        with Image.open(file_path) as img:
                            img_aspect_ratio = img.width / img.height
                            target_aspect_ratio = resolution[0] / resolution[1]
                            if img_aspect_ratio > target_aspect_ratio:
                                new_width = int(resolution[1] * img_aspect_ratio)
                                new_height = resolution[1]
                            else:
                                new_width = resolution[0]
                                new_height = int(resolution[0] / img_aspect_ratio)
                            img_resized = img.resize((new_width, new_height), Image.ANTIALIAS)
                            # Save a temporary file
                            temp_image_path = file_path + "_resized.png"
                            img_resized.save(temp_image_path)
                        from moviepy.editor import ImageClip
                        clip = ImageClip(temp_image_path, duration=5).resize(newsize=resolution)
                        video_clips.append(clip)
                    except Exception as e:
                        print(f"❌ Error processing image file {file_path}: {e}")

            if not video_clips:
                print("No valid video or image clips could be processed.")
                return

            # Similarly, process music files to create a list of AudioFileClip objects:
            music_clips = []
            from moviepy.editor import AudioFileClip, concatenate_audioclips
            for file_path in music_file_paths:
                try:
                    audio_clip = AudioFileClip(file_path)
                    music_clips.append(audio_clip)
                except Exception as e:
                    print(f"❌ Error loading audio file {file_path}: {e}")

            # Concatenate video clips.
            from moviepy.editor import concatenate_videoclips, CompositeAudioClip
            final_video = concatenate_videoclips(video_clips, method="compose")
            total_duration = sum(clip.duration for clip in video_clips)
            final_video = final_video.set_duration(total_duration)

            # For music, concatenate audio clips if any. (You may wish to adjust volume etc.)
            if music_clips:
                background_music = concatenate_audioclips(music_clips)
                background_music = background_music.volumex(0.2)
                final_audio = CompositeAudioClip([background_music.set_duration(final_video.duration)])
                final_audio = final_audio.set_duration(final_video.duration)
                final_video = final_video.set_audio(final_audio)

            final_video.write_videofile(final_video_file, codec=platform_settings['codec'],
                                        audio_codec='aac', fps=platform_settings['fps'])
            self._cleanup_progress()
            #QMessageBox.information(self, "Success", "Video creation completed successfully (bypass mode).")
            QMessageBox.information(self, texts.get("success_text", DEFAULT_STRINGS["success_text"]),
                                    texts.get("video_success_bypass", DEFAULT_STRINGS["video_success_bypass"]))

            texts.get("video_success_bypass", DEFAULT_STRINGS["video_success_bypass"])

        except Exception as e:
            print(f"❌ Error in bypass finalization: {e}")

    def continue_video_creation(self):

        texts = get_texts_for_current_language(self.target_language_input)
        print("Inside continue_video_creation and Before update_table_timings.")
        self.update_table_timings()  # refresh timings from the table
        print("After update_table_timings.")
        #self.status_text.appendPlainText("User confirmed review; continuing video creation...")
        print("User confirmed review; continuing video creation...")

        import time
        time.sleep(1)  # slight delay

        # Use self.subtitles_file if available; otherwise, build a default SRT file path.
        if hasattr(self, "subtitles_file") and self.subtitles_file:
            srt_file_path = self.subtitles_file
        else:
            # Ensure you are getting the text from QLineEdit
            output_directory_text = self.output_directory.text().strip()  # Correctly retrieve the text
            srt_file_path = os.path.join(output_directory_text,
                                         f"{self.video_title_input.text().strip()}_subtitles.srt")
        print(f"📂 Loading latest subtitles from {srt_file_path}")
        try:
            subtitles = self.load_subtitles(srt_file_path)
        except Exception as e:
            print(f"❌ Exception loading subtitles: {e}")
            return
        if not subtitles:
            print("❌ Error: No subtitles found.")
            return

        # Convert self.media_clips into a list of file paths.
        media_file_paths = []
        for clip in self.media_clips:
            if isinstance(clip, str):
                media_file_paths.append(clip)
            elif hasattr(clip, "filename"):
                media_file_paths.append(clip.filename)
            else:
                print("⚠️ Warning: Cannot determine file path for a media clip; skipping.")

        # Do the same for self.music_clips.
        music_file_paths = []
        for mf in self.music_clips:
            if isinstance(mf, str):
                music_file_paths.append(mf)
            elif hasattr(mf, "filename"):
                music_file_paths.append(mf.filename)
            else:
                print("⚠️ Warning: Cannot determine file path for a music clip; skipping.")

        # Prepare arguments for the child process.
        from multiprocessing import Process
        args = (
            media_file_paths,  # list of media file paths (strings)
            srt_file_path,  # subtitle file path (string)
            self.voiceover_file,  # Voiceover file
            music_file_paths,  # list of music file paths (strings)
            self.final_video_file,
            self.platform_settings
        )
        p = Process(target=encode_video, args=args)
        p.start()
        p.join()
        if p.exitcode == 0:
            # … after you append to your log …
            self._cleanup_progress()
            self.status_text.appendPlainText(
                texts.get("video_success", DEFAULT_STRINGS["video_success"])
            )

            # Build the two strings

            msg = texts.get("video_success", DEFAULT_STRINGS["video_success"])
            title = texts.get("success_text", DEFAULT_STRINGS["success_text"])

            # 1) Show your custom progress dialog
            progress = self.show_progress(msg)

            # 2) Override the title to “Success”
            progress.setWindowTitle(title)

            # 3) Auto‐close it after, say, 1.5 seconds
            QTimer.singleShot(1500, self._cleanup_progress)
            final_text = f"{texts.get('video_success', DEFAULT_STRINGS['video_success'])}: {self.final_video_file}"
            self.status_text.appendPlainText(final_text)
        else:
            self.status_text.appendPlainText("❌ Error encoding video in separate process.")
            from PyQt5.QtWidgets import QMessageBox
            QMessageBox.critical(self, "❌ Error", "❌ Error encoding video in separate process.")

    def on_encoding_finished(self, success, message):
        texts = get_texts_for_current_language(self.target_language_input)
        self.status_text.appendPlainText(message)
        from PyQt5.QtWidgets import QMessageBox
        texts = get_texts_for_current_language(self.target_language_input)

        if success:

            # Pick your localized “video created” message
            msg = texts.get(
                "video_success",
                DEFAULT_STRINGS["video_success"]
            )
            final_text = f"{texts.get('video_success', DEFAULT_STRINGS['video_success'])}: {final_video_file}"
            self.status_text.appendPlainText(final_text)
        else:
            # Use the raw error text (you could also localize this)
            msg = message

        # 1) show a styled, flashing‐text dialog
        progress = self.show_progress(msg)

        # 2) optionally override the window title
        title_key = "success_text" if success else "error_text"
        title = texts.get(title_key, DEFAULT_STRINGS.get(title_key, title_key))
        progress.setWindowTitle(title)

        # 3) close it automatically after 1.5s
        QTimer.singleShot(1500, self._cleanup_progress)


    def request_review_notice(self, callback=None):
        """
        Show an info message telling the user to review the content.
        Both in bypass and non-bypass mode, this is purely informational.
        No final video creation is triggered here.
        """
        print("DEBUG: Inside request_review_notice.")

        # If desired, short delay to let the UI render first.
        if not getattr(self, 'bypass_mode', False):
            QTimer.singleShot(150, self._show_review_dialog)
        else:
            self._show_review_dialog()

    def _show_review_dialog(self):
        """
        Actually build & show the QMessageBox. In all modes, "OK" just dismisses.
        No final video creation is triggered here.
        """
        print("DEBUG: Inside _show_review_dialog.")
        texts = get_texts_for_current_language(self.target_language_input)

        msg = QMessageBox(self)
        msg.setWindowTitle(texts.get("review_content_title", DEFAULT_STRINGS["review_content_title"]))

        if getattr(self, 'bypass_mode', False):
            msg.setText(texts.get("bypass_mode_message", DEFAULT_STRINGS["bypass_mode_message"]))
        else:
            msg.setText(texts.get("normal_mode_message", DEFAULT_STRINGS["normal_mode_message"]))

        msg.setStandardButtons(QMessageBox.Ok)
        msg.setWindowModality(Qt.NonModal)

        # Pressing OK just closes the dialog (info-only):
        msg.buttonClicked.connect(msg.close)
        msg.show()

    def _on_review_response(self, msg, button, callback):
        """
        Called ONLY in bypass mode if user hits OK. Proceeds with final video creation.
        """
        texts = get_texts_for_current_language(self.target_language_input)
        if msg.standardButton(button) == QMessageBox.Ok:
            progress = self.show_progress(
                texts.get("generating_final_video", DEFAULT_STRINGS["generating_final_video"])
            )
            if callback:
                callback()
            progress.close()
            self._cleanup_progress()
        else:
            print("[INFO:] Review aborted by user. Skipping final creation.")
            self.status_text.appendPlainText(texts.get("review_aborted", DEFAULT_STRINGS["review_aborted"]))

        msg.close()

    # ---------------------------------------------------------------------------
    # Start video creation.
    def start_video_creation(self):
        texts = get_texts_for_current_language(self.target_language_input)

        # Validate user input.
        video_title = self.video_title_input.text().strip()
        if not video_title:
            QMessageBox.warning(self, "⚠️ Warning", texts.get("title_required", DEFAULT_STRINGS["title_required"]))
            return

        platform = self.platform_input.currentText().strip()
        if not platform:
            QMessageBox.warning(self, "⚠️ Warning", texts.get("platform_required", DEFAULT_STRINGS["platform_required"]))
            return

        prompt = self.prompt_input.toPlainText().strip()
        if not prompt and not self.bypass_yes.isChecked():
            QMessageBox.warning(self, "⚠️ Warning", texts.get("prompt_required", DEFAULT_STRINGS["prompt_required"]))
            return

        voice = self.voice_input.currentText().strip()
        modify_keywords = self.modify_yes.isChecked()
        bypass_text_subtitles_voiceover = self.bypass_yes.isChecked()
        selected_genre = self.genre_input.currentText()
        print(f"Selected Genre: {selected_genre}")


        try:
            self.create_video(video_title, prompt, voice, modify_keywords,
                              bypass_text_subtitles_voiceover, selected_genre)

        except Exception as e:
            QMessageBox.critical(self, "❌ Error", f"❌ An error occurred: {e}")
            self.status_text.appendPlainText(f"❌ An error occurred: {e}")
        finally:
            pass


    # ---------------------------------------------------------------------------
    # Stub for create_video.
    def create_video(
            self,
            video_title,
            prompt,
            voice,
            modify_keywords,
            bypass_text_subtitles_voiceover,
            selected_genre
    ):
        # 1) Get or derive text from your GUI input fields as Python strings
        texts = get_texts_for_current_language(self.target_language_input)
        platform = self.platform_input.currentText().strip()

        # This is your QLineEdit for the base directory. .text() returns a string.
        base_directory_str = self.base_directory.text().strip()

        # Store the video title as a plain string on self.
        self.video_title_str = str(video_title).strip()

        # 2) Define (and store) your directories as strings, not widgets
        self.video_image_folder = os.path.join(base_directory_str, "InVidFiles")
        self.music_folder = os.path.join(base_directory_str, "InMusicFiles")
        self.output_directory = os.path.join(base_directory_str, "OutFiles")

        # Just for reference if needed
        srt_file = os.path.join(self.output_directory, f"{self.video_title_str}_subtitles.srt")

        # Make sure these folders exist
        os.makedirs(self.video_image_folder, exist_ok=True)
        os.makedirs(self.music_folder, exist_ok=True)
        os.makedirs(self.output_directory, exist_ok=True)

        # 3) Diagnostic prints or messages
        print(f"Creating video with title: {self.video_title_str}")
        print(f"Platform: {platform}")
        print(f"Prompt: {prompt}")
        print(f"Voice: {voice}")
        print(f"Modify Keywords: {'Yes' if modify_keywords else 'No'}")
        print(f"Bypass Text/Subtitles/Voiceover: {'Yes' if bypass_text_subtitles_voiceover else 'No'}")
        self.status_text.appendPlainText(f"{texts['creating_video']} {self.video_title_str}")

        try:
            default_platform = next(iter(output_settings))
            platform_settings = output_settings.get(platform, output_settings[default_platform])
            resolution = platform_settings['resolution']

            self.status_text.appendPlainText(f"{texts['video_in_progress']} {self.video_title_str}")

            # 4) Bypass mode
            if bypass_text_subtitles_voiceover:
                self.bypass_mode = True
                self.subtitles_tab.setEnabled(False)
                self.clip_sub_tab.setEnabled(True)

                # (Optional) Clear out older media from prior sessions
                self.media_clips = []
                self.music_clips = []

                # Example keyword extraction
                keywords = seo_extract_keywords(self.video_title_str)
                print("Extracted Keywords:", keywords)
                keywords = keywords.replace("\n", ",")
                keywords_list = [kw.strip() for kw in keywords.split(",") if kw.strip()]

                if modify_keywords:
                    new_val, ok = QInputDialog.getText(
                        None,
                        texts['modify_label'],
                        texts['enter_keywords'],
                        text=", ".join(keywords_list)
                    )
                    if ok:
                        new_val = new_val.replace("\n", ",")
                        keywords_list = [kw.strip() for kw in new_val.split(",") if kw.strip()]
                        print("Modified Keywords:", keywords_list)

                progress = self.show_progress(texts.get("starting_video", DEFAULT_STRINGS["starting_video"]))
                keywords_str = translate_and_combine_keywords(keywords_list)
                keywords_list = [kw.strip() for kw in keywords_str.split(",") if kw.strip()]

                downloaded_source_names = set()
                downloaded_music_urls = set()

                # Download logic
                for keyword in keywords_list:
                    print("Processing Keyword:", keyword)

                    # Download images
                    image_urls = search_pixabay_images(keyword, platform)
                    for i, url in enumerate(image_urls):
                        parsed = urlparse(url)
                        source_filename = os.path.basename(parsed.path)
                        if source_filename in downloaded_source_names:
                            continue
                        filename = f"{keyword}_image_{self.video_title_str}_{i + 1}.jpg"
                        download_file(url, self.video_image_folder, filename)
                        downloaded_source_names.add(source_filename)

                    # Download videos
                    video_urls = search_pixabay_videos(keyword, platform)
                    for i, url in enumerate(video_urls):
                        parsed = urlparse(url)
                        source_filename = os.path.basename(parsed.path)
                        if source_filename in downloaded_source_names:
                            continue
                        filename = f"{keyword}_video_{self.video_title_str}_{i + 1}.mp4"
                        download_file(url, self.video_image_folder, filename)
                        downloaded_source_names.add(source_filename)

                    # Download music
                    print(f"Selected Genre: {selected_genre}")
                    music_urls = search_jamendo_music(keyword, selected_genre)
                    for i, url in enumerate(music_urls):
                        if url in downloaded_music_urls:
                            continue
                        filename = f"{keyword}_music_{self.video_title_str}_{i + 1}.mp3"
                        download_file(url, self.music_folder, filename)
                        downloaded_music_urls.add(url)

                # NEW: Rebuild media/music lists from the downloaded files
                self.media_clips = self.get_downloaded_clips(self.video_image_folder)
                # If you have a separate method or want a quick approach for music:
                # self.music_clips = self.get_downloaded_clips(self.music_folder)
                # or, if your table expects .mp3 in self.music_clips, do:
                self.music_clips = [
                    os.path.join(self.music_folder, f)
                    for f in os.listdir(self.music_folder)
                    if f.lower().endswith(".mp3")
                ]

                # Refresh the table so user can see (and delete if desired)
                self.load_clips_and_subtitles()

                # Switch to the Clips tab
                self.tabs.setCurrentWidget(self.clip_sub_tab)

                # Let the user review, then continue
                self.request_review_notice(callback=self.continue_video_creation_bypass)
                return

            # 5) Non-bypass mode
            else:
                self.bypass_mode = False
                self.clip_sub_tab.setEnabled(False)
                self.subtitles_tab.setEnabled(True)

                # Kick off your async pipeline (script generation, etc.)
                asyncio.run(main(
                    video_title=self.video_title_str,
                    platform=platform,
                    prompt=prompt,
                    voice=voice,
                    modify_keywords=modify_keywords,
                    video_image_folder=self.video_image_folder,
                    output_directory=self.output_directory,
                    music_folder=self.music_folder,
                    selected_genre=selected_genre,
                    gui=self,
                    texts=texts
                ))

                # After the async flow, gather your downloaded clips
                self.media_clips = self.get_downloaded_clips(self.video_image_folder)
                # If your table also expects music clips:
                self.music_clips = [
                    os.path.join(self.music_folder, f)
                    for f in os.listdir(self.music_folder)
                    if f.lower().endswith(".mp3")
                ]

                # Example path for subtitles
                subtitles_txt = os.path.join(self.output_directory, f"{self.video_title_str}_subtitles.txt")
                print(f"DEBUG:  subtitles_txt: {subtitles_txt}")

                # Populate the table with newly downloaded items
                self.load_clips_and_subtitles()

                if os.path.exists(subtitles_txt):
                    self.tabs.setCurrentWidget(self.subtitles_tab)
                    print("Script generated; waiting for user to click 'Save and Regenerate Subtitles'.")
                else:
                    print("Script file was not generated. Please check the generation process.")

        except Exception as e:
            import traceback
            traceback.print_exc()
            self.status_text.appendPlainText(f"❌ Error in main execution: {e}")

    def get_downloaded_clips(self, directory):
        """Retrieve downloaded video clips from the specified directory."""
        clips = []
        try:
            print(f"directory: {directory}")  # Debugging output
            for f in os.listdir(directory):
                if f.lower().endswith(('.mp4', '.avi', '.mov')):
                    clips.append(os.path.join(directory, f))
        except Exception as e:
            print(f"❌ Error retrieving downloaded clips: {e}")
        print(f"clips: {clips}")  # Debugging output
        return clips

    # ---------------------------------------------------------------------------
    # Play video.
    def play_video(self):
        print(f"DEBUG: Inside play_video.")
        # at the very top of create_video:
        texts = get_texts_for_current_language(self.target_language_input)
        video_title = self.video_title_input.text().strip()
        print(f"DEBUG: Inside play_video. video_title: {video_title}")
        if not video_title:
            #QMessageBox.warning(self, "⚠️ Warning", "Please enter a video title.")
            QMessageBox.warning(self, "⚠️ Warning", texts.get("title_required", DEFAULT_STRINGS["title_required"]))

            return
        platform = self.platform_input.currentText().strip()
        final_video_file = os.path.join(self.output_directory.text(), f"{video_title}_{platform}.mp4")
        print(f"DEBUG:  final_video_file: {final_video_file}, platform: {platform}")
        if not os.path.exists(final_video_file):
            QMessageBox.warning(
                self,
                "⚠️ Warning",
                texts.get("video_not_found",
                          DEFAULT_STRINGS["video_not_found"]
                          ).format(final_video_file)
            )

            return
        try:
            print(f"DEBUG:  Before openPreview final_video_file: {final_video_file}")
            # Instead of using os.startfile or webbrowser.open,
            # we call openPreview which is known to work.
            self.openPreview(final_video_file, "Video")
            #self.status_text.appendPlainText(f"Playing video: {final_video_file}")
            print(f"Playing video: {final_video_file}")
        except Exception as e:
            QMessageBox.critical(self, "❌ Error", f"❌ An error occurred while playing the video: {e}")
        pass

    def on_app_quit(self):
        """Runs just before QApplication quits."""
        # 1. close the global log so Windows will unlock OutFiles/log.txt
        close_log_file()

        # 2. archive the working sub-directories
        base_dir       = self.base_directory.text().strip()
        video_filename = self.video_title_input.text().strip()
        archive_subdirs(base_dir, video_filename)

async def list_voices():
    voices = await edge_tts.list_voices()
    #filtered_voices = [voice for voice in voices if voice['Locale'] in ['en-GB', 'en-US', 'Neural', 'ar', 'es', 'fr', 'pt', 'de', 'hi', 'zh' ]]
    filtered_voices = [voice for voice in voices if voice['Locale']]
    return filtered_voices


def clean_subtitles(video_title, output_directory):
    # Define file paths
    original_file = os.path.join(output_directory, f"{video_title}_subtitles.txt")
    backup_file = os.path.join(output_directory, f"{video_title}_subtitles_orig.txt")
    cleaned_file = os.path.join(output_directory, f"{video_title}_subtitles_cleaned.txt")

    # Create a backup of the original file
    shutil.copyfile(original_file, backup_file)

    # Define replacements for abbreviated text and special characters
    replacements = {
        "Article": "Video",
        "article": "video",
        "It’s": "It is",
        "it’s": "it is",
        "it's": "it is",
        "I’ll": "I will",
        "i’ll": "i will",
        "I’ll": "I will",
        "We’ll": "We will",
        "we’ll": "we will",
        "We’re": "We are",
        "we’re": "we are",
        "I’m": "I am",
        "i’m": "i am",
        "I’m": "I am",
        "you’re": "you are",
        "You’re": "You are",
        "You're": "You are",
        "you're": "you are",
        "'re": " are",
        "We’ve": "We have",
        "we’ve": "we have",
        "Don’t": "Do not",
        "don’t": "do not",
        "don't": "do not",
        "Don't": "Do not",
        "n't": " not",
        "You’ll": "You will",
        "you’ll": "you will",
        "There’s": "There is",
        "there’s": "there is",
        "There is": "There is",
        "There's": "There is",
        "there's": "there is",
        "***": " ",
        "** *": " ",
        "* **": " ",
        "**": " ",
        "*": " ",
        "###": " ",
        "## #": " ",
        "# ##": " ",
        "##": " ",
        "#": " ",
        "-": " ",
        "’": "'",
        "‘": "'",
        "“": "\"",
        "”": "\"",
        "…": "...",
        "&": "and",
        "*": " "  # Additional replacement for any missed asterisks
    }

    # Sort replacements by length in descending order so longer matches get replaced first
    replacements = dict(sorted(replacements.items(), key=lambda item: len(item[0]), reverse=True))

    # Regex pattern to remove emojis/icons from text
    emoji_pattern = re.compile(
        "["                           # Start of character class
        u"\U0001F600-\U0001F64F"      # Emoticons
        u"\U0001F300-\U0001F5FF"      # Symbols & pictographs
        u"\U0001F680-\U0001F6FF"      # Transport & map symbols
        u"\U0001F700-\U0001F77F"      # Alchemical symbols
        u"\U0001F780-\U0001F7FF"      # Geometric Shapes Extended
        u"\U0001F800-\U0001F8FF"      # Supplemental Arrows-C
        u"\U0001F900-\U0001F9FF"      # Supplemental Symbols & Pictographs
        u"\U0001FA00-\U0001FA6F"      # Chess Symbols
        u"\U0001FA70-\U0001FAFF"      # Symbols & Pictographs Extended-A
        u"\U00002702-\U000027B0"      # Dingbats
        u"\U000024C2-\U0001F251"      # Enclosed characters
        "]+",
        flags=re.UNICODE
    )

    # Read the original file
    with open(original_file, 'r', encoding='utf-8') as file:
        lines = file.readlines()

    cleaned_lines = []
    for line in lines:
        # Apply dictionary-based replacements first
        for old, new in replacements.items():
            line = line.replace(old, new)
        # Remove any emojis/icons
        line = emoji_pattern.sub('', line)
        cleaned_lines.append(line)

    # Write the cleaned lines to the temporary cleaned file
    with open(cleaned_file, 'w', encoding='utf-8') as file:
        file.writelines(cleaned_lines)

    # Replace the original file with the cleaned file
    shutil.move(cleaned_file, original_file)

    print(f"Cleaned subtitles saved to {original_file}")



def generate_text_chatgpt(prompt):
    try:
        # Use the new OpenAI client for chat completion
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.7,
            max_tokens=800
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        print(f"❌ Error occurred with OpenAI API: {e}")
        return f"❌ An error occurred with OpenAI: {e}"


def generate_text(prompt):
    """
    Wrapper around the ChatGPT call and Gemini fallback, plus font selection.
    """
    global font

    # ChatGPT
    text = generate_text_chatgpt(prompt)

    # Choose Arabic font if we detect Arabic characters:
    if text and re.search(r'[\u0600-\u06FF]', text):
        font = arabic_font
    else:
        font = english_font

    print(f"from generate_text() returning font: {font}")
    # Return either the API response or an error placeholder
    return text or "❌ Error: Could not generate text from any API."


def seo_extract_keywords(video_title):
    # Create a prompt that instructs ChatGPT to extract the top 5 SEO keywords
    prompt = (f"Please provide the top 5 SEO optimized keywords and tags for the video title: '{video_title}'. "
              "Return only clear multi-word relevant keywords as a comma-separated string.")
    # Call the ChatGPT API via our generate_text_chatgpt function
    #result = generate_text_chatgpt(prompt)
    result = generate_text(prompt)
    return result


def extract_keywords(text):
    stop_words = set(stopwords.words('english'))
    words = re.findall(r'\w+', text.lower())
    filtered_words = [word for word in words if word not in stop_words and len(word) > 3]
    common_words = Counter(filtered_words).most_common()
    keywords = [word for word, count in common_words]
    return keywords[:5]  # Limit to top 10 keywords


def search_jamendo_music(query, genre):
    try:
        response = requests.get(
            'https://api.jamendo.com/v3.0/tracks/',
            params={
                'client_id': 'c2b0a654',
                'format': 'json',
                'limit': 5,
                'search': query,
                'tags': genre
            }
        )
        data = response.json()
        print("Jamendo Music data:", data)
        if 'results' in data and data['results']:
            return [track['audio'] for track in data['results']]
        else:
            print("No Jamendo music found")
            return []
    except requests.RequestException as e:
        return [f"❌ An error occurred: {e}"]


def search_pixabay_images(query, platform):
    try:
        response = requests.get(
            'https://pixabay.com/api/',
            params={'key': PIXABAY_API_KEY, 'q': query, 'image_type': 'photo', 'per_page': 5}
        )
        data = response.json()
        if 'hits' not in data or not data['hits']:
            return []

        # Get the exact target resolution for the platform.
        target_width, target_height = get_platform_resolution(platform)

        matching_images = []
        for hit in data['hits']:
            # Pixabay API provides image dimensions under 'imageWidth' and 'imageHeight'
            img_width = hit.get('imageWidth', 0)
            img_height = hit.get('imageHeight', 0)
            if img_width == target_width and img_height == target_height:
                url = hit.get('largeImageURL') or hit.get('webformatURL')
                if url:
                    matching_images.append(url)
        return matching_images

    except requests.RequestException as e:
        return [f"❌ An error occurred: {e}"]


def search_pixabay_videos(query, platform):
    try:
        response = requests.get(
            'https://pixabay.com/api/videos/',
            params={'key': PIXABAY_API_KEY, 'q': query, 'per_page': 5}
        )
        data = response.json()

        if 'hits' not in data or not data['hits']:
            return []

        target_width, target_height = get_platform_resolution(platform)
        filtered_videos = []
        for hit in data['hits']:
            video_variants = hit.get('videos', {})
            for quality, details in video_variants.items():
                vid_width = details.get('width', 0)
                vid_height = details.get('height', 0)
                # Only consider variants that exactly match the target dimensions.
                if vid_width == target_width and vid_height == target_height:
                    filtered_videos.append(details.get('url'))
                    break  # Found a match; move to next hit.
        return filtered_videos

    except requests.RequestException as e:
        return [f"❌ An error occurred: {e}"]


def search_pexels_images(query, platform):
    try:
        response = requests.get(
            'https://api.pexels.com/v1/search',
            headers={'Authorization': PEXELS_API_KEY},
            params={'query': query, 'per_page': 10}
        )
        data = response.json()

        if 'photos' in data:
            target_width, target_height = get_platform_resolution(platform)

            filtered_images = [
                photo['src']['original']
                for photo in data['photos']
                if 'width' in photo and 'height' in photo and
                   photo['width'] == target_width and
                   photo['height'] == target_height
            ]
            return filtered_images if filtered_images else []
        else:
            return []

    except requests.RequestException as e:
        return [f"❌ An error occurred: {e}"]


def search_pexels_videos(query, platform, per_page=3):
    url = "https://api.pexels.com/videos/search"
    headers = {"Authorization": PEXELS_API_KEY}
    params = {"query": query, "per_page": per_page}

    try:
        response = requests.get(url, headers=headers, params=params)
        response.raise_for_status()
        data = response.json()

        if 'videos' not in data:
            return []

        target_width, target_height = get_platform_resolution(platform)
        filtered_videos = []
        for video in data['videos']:
            for file in video.get('video_files', []):
                vid_width = file.get('width', 0)
                vid_height = file.get('height', 0)
                if vid_width == target_width and vid_height == target_height:
                    filtered_videos.append(file.get('link'))
                    break
        return filtered_videos

    except requests.RequestException as e:
        print(f"❌ An error occurred while fetching videos from Pexels: {e}")
        return []


def search_unsplash_photos(query, platform, per_page=5):
    url = "https://api.unsplash.com/search/photos"
    headers = {"Authorization": f"Client-ID {UNSPLASH_API_KEY}"}
    params = {"query": query, "per_page": per_page}

    try:
        response = requests.get(url, headers=headers, params=params)
        response.raise_for_status()
        results = response.json().get("results", [])

        target_width, target_height = get_platform_resolution(platform)
        filtered_results = []
        for photo in results:
            if isinstance(photo, dict):
                photo_width = photo.get("width", 0)
                photo_height = photo.get("height", 0)
                if photo_width == target_width and photo_height == target_height:
                    filtered_results.append({
                        "id": photo.get("id", "N/A"),
                        "description": photo.get("description", "No description available"),
                        "urls": photo.get("urls", {}),
                        "download_location": photo.get("links", {}).get("download_location", ""),
                        "user": photo.get("user", {}).get("name", "Unknown")
                    })
            else:
                print(f"⚠️ Skipping unexpected response format: {photo}")

        print(
            f"✅ Found {len(filtered_results)} images for '{query}' exactly matching {platform} resolution: {(target_width, target_height)}")
        return filtered_results

    except requests.exceptions.JSONDecodeError:
        print("❌ Error decoding JSON response from Unsplash API.")
        return []
    except requests.exceptions.RequestException as e:
        print(f"❌ Error fetching photos from Unsplash: {e}")
        return []


def download_file(url, folder=None, filename=None, output_path=None):
    if output_path:
        folder, filename = os.path.split(output_path)
    elif folder and filename:
        output_path = os.path.join(folder, filename)
    else:
        raise ValueError("❌ Either 'folder' and 'filename' or a complete 'output_path' must be provided.")
    os.makedirs(folder, exist_ok=True)
    if os.path.exists(output_path):
        print(f"File already exists: {output_path}")
        return output_path

    headers = {
        'Authorization': f'Client-ID {UNSPLASH_API_KEY}',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36'
    }
    retries = 3
    for attempt in range(1, retries + 1):
        try:
            response = requests.get(url, headers=headers, stream=True, timeout=10)
            response.raise_for_status()
            with open(output_path, 'wb') as file:
                for chunk in response.iter_content(chunk_size=8192):
                    file.write(chunk)
            print(f"Successfully downloaded: {output_path}")
            return output_path
        except requests.exceptions.RequestException as e:
            print(f"❌ Attempt {attempt}/{retries} failed for URL: {url}. Error: {e}")
            if attempt == retries:
                raise Exception(f"Failed to download file after {retries} attempts: {url}")


# Helper function accepting a list of keywords and returning a list with translations
def translate_and_combine_keywords(keyword_list):
    """
    Given a list of keywords, for each keyword containing non-English characters,
    call generate_text_chatgpt() to translate it into English. If a translation is provided
    and is different from the original, combine them.
    Returns a comma-separated string of the combined keywords.
    """
    combined_results = []
    for kw in keyword_list:
        if any(ord(c) > 127 for c in kw):  # Check non-ASCII characters
            prompt = f"Translate the following non-English keyword to English: '{kw}'. Return only the English translation."
            #translation = generate_text_chatgpt(prompt)
            translation = generate_text(prompt)
            if translation and translation.strip() and translation.strip().lower() != kw.lower():
                combined_results.append(f"{kw} {translation.strip()}")
            else:
                combined_results.append(kw)
        else:
            combined_results.append(kw)
    return ", ".join(combined_results)


def generate_content(texts, prompt, platform, video_title, modify_keywords, video_image_folder, output_directory,
                     music_folder, selected_genre):
    def get_wide_text(parent, window_title, label, default_text,
                      chars_to_show=100):
        """
        Opens a QInputDialog whose line-edit is wide enough to display
        `chars_to_show` average characters (≈100 by default).
        Returns (text, accepted)
        """
        dlg = QInputDialog(parent)
        dlg.setWindowTitle(window_title)
        dlg.setLabelText(label)
        dlg.setTextValue(default_text)
        dlg.setInputMode(QInputDialog.TextInput)

        # ----------------------------------------------------------------
        # Enlarge the dialog and the internal QLineEdit
        # ----------------------------------------------------------------
        # 1.  Find the line-edit that QInputDialog creates internally

        le = dlg.findChild(QLineEdit)

        if le is not None:
            # Compute the pixel width that ≈ `chars_to_show` characters occupy
            fm = le.fontMetrics()
            char_width = fm.horizontalAdvance('M')  # “M” ~ widest char
            margin = 20  # extra padding
            target_px = char_width * chars_to_show + margin
            le.setMinimumWidth(target_px)  # make the edit wide
            dlg.resize(target_px + 50, dlg.sizeHint().height())  # make dialog wide

        # Optional: limit how much the user can type
        # le.setMaxLength(chars_to_show)   # uncomment if you need a hard max

        # ----------------------------------------------------------------
        # Execute the dialog
        # ----------------------------------------------------------------
        ok = dlg.exec_() == QDialog.Accepted
        return dlg.textValue(), ok

    def show_progress_local(message: str, parent=None):
        """
        A self-contained version of show_progress that:
        1) Creates a frameless, on-top QProgressDialog with the given message.
        2) Applies a style sheet to the dialog and label.
        3) Flashes the message text every 500ms.
        4) Returns the QProgressDialog object so you can later call close().
        """

        # Create a QProgressDialog
        dlg = QProgressDialog(message, None, 0, 0, parent)
        dlg.setWindowModality(Qt.ApplicationModal)
        dlg.setWindowTitle("Processing...")
        dlg.setCancelButton(None)
        dlg.setMinimumDuration(0)
        # Frameless + always on top
        dlg.setWindowFlags(dlg.windowFlags()
                           | Qt.FramelessWindowHint
                           | Qt.WindowStaysOnTopHint)

        # Style it (adjust to your preference)
        dlg.setStyleSheet("""
            QProgressDialog {
                background-color: rgba(240, 240, 240, 220);
                border-radius: 10px;
                padding: 20px;
            }
            QLabel {
                color: black;
                font-size: 12px;
                font-weight: bold;
            }
        """)

        dlg.setLabelText(message)
        dlg.show()
        dlg.setValue(0)

        # Make sure the UI updates
        QApplication.processEvents()

        # Obtain the QLabel (for flashing text)
        lbl = dlg.findChild(QLabel)
        if lbl:
            lbl.setTextFormat(Qt.RichText)
            lbl.setWordWrap(True)

        # Prepare flashing
        orig_text = message
        flash_text = f'<font color="#5d8aa8">{message}</font>'
        state = [False]

        # Timer to alternate text color
        timer = QTimer(dlg)
        timer.setInterval(500)

        def _flash():
            state[0] = not state[0]
            if lbl:
                lbl.setText(flash_text if state[0] else orig_text)

        timer.timeout.connect(_flash)
        timer.start()

        # Return the dialog so you can close it later
        return dlg

    #texts = get_texts_for_current_language(target_language)
    script_text = generate_text(prompt)

    # Ensure script_text is a string
    if isinstance(script_text, bytes):
        script_text = script_text.decode('utf-8')
    elif not isinstance(script_text, str):
        raise TypeError("❌ Generated text is neither str nor bytes")

    print("Generated Text:", script_text)

    text_script_file = os.path.join(output_directory, f"{video_title}_subtitles.txt")
    with open(text_script_file, 'w', encoding='utf-8') as file:
        file.write(script_text)
    clean_subtitles(video_title, output_directory)
    print(f"Text Cleaned and saved to {text_script_file}")

    # Extract keywords from the video title (returns a comma‐separated string)
    keywords = seo_extract_keywords(video_title)
    print("Extracted Keywords:", keywords)

    # Replace newlines with commas and convert the string to a list
    keywords = keywords.replace("\n", ",")
    keywords_list = [kw.strip() for kw in keywords.split(",") if kw.strip()]

    # If modify_keywords is enabled, prompt the user once to edit the keywords
    if modify_keywords:
        """
        new_keywords_str, ok = QInputDialog.getText(
            None,
            texts['modify_label'],
            texts['enter_keywords'],
            text=", ".join(keywords_list)
        )
         """
        #new_keywords_str, ok = QInputDialog.getText(
        #    None,
        #    texts.get("modify_label", DEFAULT_STRINGS["modify_label"]),
        #    texts.get("enter_keywords", DEFAULT_STRINGS["enter_keywords"]),
        #    text=", ".join(keywords_list)
        #)
        new_keywords_str, ok = get_wide_text(
            None,
            texts['modify_label'],
            texts['enter_keywords'],
            default_text=", ".join(keywords_list),
            chars_to_show=80  # show ±80 chars in one line
        )
        if ok:
            new_keywords_str = new_keywords_str.replace("\n", ",")
            keywords_list = [kw.strip() for kw in new_keywords_str.split(",") if kw.strip()]
            print("Modified Keywords:", keywords_list)

    # Now translate/combine the keywords using a helper function that accepts a list,
    # not a joined string.
    keywords_list = translate_and_combine_keywords(keywords_list)

    # In case the helper returns a comma-separated string, convert it back to a list
    keywords_list = [kw.strip() for kw in keywords_list.split(",") if kw.strip()]

    print("DEBUG: inside generate_content. Before show_progress_local")
    progress = show_progress_local(texts.get("starting_video", DEFAULT_STRINGS["starting_video"]))

    # Create sets to keep track of downloaded source identifiers.
    downloaded_media_sources = set()  # For images/videos (based on filename)
    downloaded_music_sources = set()  # For music (based on full URL)

    for keyword in keywords_list:
        print("Processing Keyword:", keyword)

        # Download Pixabay images.
        image_urls = search_pixabay_images(keyword, platform)
        for i, url in enumerate(image_urls):
            # Extract source filename from URL.
            source_filename = os.path.basename(urlparse(url).path)
            if source_filename in downloaded_media_sources:
                print(f"Skipping duplicate Pixabay image with source: {source_filename}")
                continue
            output_path = os.path.join(video_image_folder, f"{keyword}_pixabay_image_{video_title}_{i + 1}.jpg")
            download_file(url, output_path=output_path)
            downloaded_media_sources.add(source_filename)

        # Download Pixabay videos.
        pixabay_video_urls = search_pixabay_videos(keyword, platform)
        for i, url in enumerate(pixabay_video_urls):
            source_filename = os.path.basename(urlparse(url).path)
            if source_filename in downloaded_media_sources:
                print(f"Skipping duplicate Pixabay video with source: {source_filename}")
                continue
            output_path = os.path.join(video_image_folder, f"{keyword}_pixabay_video_{video_title}_{i + 1}.mp4")
            download_file(url, output_path=output_path)
            downloaded_media_sources.add(source_filename)

        # Download Pexels images.
        pexels_image_urls = search_pexels_images(keyword, platform)
        for i, url in enumerate(pexels_image_urls):
            source_filename = os.path.basename(urlparse(url).path)
            if source_filename in downloaded_media_sources:
                print(f"Skipping duplicate Pexels image with source: {source_filename}")
                continue
            output_path = os.path.join(video_image_folder, f"{keyword}_pexels_image_{video_title}_{i + 1}.jpg")
            download_file(url, output_path=output_path)
            downloaded_media_sources.add(source_filename)

        # Download Pexels videos.
        pexels_video_urls = search_pexels_videos(keyword, platform)
        for i, url in enumerate(pexels_video_urls):
            source_filename = os.path.basename(urlparse(url).path)
            if source_filename in downloaded_media_sources:
                print(f"Skipping duplicate Pexels video with source: {source_filename}")
                continue
            output_path = os.path.join(video_image_folder, f"{keyword}_pexels_video_{video_title}_{i + 1}.mp4")
            download_file(url, output_path=output_path)
            downloaded_media_sources.add(source_filename)

        # Download Unsplash images.
        unsplash_photo_results = search_unsplash_photos(keyword, platform)
        if unsplash_photo_results:
            for i, photo in enumerate(unsplash_photo_results, 1):
                if not isinstance(photo, dict):
                    print(f"⚠️ Skipping invalid photo data: {photo}")
                    continue
                download_location = photo.get("download_location", "")
                if not download_location:
                    print(f"⚠️ No valid download location for photo: {photo.get('description', 'No description')}")
                    continue
                try:
                    headers = {"Authorization": f"Client-ID {UNSPLASH_API_KEY}"}
                    response = requests.get(download_location, headers=headers)
                    response.raise_for_status()
                    download_url = response.json().get("url", "")
                    if not download_url:
                        print(
                            f"No valid download URL retrieved for photo: {photo.get('description', 'No description')}")
                        continue
                    source_filename = os.path.basename(urlparse(download_url).path)
                    if source_filename in downloaded_media_sources:
                        print(f"Skipping duplicate Unsplash image with source: {source_filename}")
                        continue
                    print(
                        f"Downloading Unsplash photo: {photo.get('description', 'No description')} by {photo.get('user', 'Unknown')}")
                    filename = f"{keyword}_unsplash_image_{video_title}_{i}.jpg"
                    download_file(download_url, video_image_folder, filename)
                    downloaded_media_sources.add(source_filename)
                except Exception as e:
                    print(f"❌ Error fetching or downloading photo: {e}")
        else:
            print(f"❌ No photos found on Unsplash for keyword: {keyword}")

        # Download Jamendo music.
        print(f"Selected Genre3: {selected_genre}")
        jamendo_music_urls = search_jamendo_music(keyword, selected_genre)
        if not jamendo_music_urls:
            print("No Jamendo music found")
        else:
            for i, url in enumerate(jamendo_music_urls):
                # For music, we'll use the entire URL as the unique identifier.
                if url in downloaded_music_sources:
                    print("Skipping duplicate Jamendo music (URL already processed)")
                    continue
                filename = f"{keyword}_jamendo_music_{video_title}_{i + 1}.mp3"
                output_path = os.path.join(music_folder, filename)
                download_file(url, output_path=output_path)
                downloaded_music_sources.add(url)
                os.makedirs(output_directory, exist_ok=True)

    script_text = read_script_file(text_script_file)

    # Ensure script_text is a string
    if isinstance(script_text, bytes):
        script_text = script_text.decode('utf-8')
    elif not isinstance(script_text, str):
        raise TypeError("❌ Script text is neither str nor bytes after reading from file")

    print("Before writing script to file again....")
    with open(text_script_file, 'w', encoding='utf-8') as file:
        file.write(script_text)
    clean_subtitles(video_title, output_directory)
    print(f"Text Cleaned Again and saved to {text_script_file}")

    #progress.close()

    return script_text, keywords, text_script_file


def read_script_file(text_script_file):
    try:
        with open(text_script_file, 'r', encoding='utf-8') as file:
            text = file.read()
        return text
    except UnicodeDecodeError:
        try:
            with open(text_script_file, 'r', encoding='latin-1') as file:
                text = file.read()
            return text
        except UnicodeDecodeError:
            try:
                with open(text_script_file, 'r', encoding='cp1252') as file:
                    text = file.read()
                return text
            except Exception as e:
                print(f"❌ Error reading file {text_script_file} with various encodings: {e}")
                return None
    except Exception as e:
        print(f"❌ Error reading file {text_script_file}: {e}")
        return None


async def convert_text_to_speech(text, voice, output_file):
    communicate = edge_tts.Communicate(text, voice)
    await communicate.save(output_file)
    print(f"Voiceover saved to {output_file}")


def get_audio_duration(file_path):
    try:
        audio = AudioSegment.from_file(file_path)
        return len(audio) / 1000.0  # Convert milliseconds to seconds
    except FileNotFoundError as e:
        print(f"Audio file not found: {e}")
        return 0
    except Exception as e:
        print(f"❌ Error getting audio duration: {e}")
        return 0


def resize_clip(clip, target_resolution):
    try:
        if not isinstance(target_resolution, tuple) or len(target_resolution) != 2:
            raise ValueError("❌ target_resolution should be a tuple of (width, height)")

        clip_resolution = (int(clip.w), int(clip.h))  # Get clip's current resolution
        print(f"📏 Clip resolution: {clip_resolution}, Target resolution: {target_resolution}")

        # ✅ Only resize if resolutions don't match
        if clip_resolution == target_resolution:
            print("✅ No resizing needed. Clip resolution matches the target platform.")
            return clip  # Return the original clip if it already matches

        print(f"🔄 Resizing clip to: {target_resolution}")
        resized_clip = resize(clip, newsize=target_resolution)

        if resized_clip is None:
            print("❌ Error: Resized clip is None.")
            return None
        else:
            print(f"✅ Resized clip resolution: {resized_clip.size}")
            return resized_clip

    except Exception as e:
        print(f"❌ Error resizing video: {e}")
        return None


async def generate_voiceover(text, output_file, voice):
    try:
        await convert_text_to_speech(text, voice, output_file)
    except ValueError as e:
        print(f"❌ Value error: {e}")
    except Exception as e:
        print(f"❌ An unexpected error occurred: {e}")


def generate_subtitles_local(script, subtitles_file, voiceover_duration):
    try:
        subtitles = []
        words = script.split()
        with open(subtitles_file, 'w', encoding='utf-8') as f:
            start_time = 0
            line = []
            for word in words:
                if len(' '.join(line + [word])) <= 45:
                    line.append(word)
                else:
                    duration = len(' '.join(line).split()) / len(script.split()) * voiceover_duration
                    end_time = start_time + duration
                    subtitle_line = ' '.join(line)
                    subtitles.append((start_time, end_time, subtitle_line))
                    f.write(f"{start_time:.3f} --> {end_time:.3f}\n{subtitle_line}\n\n")
                    start_time = end_time
                    line = [word]
            if line:
                duration = len(' '.join(line).split()) / len(script.split()) * voiceover_duration
                end_time = start_time + duration
                subtitle_line = ' '.join(line)
                subtitles.append((start_time, end_time, subtitle_line))
                f.write(f"{start_time:.3f} --> {end_time:.3f}\n{subtitle_line}\n\n")
        return subtitles
    except Exception as e:
        print(f"❌ Error generating subtitles: {e}")
        return None


async def main(video_title,
               platform,
               prompt,
               voice,
               modify_keywords,
               video_image_folder,
               output_directory,
               music_folder,
               selected_genre,
               gui,        # instance of VideoCreatorGUI
               texts):     # dict returned by get_texts_for_current_language


    # 1) Log the "creating video" message
    msg = texts.get('creating_video', DEFAULT_STRINGS['creating_video'])
    print(f"{msg} {video_title}")

    # 2) Generate the script, keywords, etc.
    text, keywords, script_file = generate_content(
        texts,
        prompt,
        platform,
        video_title,
        modify_keywords,
        video_image_folder,
        output_directory,
        music_folder,
        selected_genre
    )

    # 3) Prepare for voice-over + subtitles
    warnings.filterwarnings("ignore", category=SyntaxWarning, module='pydub')

    # Where ChatGPT saved the .txt
    script_path = os.path.join(output_directory,
                               f"{video_title}_subtitles.txt")
    # Read it back if present
    script = text
    if os.path.exists(script_path):
        try:
            with open(script_path, 'r', encoding='utf-8') as f:
                script = f.read()
        except Exception as e:
            print(f"⚠️  Could not read {script_path}: {e}; using generated text.")

    # 4) Generate the voice-over
    voiceover_file = os.path.join(output_directory,
                                  f"{video_title}_voiceover.mp3")
    await generate_voiceover(script, voiceover_file, voice)

    # 5) Build SRT subtitles
    subtitles_file = os.path.join(output_directory,
                                  f"{video_title}_subtitles.srt")
    voiceover_duration = get_audio_duration(voiceover_file)
    if voiceover_duration <= 0:
        print("❌ Invalid voiceover duration; aborting.")
        return

    wip_subtitles = generate_subtitles_local(
        script, subtitles_file, voiceover_duration
    )

    # 6) Final check that our .srt exists
    if not os.path.exists(subtitles_file):
        print(f"❌ Subtitles not found at {subtitles_file}; aborting.")
        return

    # 7) Hand back to GUI to do the final video+audio merge
    gui.create_video_with_audio_and_subtitles(
        video_title,
        subtitles_file,
        platform,
        video_image_folder,
        music_folder,
        output_directory
    )

def show_animated_splash():

    splash = QSplashScreen()
    # Make it frameless if desired
    splash.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint)

    # Force a fixed size so the splash won't resize automatically
    splash.setFixedSize(600, 400)

    # Create a QLabel that covers the entire splash
    splash_label = QLabel(splash)
    splash_label.setAlignment(Qt.AlignCenter)
    splash_label.setGeometry(0, 0, 600, 400)
    splash_label.setScaledContents(True)  # Scale GIF to fill label if needed

    # Load and set the GIF
    movie = QMovie(SPLASH_GIF)
    # Optionally force the GIF itself to 600×400 if you want it stretched:
    movie.setScaledSize(QSize(600, 400))
    splash_label.setMovie(movie)
    movie.start()

    # Center the splash on the screen
    screen_rect = QApplication.primaryScreen().availableGeometry()
    x = (screen_rect.width() - 600) // 2
    y = (screen_rect.height() - 400) // 2
    splash.move(x, y)

    splash.show()
    return splash


if __name__ == "__main__":



    _set_imagemagick_path()
    app = QApplication(sys.argv)
    # 1. Show splash
    splash_screen = show_animated_splash()

    # 2. Instantiate GUI but do not show it immediately
    gui = VideoCreatorGUI()

    # 3. Hide splash and show GUI after a short delay or once init is done
    QTimer.singleShot(2500, lambda: (splash_screen.close(), gui.show()))

    app.aboutToQuit.connect(close_log_file)  # Connect cleanup function

    gui.show()
    sys.exit(app.exec_())


