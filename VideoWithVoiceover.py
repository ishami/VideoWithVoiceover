# Standard library
import json, atexit
import os
import sys
import gc
import warnings
import time
import asyncio
import threading
import subprocess
import tempfile
import uuid
import base64
import pickle
import re
import shutil
import textwrap
import webbrowser
import traceback
from io import BytesIO
from collections import Counter
import builtins
import datetime
import platform

# Third-party libraries
import cv2
import numpy as np
import nltk
from nltk.corpus import stopwords
import requests
import tiktoken
import vlc
import openai
from openai import OpenAI
from pydub import AudioSegment
from PIL import Image
from bs4 import BeautifulSoup
from transformers import pipeline

# MoviePy (video/audio editing)
import moviepy.editor as mp
from moviepy.config import change_settings
from moviepy.editor import (
    VideoFileClip, concatenate_videoclips, CompositeVideoClip,
    AudioFileClip, TextClip, ImageClip, CompositeAudioClip
)
from moviepy.video.VideoClip import VideoClip
from moviepy.video.fx.all import resize
from moviepy.audio.AudioClip import concatenate_audioclips

# Text-to-speech
import edge_tts
from edge_tts import Communicate, list_voices

# Google APIs
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from googleapiclient.http import MediaFileUpload

# URL parsing
from urllib.parse import urlparse

# PyQt5 (GUI)
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QDialog, QFrame, QSplashScreen,
    QDialogButtonBox, QVBoxLayout, QHBoxLayout, QGridLayout,
    QStackedWidget, QTabWidget, QLabel, QLineEdit, QPlainTextEdit,
    QTextEdit, QRadioButton, QButtonGroup, QComboBox, QToolButton,
    QPushButton, QFileDialog, QMessageBox, QInputDialog, QFormLayout,
    QDateEdit, QCheckBox, QProgressBar, QProgressDialog, QGroupBox,QDateTimeEdit,
    QSlider, QSizePolicy, QListWidget, QTableWidget, QTableWidgetItem,
    QHeaderView, QAbstractItemView, QLayout, QStyle, QStyledItemDelegate,
    QStyleOptionViewItem, QToolTip, QDesktopWidget, QProgressDialog, QTabBar
)
from PyQt5.QtMultimedia import QMediaPlayer, QMediaContent
from PyQt5.QtMultimediaWidgets import QVideoWidget
from PyQt5.QtCore import (
    Qt, QUrl, QThread, pyqtSignal, QTimer, QSize, QDate, QDateTime,
    QObject, QEvent, QMimeData, QPoint, QStandardPaths, QCoreApplication
)
from PyQt5.QtGui import (
    QPixmap, QIcon, QImage, QDesktopServices, QCursor,
    QColor, QBrush, QDrag, QFont, QPainter, QFontMetrics, QMovie
)
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from langdetect import detect, DetectorFactory
from PyQt5.QtMultimedia import QMediaPlayer, QMediaContent
from PyQt5.QtCore import QUrl


# --------- Buttons Style Sheets -----------------------------------

os.environ["BROWSER"] = "true"      # makes webbrowser.open() a no-op
BTN_STYLE = """
QPushButton {
    background-color: #5d8aa8; /* Base color */
    color: white;
    font-weight: bold;
    font-size: 12px;
    border: 2px solid #4a739b; /* Darker border for depth */
    border-radius: 5px;
    padding: 5px 10px;
    min-width: 80px;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3); /* Shadow for 3D effect */
}
QPushButton:pressed {
    background-color: #4a739b; /* Darker shade when pressed */
    border: 2px solid #3b5a7b;
    box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.3); /* Inset shadow for pressed effect */
}
QPushButton:hover {
    background-color: #6b9ec1; /* Lighter blue on hover */
}
"""

BTN_LF_STYLE = """
QPushButton {
    background-color: #5d8aa8; /* Base color */
    color: white;
    font-weight: bold;
    font-size: 18px;
    border: 2px solid #4a739b; /* Darker border for depth */
    border-radius: 5px;
    padding: 5px 10px;
    min-width: 80px;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3); /* Shadow for 3D effect */
}
QPushButton:pressed {
    background-color: #4a739b; /* Darker shade when pressed */
    border: 2px solid #3b5a7b;
    box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.3); /* Inset shadow for pressed effect */
}
QPushButton:hover {
    background-color: #6b9ec1; /* Lighter blue on hover */
}
"""
# --------------------- Variables and Parameters Setting ------------------------

SPLASH_GIF = "splash.gif"  # Will be replaced with your actual GIF file later.
APP_LOGO = "logo.png"  # Will be replaced with your actual PNG file later.
FAQ_LINK = "https://ai-videocreator.com/faq"  # The link to your FAQ.
SUPPORT_EMAIL = "support@ai-videocreator.com"  # Destination for support tickets.

SMTP_SERVER = "smtp.hostinger.com"  # Your SMTP server address
SMTP_PORT = 587  # Common port for TLS
FROM_EMAIL = "System@ai-videocreator.com"
EMAIL_PASSWORD = "SyS2025$"  # NEVER hardcode in production!
DetectorFactory.seed = 0  # for consistent results from langdetect
COUNTER_FILE = "sr_counters.json"
issue_counter = 1
enh_counter = 1
com_counter = 1

sys.setrecursionlimit(1500)  # Increase limit, but use with caution
# Override the built-in print function.
global target_lang
default_voice = "en-US-AvaMultilingualNeural"

PLATFORMS = ["facebook", "youtube", "youtube_shorts", "instagram", "tiktok", "720p"]
ALTERNATIVE_PLATFORMS = {
    "facebook": ["youtube", "720p"],
    "youtube": ["facebook", "720p"],
    "720p": ["facebook", "youtube"],
    "youtube_shorts": ["tiktok", "instagram"],
    "tiktok": ["youtube_shorts", "instagram"],
    "instagram": ["youtube_shorts", "tiktok"],
}
YOUTUBE_SCOPES = ["https://www.googleapis.com/auth/youtube.upload"]
CLIENT_SECRETS_FILE = "client_secret.json"  # Place your downloaded file here

#font = "Cairo Bold"
arabic_font = "Cairo Bold"

font = "Arial Black"  # Default
#font = "Almarai-ExtraBold.ttf"
#arabic_font = "Arial Black"
#arabic_font = "Almarai-ExtraBold.ttf"
font_weight = "bold"

#english_font = "Segoe-UI-Black"
english_font = "DejaVu-Sans-Bold"
# Global configuration flags:
PRINT_ENABLED = True  # Set to False to disable console output
LOG_ENABLED = False # Set to False to disable logging calls

# Global variables to store the current log file object and path.
global_log_file = None
global_log_file_path = None

# Save the original print function.
_original_print = builtins.print

# Base64 encoded strings for your icons
video_icon_base64 = "iVBORw0KGgoAAAANSUhEUgAABAAAAAQACAMAAABIw9uxAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAAlwSFlzAAJOjQACTo0BQHqWvAAAAe9QTFRFR3BM50w850w850w8z0Ey1EIz50w8yj4v50w850w85ks750w85ks730c450w850w850w8yj0v50w850w8yDwuzkAxxjst50w850w850w84Eg44Uk550w850w850w850w850w8zj8wwDkrxTstzT8wxzwu50w840o65Us70kEz50w840o650w8xDssyT0vxDosyj4v50w85ks7xzwuzD4w50w8xDssyDwu0UEywjos50w80kEywzos50w850w8yT0u50w850w850w850w850w80UEy40o650w850w850w810M050w800Iz50w81kM0yDwu0EEy50w820Y25Eo65Eo650w82kU2yD0uxzwuwTkrwTkrwTkrxTstwTkrwDkr50w8wDkrwzoswTkr50w800Iz50w8wDkr1kM01UM0zj8x0EEy50w850w84Uk5zkAxz0Ax0EEy1EIz00Iz2EQ140o60UEy50w80kIzzD4wwjos0EAxwDkr20Y3wDkrwTkryj4vwDkr3Ec31UM03kg4wzst00IzwTkr50w850w850w81EIzwDkr50w87PDx6YV6z3hv7O/wwTkr6HBk6rGr5009w0Q369DOyFtQ2qOe4sfF7Obm6ZCH0X5251pLwzos6ODg6eHh51lK6qCZ6YqB68vJLGcftQAAAIt0Uk5TAP7sDJICBOGoWA4gSBLc6Ykm+/b7B/prmS8aKb5Bts9U7zgX0v4YOhxSsRXA/Osg5WIm+Pny6++Pstea/oEyMeHTzFo9eiuhdPFDqW2EhfS5Zgs2RsdQk9XmLPdr0553j5jcoNmS/KnCxp1vbiO9faZlWW8xu5XI3fGscn1Wr6zyes9WiWDGe9p+TFzEGNoAACAASURBVHja7N3PThtXG8Dh2patYAy2bEVgYgMrqAwbI7FBAvFPIQixgDTfNguUVcKuyi2klXzRTdooX9KkLdjvAc2c57mBszjv/JgZZsY//QQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADyyp1u3/dPW+hwUwnrrtH+79dSRO6Pmy3Fn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"

"""
    <base64 string for video_icon.png>
"""

music_icon_base64 = "/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAUDBAQEAwUEBAQFBQUGBwwIBwcHBw8LCwkMEQ8SEhEPERETFhwXExQaFRERGCEYGh0dHx8fExciJCIeJBweHx7/2wBDAQUFBQcGBw4ICA4eFBEUHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh7/wAARCAQ4B4ADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6VooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooqOSaGM4eWNT6FgDQBJRVf7dZg4N1CCOxcD+tIb+zA3faIyPY5P5U0n2CxZoqmNStD9yQvz0VCSPyFSxXUcpxHHcMfQQOT+WKOV9h2ZPRULzhD80NyvGeYHHr7e1M+3W2cF2Uj+8jD+Yo5WFmWaKgF3akZ8+MfU4P5GlF1bHpPF/30KGn2ETUU1XRvuup+hB/z1FO60gCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKYZBhtoaQr1CjOOcdeg/E1HLOELIWiVhgAFtzEn2XP86tQk+g0myekJCgliAB1JOAKRLe8uNwhtrhwSMM2IlHqecn/ACahv2srHc2p6xp1hkj5QRJJgdhk/wAqfIo/Ey4UpzdopsmDbs7EaQqOQqk9ffp+tJMzxbTIIogx4Msyr+PUnFc5qHjTwlAzIP7T1Vj3Y7E/IkfyrNk+I9jFj7B4XtEI+60r5P5Af1rCWJw8N2epRyPHVfhpv8vzOyMim48kXkOSOBFE8p/MAA81JFaTTFlEepyDsVjWIevUkn9K87uvid4jkBFutnbDt5cPI/Mmsi78ZeKLr/W61dAHsjBP/QQKxeY0Vsj0qXCeNn8Vl8z15NIlMR82yjGOjXN4zZ/AAAVH9n02KMrNe+HIhn+NFbB9AWavDbm8vLnP2m7nnz18yQtn8yahPPWsnmnaJ6FPg2T+Op+B7i97o0DFj4p0OPHQRxx9fzNMXxBoMRCv41iyBgCKBBj6YBrxD6Clqf7Tm/snRHg2n1qv7j2qbxT4WIxL4tvjgfwRf4JVO48W+E4yGHiDW5VA5CFxn8sflXkNFT/aNTsbLg/DdZv8P8j1yLxd4TmYEa7rsAz0cuf55/lVy38UeFAQYvFupKT3eI/1SvF6T601mFTsD4PwvSb/AA/yPbz4j0Sb5YvG4yP4ZbdCOfqgpVvdLnbJ8aaNIBxtkgi6+/zA14hRirWYS7GEuDqfSr+B7wv2N1/daz4YnPU/ulB9ez1JHp14Fd0s9NuS33fs948efzBHrXgYUZzxn1xUkUkkTEwyyRk85Rip/PNWsf3Rzz4Nn9mp+B7obW9hhdptM1WNh0ETxzj9CDUE9zHbWweeaeFyfu3FlIuM+pAIryW18R+IbYjyNc1BPQGdm/QkjHtWrbfELxjDjGqrKB2lgQj8wAf1rRYuD3RwVeEsZC/K0z0mOfzCREYZzjIWGVWbHfKkg9aGuokIEu6E4/5aKVHUg8ng9PWuJh+JE07Z1jw9pt6cY8yMeW4/Ehv5itfTfGfhGQRRltZ0cqeFDGWLOD2y3H4DtWqq05dTy6+SY6j8VN28tTpEZXAZWDA9CDkUtZ9nLpWoKBp/iDRrx2kyFmTyZRk8j5SDnr1XrVq40/U4EdxZXYVcFTBMlwrZ6jDYb+fXjNWrPZnmSpyg7STXqTUVWa6WOURTBo3xnEqNER07OACckDAJNThxkA5UnoGGCfpnrQ0yB1FFFIAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooqCS6iU7VJkbHCqCSeMjpTSb2QE9RPcRJIIzIC/90cn1zgc1KtpdSxmabFtCoyXkbYAPzycfUD2rC1PxJ4U0gMDcvqU3eO34TPHU5wR70ScKavUlY6aGErYiXLSi2azyTOwSCMsxGAANx+mBx6dSKfPEbSAXGq3lvYxdC0zjJ9Pl6Z9ufSvPdY+JGrXCmLS4YdNhP/PMbnI9yR+uAa4+8u7q8lMt3cSzyHq0jFj+v1rhqZpShpTVz6fB8I4irrWfKvvZ6jfeM/CVoCkf27VXGBgfLH+pAx9Aaxbz4m3ygppOk2ViueCRvb+nP51wNFcFTMq8+tj6XDcL4GjZyXM/M2tU8VeIdSyLvVrllPVEbYv5LisYnJJJJOck56mkorklUlJ6s9yjhaNBWpxSCiilFJI2YClooqkhBRRRTSAKKKKtIAoooqkguFFFGKpIVwFKKBj1FFUkMKUCgCnAVaQmxKUUUVSRLYUoFAFLVJAIQGGCAR71d0/U9T08n7BqV7aj0jmZV/75zj9KqYpatNrY56uGpVVapFM6uw+Inie3Pl3cttqducBo7qEcjuMrjn6g1vad408NXYCXlre6JKSSzW582EsRgkrg8dD938fXzalxW8a00eLiuGsFXvyx5X5Hs1j5t3EZdKvrDVosgZtpQkgzkElCSMjg4yKDfxxOI7tXtXOflnUx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VlKiuh9Lg+Lq1Oyrxuj5yor1bXfhpZzbpNKna3c8+W/zKfYHqP1rgdb8Naxo7H7ZaN5eeJEG5T+I6fjWLptH12BzvB4yyhKz7MyAKWiikkercKQbllSaN3iljOUljYq6H1BHIP0paKaInTjUXLJXTOu0vxw8kUdp4ptW1CFOEvYPkuYvfjG4euCDxyDXXWVw01mL3S7ka3p3/PWEDz485OHTgkgEdAD1JFeSCpLG5vNOuxeabdy2V0BgSxnBI64YHhhnHBBFbRk+p8nmXDVKpeeHdn26HsVpcwXUIlt5VkX1HUE84IPIOCODzU1cJp3jCwvZVHiBG0q+bganZKfLc4wPNTnA6ZJBHuoFdcLt7cxLfGLy5j+4uoW3QzAjIIbkKSM8E844JzV+h8VicJWw0+WrGxdoo60UjnCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooppLM4ihQySngKD09z6D3ppXegBI6xqWY4HYDqT6Ad6q6xfWGkWX23W5THGR+6tV5klP9O3oBWZ4o8U6f4c3xRMl/q/YZzHb/XHf2HP04J8r1XUb3Vb57y/uHnmfqWPQegHQAegrixWYQw94w1l+R9Pk3DlXG2qVtIfmbninxrqmtq1rGfsNh0W3hOAR/tH+L9B7VzOPagc0o6V8/VrTqy5ps/R8Lg6OEgoUo2QUE0EgikqEjp82FKASRjk9ABXReFvB2s6+4a3hMNvn5ppAQuPbufwr13wp4A0XRFWV4xeXQ5Msg4B9hXdh8FUq62sjwMz4jwuBvG/NLsjyzwv4C1zWyspi+x2x/5ayjBP0HWvU/DXw/0LRwsjxfbLgc+ZKM4+g7V1yqFGAMCl7V7FHB06Xmz8/wAx4ixmNbXNyx7IRVVVAVQABwAMUpopK60jwG7hRRRTEFFBpM0ABNFFFABRRSE0ALmkNIaKACiiigApDQTmigAooooAKKSg0ABNJRRQAUUUhNACmkNJRQAUUUtACUuaSimkAUUUUwCiik60AB+tNdEdSroGUjBBGQfwp1FA02ndHIeIfAOkaiGktV+xTHPKD5T9R/8AqrzfxD4T1jRmZpYDNAP+WsYJH49x+Ne7011VwVYAjGCCMg1nKmnqe/l/EeKwjSk+aPmfNgBz6Ypa9j8S+A9N1LdNZgWdwc8qPkb6j/CvM9f8PanospW7tz5ecLKvKn8e30NZuDR9zgM9w2NVou0uzMjmlpPrS89qaR6MpiHBBBAII5BrS8O67qOgFobYJd6dIf32nznMbc5JU/wN15AwTyQTg1nDjmjOelUkcOLw9LEwcKiPUPD+oWmo2rT6FJLcxxL++0+U/wCk2/f5QT8y44HJ6AAk5A1raeK4j3wuGGcEdCD6EHkH2NeNRPLb3Ud3azSW9zEcxzRnDKfr3B6EHgjIINdro3i2z1CeOPXJE0zVOAmoRriG47bZV6KccZOOmQRwKpo+GzHJqmGblT1idrRVVLiaG5Wz1CIQXBBKEHdHKAeSjdDwQcHkZ6VapNdzxAooopAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRQSMEngdSTVW4u7aKze+u5vs9jGMvIeC/sO/NUlpd6IuEJTkoxV2yfJdHk8xYII8mWdyAqgdcE9T2rhfFvjoLFJpvhwvHE2RNeEYkkPt6D3/l3w/Gniu616UW0ObbTYiRFAp6/7TY6n88e/OeaArxcbmbl+7o7dz9AyThiNNKtild9v8xSSzFmJJJyTnJNLg0AUHpXjn2iSWiCkPWl5yAATmu28E/D7UNaKXd8HtLLqCR8z/QelbUqM6jtE5MZjqGCp+0rSsjldG0q/1e7W10+3eeUnt0A9SegFeueDPhlZ2G261ordXHB8sfcX/E12mhaJp2i2i22n2yxKByerN7k9zWkM969vD4CFO0p6s/OM24pr4tuFD3Y/iNiijhjEcSKigcKowKfQKQnFeifKN31YpptFFMlsKKKKACgmkJooADzRRRQAUUUhoACe1JRRQAUUUGgA6UhOaDRQAUUUUAFJmgmkOKACiiigAo470HpmkNAAfakoooAKKKDQAUGk60UAKKKBRVAFBoJpKACiiigAoopCaAAnNJRRQAVFcwQ3MLQzxrJGwwVYZyPxqWkJpMcZOLunZnnfiv4eJJuudFbYx5MDHg/Q9voa86vLW4s7hre6iaKRTyrDBr6IrK8QaDp2tW5ju4RvA+WRQAy/Q1LSufT5dxFVo2hX1X4ngvfml610finwlqGiOZQpntSfllUdB6Edq5wDiqSPrqWKp14c9N3QUOgdCrKCpGCCMg0uKM1aQpO5q+GvEVzo8S6bfiXUNEJ4hJ3SWvo0ZPOB/dz9Mcg+hWV2iRQyLdpeadcAG0vVPDDpsk/uuDkc4zgjggivKBV/QNYvNCndrZFuLSY/6TZucJJ6kdlb3xzgZBwMS4aHzeZZTGbdSktex60MEcHiisPSNRtmsvtunzSXOkk8hx++s26mNx1288H+YwTtxsroHRgykAgg5BB71m0fLyi4tpqzFooopCCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKRmVFLMwAA5JOMUO6ohdmCqByScAVga3rVpY2/2u/JABPkW4PzSn1PoP88nFGkVzSdkbYfD1MRNQpq7L2pajaWdmb/UZGitFPyoOHmbPQD04/nnpx5b4r8R3niC73y4htY+ILdT8qD+pqrr2r3utXpubuTIHEca8LGPQD+veqArwMbj5V/chpE/TskyCngYqpUV5/kFKOKB0oJGK81I+juBqfT7O5v7tLa0heWVzhVUZJrQ8L+HdR8Q3ot7KI7c/PIR8qD1z/SvdvB3hPTvDloFgQSXLD95Mw+Zv8BXfhcHKs7vY+eznP6OXRcY6z7f5nN+BPhzbad5d7rKrcXXVYiMoh9/U16IiqgCqAB2ApSM/WivfpUYUo2ij8vxuPr42o6laVxaKTNGa1scVxKKKKYgoooNABSE0uaSgAooooAKOlJkUGgANJRRQAUUUmaAFJx0pDzRRQAUUUUAFITQTSUAFFFFABRkd6DgdDTaAFNJRRQAUUvakNAAT6UlFFABSikopoBaQ9aKKYBRRRQAUhoJ9KSgA60UUUAFFFNzzSbAU0UUUhhRRSGgY2VI5YykiKykYKkZBHuK888Y+BAd97oqgHlmg7H/AHf8K9ENFNNo6sJjKuFnzQZ87SxyQytHIhR1OCrDBH1pgr2fxd4Ss9biaaMLBdgfK4HDex9frXkmrabeaXdtbXkTRuDwSOCPUHuK0i0z7PBZnTxcdNH2KlFJxRxVpHY2T6ZfX2k34v8ATJhHPgK6MCY5l/uuO49+o7EGu88OavaX0U1zpCeWEO670wnL27Z5aMn7yEnOMdTxgkgee9aSNri2vIr+xmaC8gOY5F7+oI6EEZBB4IJpSp32PIx+AjXXNHc9lt5oriFZYXDIw4I/l7GpK5Xw7rkN9BJqEEQikQZ1G0Xkx/8ATVB1KnuO3PXGa6iN0kRZEYMrDKsDkEHpg1zNWZ8tOEoScWh1FFFIgKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKCQBnOAKKxfEGrQ2kEm6XaiDMjDHHoB7nt9aata72RrRozrTUIK7IPEOr21pbm5nJMURIRBkGR+w/Q/QZ/Dy3V9QudUvnvLp9ztwAOijsoHYD/69Ta9qk+q3plf5YkyIoweFH9Se5/+tVACvnsfjXXlyx+FH6nkeSwwFNSkvfYgzSijoKDXnpHv3AnnrXUeBPB174kug7BobJD88xHX2FXPh14Jn16dby8DRWCHk4wZPYe3qa9ysLO2sbWO2tIljijGFVRgCvUweBc7TnsfHZ/xIsLehh3efft/wSvoWj2OjWKWdjAsUajk45b3NaAPOAKDnFHbivcUVFWR+bTnKpJym7ti0GikqkjNsSiiimIKKKDQAGkozRQAUUUUAFITQTSUAFFFFABRR0pDzQAE5ooooAKKKTNAAaCaQ80UAFFFHHegApCaD7UlABRRRQAUUHpSUABooooAKKKQ0ALRSClppAFFFIaYC0hNJmigAooooAKKCab160mwSFooopFBRSUhNACk0maKKACiijNAAelZfiHRLLWrQwXSDcASjgfMp9Qa06SmnbYqE5U5c0XqeGeJdBvdDuzFcIWiYnZKBww/ofasj8a+gNU0611Kze1u4hJGwxyOQfUHsa8f8XeGrnQrkkAyWrnKSAfofQ1vTmnufV4DM1XShPSRgdKXBNAFHSt0j0mxbae5sb2K/wBPmMN3CfkbnDDurDuD3H4jmu80DWoZrRr+zhZIFIN/ZDlrRjkmRAOsZIJIA4wSBwQOB9alsbu706+j1Cwl8u5jyASMq6nqjDPKnAyPYEEEAjKrS5tUebjsHGsrrc9gikjmiWWJ1eNwGVlOQQeQQe4p9cr4e1m1ltWv7FDHab8XdoTlrOQ9SPVCckEYB5IwQQOpRg6hlIKkZBHQiuNqx8zKLi2mhaKKKQgooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKp6repY2xkJG48KM9SaaVyoRc2kt2VNf1RLOFkVwH25Ynoq9ya8t8QatJqU+1WIt0Pyqf4j3Y+pP6fnVnxTq8t5cPbJLujDZkZeA7Dt7gdP19KwgOPSvEzDG879lT2/M/TeH8ljhKaq1F7zFAo6UE8UleSkfUBXcfDbwTNrs6318rR6ejA8jmQjsPb3/yIvht4Ol8QXgurpWSwiYbj03kfwj+pr3e1t4bW3S3t41jijUKqqMACvWwOC5/fnsfF8R8Q/V08Ph37z3fb/giWlvDa26W9vGscSABVUYAAqftSDpR1Ne3a2iPzdycndu7FpM0E0lNEsKKKKYgoopCaAFzSUUUAFFFGeKADpSGg0lABRRRQAUGg0lAAaKKKACiikzQAE0lFFABRRSE0ALSZopKACiiigAoJoNJQAUUUUAFFFIaAAmkoooAKUUlL0NNABOKTrRn3opgFFMkljjBMjqoHUkgAVl3viXQrPIuNTt1I6gOGP5DNTdLqbU8PVq6Qi2a9ITXF33xI0GEEQC4uCOPlTAP4kisO++KE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oAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACszX777Hak7wvBJJ7YHX6Y5/AVouwRCxOABXmfxA1gzzmzjfOSC/PRew9iTyfbFZ1qyoQc2erk+XyxuJULaLc53Vb+W/ujI5byxkIpPQZ6n3PU1TPWgmkr5ec5Tk5M/XqNKNKChFbBUlrBLc3EdvAhkkkYKqgZJJOMVHXrnwc8J+VENev4/3j/wDHujD7o/vVthqDrTUVscObZnDL8O6kt+nqdT8PPC0Ph3SFDgNeTANM/of7ua6rvRRkZzX0sIKEVFH43icTUxNWVWo9WLSUlFaHM2FFFFABQaCaTNABRRRQAUUUmaAAmkoooAKKKCcdKAA0ho60UAFFFFABSZoJFJQAH2ooooAKKKQ+9AAaSoLq9s7VS1xdQxDHJdwP51g6h468M2ed2opKwOCsQ3fqKlzjHdnTRwWIrP8Adwb+R0tFedX/AMVtNjyLPT55z2LkKP0ya5/UPilrc+RaW9tbDtkbiPxJrGWKpx6nr0OGMwq/Yt6nspOB1xVe5vbS2UtcXMMQHXe4H9a8C1Dxf4ivcibVJ1U/wodg/TFYs8807FpppJGPUsxJP51jLHLoj2aHBVWWtWpb0Pe77xv4Zswd+ppIw/hiBc/pXP3/AMVNLjJFnY3Ex7FiFH9TXkPU0AVk8XUex7NDg/A0/jbkzv7/AOKOsSgi1tbe3HbILH+lYF/4y8SXv+t1SZVP8MeEH6YNYA60uKzdWb3Z69HJ8FQ+GmiWe4uLg5nnklPcuxJP51FiilFSrvc9CMIxWisApRRSgVSRVxBTqKAKaQgpcCgUVaQmFKKAMUvWqSJbEFKKXAoqkiQpQKBS1SQBRR1pRirSE3YTHtS8DtR0oFWkZSmJS0dqUDOOapI55z0PcfAqbfC1iP8AY7fWtusnweNvhqx7ZiBx9a1a1Wx+R4x3xE35sOtFFFBzBRQeKQkUABoNJRQAUUUE0AFcr8QPDq6vZG5tkH2uEfKQOXA6g/0rqaCM9aunNwkmi6dSVOSlE+dpAyOVcEMpIIPUGmGu++KHhzyJTrFnHiNj++UD7pPf6GvPiRX1OEca0FKJ9DTrqrFSQpPvTYbiaxvYtQtUWSWE/NG2CssZ4ZGBBBBHqDg4I5FITzTc5r0XhY1YOEloRNqSaPVfB1/HPbJBC5ktHQS2UhUgmPOChOSNyHgjOcY4GDXQ1494R1I2Worp5dY1uJd9pIwJEdxjG0kEHa44I5GcYGSTXq+l3qX9os6KUYfLIjAhkcHDKQQCCD6j0PevicZhZ4aq6cjyKsOSRaooorlMwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooqOeQRxFm4Ayc+gpoaTbstzG8XarHYafIzEZAIAzgtnoB9Tx9Aa8juJnuJ3nlYs7nJJ9TW14z1c6lqbRo37mE7Rg8FuhP4dB+J71g18/j8R7WfKtkfq3DuWLB4dSkveYUUVNZW015dxWtuheWVgqrjk5OK4opt2R785qEXKTskdJ8NfDTeIdbXzVP2KA75jjg+i/jX0FDEkMSxxgBVAAA7CsbwVoMHh/Q4bOPBlI3Stj7zd63M56V9JhMOqUPNn4/n+avMMS2n7q2/zEooorrPBCiiigANITQaKACiiigAozSE0lACmkoooAKKDxSE5oACc0UUUAFFFIaAFpCaCaSgAooo470AIzKoJY4AGSTwAK4rxJ8R9H0uZre1U306/eCHCj23d/wrn/i34vlE76FpspVVGLh1PJz/AAg15eSScnrXn4jF8r5YH3OR8LRr01XxWz2R3+ofFLWZifsttb247HBY/mf8K53UPF/iO9J87VZ1U/wodg/TFYVFcUq9SW7PsqGT4GhbkpIkmnnmcvNNJIx5JZiT+ZqPNFAFRq9z0IwjHRKwAUoooppF2ClFApRVJA2IBSgUuKKpIlsBRSilxVJCExS0Clq0hXDilopRVJCuIBS0UoGapIVxBzSilxjtQKpIlsBS0UtUkISlApQKKaQBRQOaXpVpEuSDFB6Yo96B9K0SMZTD0paB1oPQ1SRhKQv4UIMsPcgCk7U+P76+uRWiic9Seh7t4ZXZoFiP+mK/yrSqnoi7NItF9IV/kKuUH5RXd6sn5hR0pCcUGgyA0lFFABRRSE0AKT6UnfNFFABRRSE0ARXcEVzbSW86ho5FIYEcHIrw3xlosmh6vJbHJiY7omI6gn+Y6V7sa57x3oS63ozoqj7TEN8R7k45H416eV4v2FVKWzOjDV3TlboeHE0hNLMrxSNE6lXUkEHggjqKjJ4r9ApU09Uem5jLlFmiaM5AIwCDgj0IPYg13fgLxD56me5kVZVK2+ojLAB8YjmAwQAw4PQZHTAzXCFqLG7TTNXiv5sm1dTb3qgDmJyAW6HlThhgZ4OOteXn2WqvQ9pFe9H8jnqJSR79RWV4Zu3uLA29w+64tW8uQnOXAAKvzzhlIOfXPpWrX56cTVtAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArlfiDqhstKaOJiJZvlXBwQO5/mfyrp5WCoSTgYyT6Ad/yryHxrqR1LWpNpBihJRQOnuf6fhXLjK3sqb11Z9Bw5l/1vFptaR1MMCiiivnbH6ulYCa9V+Cnhrcz69dx8D5bcEdfVq888MaVNretW+nwg/vG+ZgPuqOSa+k9Ms4dPsYbO3ULFEgVQB6V6eX4fmlzyWiPjeLc19hRWGg9Zb+n/BLNFFFe4fmQUUUUABpKKKACiig8UAFITQTSUAFFFFABQaCcUnWgAJooooAKKKQ0AGaSiigAoooJAFABVfUJHjsp5EwGWNiM+oBqeoNQ5sLgesbfypS2NKVnON+6PmnUpXn1C4mkYszysSSck8mq9OnyZpDjBLEnH1pteA9Wz92pJKnFLsFGKAKWhIsBRRS9aaQ9hKUCjApatITYAUoooqkhNhSgZoApapITYUoFAFLVJCCjFAFLVJCbDFFKKUCrSE2IBSigdaWmkS2AFFFOFUkIQCl6UUDmrSE3YKUetHsaD+lWkRKQfSj86BilHWrt2MJSEpffFB4pe3NWkYSkH6UnelxS9KtRMJTExkU+EZlQerD+dNqWzXddRD/AGwP1q0jmqztFnvmnDbYQL6Rj+lT5qO2GLaIccIOhz2p/WoZ+YVHeTfmFFFFIkKM0GkoAKKKKACiimmgBSaSiigAoPNFFAHknxa0D7FfLq1smILg/vQOiv6/j/SuAJ96+i9e02HVtKnsZwCsinBx0PYj3Br591Sym0/UJrSdcSRMVI+nev0Dh7H+3o+yk/ej+R20Kl42ZWxSOquhRgCCDkEZBzS9aBX0TV1ZmzZ1vw11hoFjinY7rMraXBIxuhYnyZDgAfKcqSSTjJr1KvALe7TTdTg1CVd1uQYLxQOsLnBPQ8qcMMDsa9p8MXr3NgYJ33XFsRFIx6uMAq/POGUg59c+lfl+c4H6niZRWz1Rz1F1NaiiivKMgooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKbIdqE5APYntQBg+N9UGnaNKytiWQeWgB5ye/wCf8jXkXXrznrXRePdUOoawYY2JhgGwDPBPc/575rna8HHVfaVLLofq/DeA+qYVSa1lqFHHeitTwrpUmta7a6fGCQ7jefRRyT+VcsIuTUV1Pcr1Y0acqktkeo/BTQPsmnPrNxHiW54iz1CD/P8AKvSahs7eK0tYraFQqRqFUD0AqavpqNP2cFE/EsyxssbiZVpdQoopCa1OEU0lFFABRRSE0ALSGg0lABRRRQAUGkJooAKKKKACikNBOaADNIeaKKACiikJ4xQAE0GkooAKivB/okw9Ub+VS1Hdf8eso/2D/Kk9jSl8cfVHzFcD9/J/vn+ZpgqW6GLuYf7ZH6mo68FrU/dqesF6C9qSilAppGmwCloHpS4qkiWxAKUUUuD3qkgbClAxRSgVaQmxBTqKAKpIQUooFFUkJsKUUAUvNUkS2FApQKKpIlsKUCjFLVJAAFFFAFWkJuwD60vAFH+c0Ae9WkZSmH1o7cUdTS1aRhKQCjPPFL1FGKtRMJSACigDmlAFaJWOeUwxxR16UYo4qkjCUwFWdMG7UbYDvIo/UVX61d0Fd+s2i+syj9RVpWRy15+4z3eIfIv0p1IgIUZGOBSk4rnPzl7hSE0E0UAFFFFABSE0E0lAAaKKKACiiigAozSE0lACk15l8YtD5j1mBMZ+SbA/In+VemVV1exi1LTZ7OYArKhU57Hsa78txbwmIjUWxUJOMkz5zxSMDVvU7OWw1Ga0mBDxOVOR1wev0NVjj0ya/UITU4qS2Z3XvqRSIskbIwBVgQQehyK6n4Ya1JCYbedjutZVsJyc4aNgTC5wAMggoSTnn6VzIFGmutrr8TsxWO+Q2kjbSwViQY2wCOQ4HPoTXg8RYP2+G9olrH8upm2noe/UVR0G9/tHSbe6ZdsjLiRcY2uDhhg8jBBq9X52YhRRRQAUUUUAFFFFABRRRQAU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WfrWh6fqtq0E9vGGI+V1UBlPqDTVRdjljn6crSjZHhfpSgY+tanifRpdE1NrSRhIpGUYDqD0/GsuuqNmro9VVozipRFJ9a3fAS7/ABTZ8Zw2fyBrBBro/hwufFVufQMf0NVKNos5cVP91L0PYqKKaa84+PFJpKKKACiiigAoopMmgANJSnmkoAKKKKACiiigAoNITRQAHnOe9eKfEfSzp3iSUquIpx5inGB7j869rriPi5p/2jRI75R81u/zY7g9f1xXt5DivYYtJvSWg07Hk3UYplPphHNfoqYpS6lLUZFs5bbUim5baUGVdgYtEwKuMH1UnntjPavafAN21x4djhkYtJaO1sxII4U/L15+6V5rx+4jE1vJE2cOpU49CK7X4Makzo1jMzb5IA4DEEl4yY3PA7gKeTnHtXw/FOG5asay6mtKXNBrselUUUV8oMKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopHOxGbGcDP5UAcH8T7v8AcR24I+d+R6gf/XArga6Hx9c+frPlBsiJcY9z1/kK56vDxkuaqz9a4dw/sMBDTfUKu6DZNqOr21mgJ82QKcdhnk/lVKu7+CunfavE73bAlLaMnp3PT9Aazow55pHdmeJWFwk6vZHtVnAlvaxQIoVY1CgDtipqKK+i20PxGUnJtvdhRmkJHakpkhRRRQAUv1pKQ0ABooooAKKKQ0ABpKKKACiig8UAFIaDSUAFFFFABQaCaSgAooooAKKKQmgAzSN900UHofoaBx+I+cvEI/4n18B/z3f+ZqgK0vEoA8Q34z/y3f8AmazgM15LWrP3LCv9xD0ClpaKaRuFKKBRVJCbClxQBSjmqSJbCgClAxRVJEhSgUYpeM4FUkK4Cip7azu7kgQW8spPQKhP8q2LLwd4iu8FNOkQHvIQo/XmrUWc1XGUKK9+aRgijHpXc2Xw21NwDdXcEI7hcsf6D9a27L4babGQbq8nmPcKAo/qa0UGeRX4jwNPRTv6HlfWnxQyynbFG7nsFUk/pXtll4P8PWoBXTo5D6yEt/M1sW9na24CwW0UQHACoB/KtFE8evxbSX8ODZ4hZeGddu8GHTZ8Huy7R+ZxW3ZfDvWpgDPJb24PYsWI/ACvWuB2FIaaSR5FbifFTvypI4Cy+GtsADd6hJIe4RQo/M5rasvBHh+3wWtGmI7yOSD+AwK6WimeZVzXF1fimynaaXp1qALaxt4sdCqAGrYAHQAfQUtB9M0HDKpKT95sQ0h5oooJCiiigApCaDmigDzH4trjVLdsDlM/y/wriDXc/F4g6hZgEZ8s59eoxXC5r0qEbwR9Rgm/YRDPpXU/DAZ8UIf7qMf0rlc9a674VKT4gZhztib+YrerG1NseLl+5kermiiivGPlUFFFFAwoNITRmgANJRRQAUUUUAFFFBoAKQmjrRQAUUUUAFUtbtFvtJubVhkSRkDpxxweau0daunNwkpLoB86XMLwXMkDghkYqR9DUTgYrpPiJYfYfE04VcLLhx+PU/nXOkcEV+p4Wsq1KM11RzynZkYHPNWfAl4ul+LowfkjNypOHIyJQUJIJxgOqnI9frVY1Qv3eDUbWeNljeQNCGI5DEbkwccHco+uea83iCh7XBtrpqVhan7yz6n0TRVPRr1dR0m1vo1KrPEsm0nJXIBIPuDx+FXK/ODsCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoo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Tix+Kli5bAmdcjoTuR0AB9zt/QV77X5fmdP2eLqR8z6ihPnpQl5f8AKKKK4DQKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvKviHMZNUVeDgE4HbJr1OVisbMOoBIz9K8d8WyF9akUnIRQAa5sU7Uz6Thanz49PsmZFFFAryUj9SPRPgXbh9du7kg/u4dvTjk/8A1q9lrzH4DQbbLUJ/7zqgP0Gf616ceK9rCxtTR+RcT1efMZrtYDSZo60V0HzwUUUUAFIaCfSk60AFFFFABRnAxSE0lAC0lFFABR0opDQApNJRRQAUUUmaAA0lFFABRRRQAUhoNFABRRRQAUUUUDW54H44yPFeoD/pqaxwK3PHgx4u1D/rqf5CsOuGS1Z+05frhafogPpXrPwbI/sCf184/wAhXk4FesfBv/kBXH/Xb+grWkvePG4p/wBwfqjuaKKK6T8wCig0maAAmkoooAKKKCaAAmkoooAKKKQ0ALSGjNJQAUUUGgAoJpCfSigA75ooooAKSgnFJQAGiiigAoooPSgDxv4nPv8AFc/sigY9hXLGuk+JQI8W3XfgY/KuayRX2eDp/uYs+gou1NATXqPwcXGlXb+suP0ryxuv1r1n4QJjw/K3rMf5Css2VsKc+Nl+7Z2tFFFfInjhRRQaAA0maKKACiiigAooooAKKKQ0ABNJRRQAUUUUAFFFFABXknxNh8rxQ74wJEVv6f0r1ok9682+LUONQtZ8DDIVJ+h4/rXucP1OXF27o4cev3TZwzDg/SoQOKnxmoSOTX30WfN1Khgas/2Xxbo91gk7wcg4+46sPr0J9+lfSCk7RnqQM181eN/k+wTgEkSsoweeUY4HvkCvpCyk820hkOMvGrHByMkA9e9fnnEEOXGyfex9Tlc+fCR+ZNRRRXineFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAEN5gWk24gDY2Sfoa8Y19i2sXJPOH/lXsmpkiwmOcEL1rxbVWDalcN6vXJjPgR9fwfG+Kk/IrCl6UUvavOSP0bY9p+CMQTwxLIOsk5P0xx/Su9rkPhCir4NhK8Euc115Fe1RVqaPxbOp8+PqvzCiiitTyxDSZoPNFABRRR2zQAUhPGKDSUAFFFFABQTig0lAAeaKKKACg0U2gBSQRSUUUAFFFFAAfakpaKdgEopcCmniiwC0UUUhpBRRSE0DR4X8QRjxdf/AO/n9BWEK6H4ij/irr33YH9BXPVyyXvM/Zstf+yU/RfkB6V6t8G/+QHcf9dj/IV5V2r1T4N4/sW6/wCu5/kKumrM8jih/wCwv1R3dITQfakrc/MAooooAKKCaSgAJOfaiiigAoopDQAGkoooAKKKCaAA0nWiigAoooPFABTTQaKACiiigAoooNAAaQ0ZpKYHifxEcnxXecg4PGPpXOZNbfjh9/ii+JOcPgfkKxM/pX3+Dp/uY+h7lN+4kBOOK9g+Ey48L5x96U/0rx0nFe0fC5AvhKHAwC5P61xZ6uXCr1OXGP3DqaKDSV8YeaKTSUUUAFFFFABRRR0oAKQmg0lABRRRQAUUUUAFFFITQAppDzRRQAVwfxajzb2cuOAxXp7V3lcb8VkLaLA+OBN/MGvTyeXLjIHFj/4EmeZD2qFhhj9asAVA4w5wO9fosdz4ypUOb8eqTYWjDI23KgcdMggH9T+dfQPhiUz+G9MnYYaS0icj0ygOP1rwLx2QuiI5z8tzEQO2dw6/hmvcfh5IZPA2iszBmFnGpIHHCgYGfp17+g6V8LxIrYpPyPrchnzYT5v9Deooor549kKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAKetEjTJ/90DrjuK8WvDuvJmH98/zr2rWf+QXcf7hrxa7GLuUejn+dcmLXuo+y4Ot7efoRAUuKAKU9K4kj9BbPfPhUmzwVZ9s7j9ea6muc+Gwx4L073jz+ddEa9mn8CPxPM3fGVH5sQ0lOpDV2OASijFFIApDQelJQAUUUUAL2zSE0EZpKACiiigApD0paKaQCE5pKKKQBRR0oppAFFFFMAooJpKTYWA0UUUigoopDQAZFIaKKAPEviOMeLrvPqD+grnRXS/EsY8X3f/Af5Cua5JrC12fr+Wz/ANjp+iDnpXqfwcP/ABJrof8ATb+gryz2r1L4OcaRd/8AXb+gq4rU8niWV8C/kd3RRRWh+bBQTSGigAooooAKQ0pNNNAB1ooooAKKDSEkmgAJooooAKKKaaAFJpKKKACiiigAoopDQAE0lFFABQelFB4+g5prcDwTxex/4SS/zx++YfkcVkk89K0fFUgfxDfNgAmdgceoJFZZOR6V+mYSn+6j6HswfuoUn3r3D4cLt8I2h7sCf1NeGk817v4CXb4TsB/0zz+ZNeTxIuXDR9TkxTvFG6eaKKK+IOEKKKKACiikJoAWk60lFABRRRQAUUUUAFHSgmkoAD9aKKKACiiigArlPifz4fXjgSj8/wDOa6uuY+JYB8NsSORIuPzruyx2xUPU48f/ALtP0PKhUMn+sNT45qNx85r9Ii9T8+q1NDm/iASvhid/7joSPXDD+uK9m+FEgk+H2kMGz+5xnOejEf0rx7x4oPhi5zn7yAY9S4H9a9h+FChPh5oyhQP9HDEAY5JJP8/zzXxXEv8AvEfQ+x4ZnzYWX+L9DqKKKK+bPogooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAq6qCdOuAM/6s9OvSvF70D7bKD13HP1r2vUf+PCfpyjA5Ge1eMakAL+X03VzYle6j6/g9/wC0z9CtSigDNLXGj9DZ778NGDeDLDHZMHn0rpK5b4Vkf8Ibac55b8OcY/SupPWvXp/Cj8UzRWxlRebFpDQaTrVnAKTSUUUABptO6Uh60mAh9qKOlFCQBR1ooJpgIRRRRSsAUUUhpgB4pKCSTRSsAUUUUwCgmkNFJsaQlLRRSGFIeKDSZoAM0UUUAFFBpCaAPGPiaP8Air7r3C/yFcx9K6n4oDHi2f3Vf5CuY5rNrU/Vstn/ALHT9EJ0r1D4N/8AIJvPaYfyFeYH9a9O+DhI0u9/67D+VWlZHmcRSvgpfI70mkoopn54FFFB4oAKQkUGkoAKKKKACg0hNFABRRRQAUfWkJpKAA0UUUAFFFFABQaM0hoADzSUUUAFFFFABQ3KntkH+VFNmbbE7f3VJ/SqjrIEfPWvMW1m7OSczNyTknk1RJ496saq5bUbhvWVj+pqoSScV+s4eCVOPoereyQuckfXmvf/AAcNvhqxXp+6HGMdRmvAUHzAepr6E8Nrt0GyX0hX+VfN8VS/dQXmcmIldaGjRRRXxByhRSE0hoAUmkoooAKKKKACiig0AFIaMmigAooooAKKKKACikpKAFJrmfiT/wAi0/rvXH510tcr8TTjQVGOso5/Wu7LdcVD1ODMpcuFm/I8yAyKik++e1WAM1C4+c1+jRep+ZVamhzvxAOPDEoGAWkix7/vFr2j4bIsfgLQ1XO37FGwyecFQRn35rxP4iHGgKOxuIvx+YH/AOv+Fe4+AU8vwToqHtZRf+giviuJH/tK9D7vhR3wcn/e/RG5RRRXzp9OFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAEd1/wAe0oPPyH+RrxfVlxqMw9GOBXtbAMpX1BrxzxDEY9WnU/3j/OsK6vA+o4Tny41rujOpQKKWuNI/Sj274Qyb/CKDJO2Rh9Oc12JrgPgrPu0G4hz9yX+grvq9Sl8CPxrO4OGPqLzA89aKKK0PKCikJxSd80AKaSiigAooNBOe1AAaSiigAoopCaADNJRRQAUUUZoAKTNB5opNjSCiiikMKQ9KCc0lABRRRQAUGg02gAooooA8e+KY/wCKrl/3EP6VyuO1dZ8VR/xVT+8S/wBa5TFNI/TMun/slP0Qn0r074O4/s69/wCuo/lXmXHrXpvwe/5B97/10X+VU1ZHn59K+EfyO8oopCag+DAnFGaTrRQAUUUGgANIeaKKACiikoAWmmg0UAFFFFABRRQTQAHikPSg0lABRRRQAUUUUAFFBpKAAn0pk5xBIf8AZJ/Sn1Bfttsp29EJ/Srpq80gPna/Ie9mYEEFyQQMZ59KiA9qkmy0zEkkliST9aQD0r9bhpBHTOrZWHQKDKgJ6sB+tfQukLt0u1XGMRKMfgK+frRN1zEPVwP1r6FsV2WUKnsi5/IV8nxVL3aa9Tlc+Zk9ITQaSvjRhRRRQAUUUUAFFFISe9AATRRRQAUUUUAFFFFABSEjtRntSUAFFFFABXI/FBsaRbJn702ceuAa66uI+KcmUsovdmI/IV6WUR5sXA8nO58mCmzgwM1Ewy5+tWDgdKrNyT9a/QIs/K6s2zlfiT/yDLVRyDcLkDqcAn+lfQXh5DHoOnxnGVto1ODkcKBXz549DTz6TYoCZJrn5T6HG38ssPyr6OgjEUEcSgBVUKABgAAYr4fiCSeKsfpfCkWsAvVj6KKK8I+lCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAryjxzCIddmGCMsSOOoPP8AWvV682+JsQTV0kxgOoOR64x/Ss6qvA9rh+r7PHw8zlRzSgUCiuNI/Vrnp3wPnIOoW5PGFYD06gmvT68a+DVx5XiaSE9JYDx9K9lrvov3D8p4opcmYSfewUhNBpK2PnQooooAKDQaTNAAaKKKACikNJQApNJ0oooAKKKTJpNgKTSUUUXGkFFFIaQwNBpOtFABRRRmgApCaCaSgAooooAKCaCaSgDyP4rA/wDCUk9zCp/nXJcmuu+K/wDyM4z3hX+tcj0rWKuj9Cy+f+yw9Ba9L+D3Nhff9dF/ka8z/GvSvg9/x433++v8jVSWhxZ1K+FaO+PXFJRRWB8UFFFITmgAJooooAKKKQmgAJpDRRQAUUUUAFFFJmgANJRRQAUUUUAFFFBoAKCcUZpKACiiigAqprLbNJu29IWP6GrdZvidgnh6/bOMQN/I1th1erFCeiueBSD962BgZ4/OkApx5Jx60oFfq62OapV8yxpilr+AY5Mg/nX0DCAIUA6bR/KvA9DTdrFoPWZf5ivfUwEUYwAP6V8dxQ/egvUMPLmuLRRRXyZ1BRRRQAUGkNFAAeaKKKACiiigAoopD7UABpKKKACiiigAooooAK88+J0obVbaLP3Ysn8Sf8K9CJry3x9N5viWYA8Iir+Q5/nXtZDDmxV+yPnOJ6vJgrd2YLnAJqv1GalkPymoc19zE/Mqj1MIxf2h8UfDljtyIpRK3POAwbj14jNfQleE/DqE3/xpkk4K2NsSBnkfKB/7UP6Cvdq/PM4qc+LkfrvD9L2eApryCiiivMPZCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArhfipDlbWfpg4PHXB9fxruq5r4jWv2jw8zgZMTAj8aT1TR1YKr7HEQn2Z5kOnFKKSI5QEjBIH4U4Vx2sfscZKUU0b3w/uvsniyylJwGfyyc9m4/rXvZJJ9q+bLKY297BOvBRww/Ag19HWUyz2kUynKugYH8K6qGzR+fcY0bVYVV10JaKKOldB8WFBpDRQAUUUUAFIaCaSgA60UUUAFBNBOKSk2FgNFFFIoKKKaTQAuaSiigAoopCaAFNNo75ooAKKKCaACkNB65ooAKKKQ0AeUfFn/AJGSM+sA/ma4+uy+LYz4hiOOsA/ma4zvXTBaI+5wErYWHoB6V6V8Hv8Ajzvv99f5GvNu2K9J+D/Frff7y/yNOovdOTNpXwzR3tBNBNJXKfIh1ooooAKSgmkoACaKKKACiiigAooPSm0AKetJRRQAUUUUAFFFITjgUAKaTrRRQAUUUUAFFFFABWP40fZ4X1A5x+5I/pWuTXNfEmcQ+FbgZGZCEx65NdWBjzYiC80RUdotnjA604DmgD0p2K/UjxalU0PDCbtfswOvnKQPxr3Y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6tgIfP8AMKKKK8w9oKKKKACikzSUAKaSiigAooooAKKKMigApDRRQAUUUUCMTxpqAsNDmKkCSUbF55GeuPoM15OTXTfELU/tur/ZkbMVuNvXgseSf6VzBNfeZNhfYYZN7vU/JuJsw+tYxqL0jp/mNbk89Ko61eLY6bNccFlXCAnGWPAH5kVcJyao2tj/AMJF4x0/QlwYYj591xkBR2Ppkcf8CFduPxCw9CU2eblGCljsXCl56+h6J8IdCOi+EopZlH2q9P2iViBk5GVBPsDnHqTXZUiqFUKoAAHAHTFLX5rOTk3J7s/b6cFTiox0SCiiipLCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigDkPifpZutKTUYR+9szk4HJQkZB9v/r1wMTCSNXA4YD8K9qniSeB4ZAGSRSrAjqCMGvGL+zfSdbutLkJwjExE/wASnkfpj9aaR9Pw5jfZzdCT3EqexuJLS7iuYjh42DKR9c1D+FFWon1tRqUWnsz3/QNQj1XSbe9jIIdRuA7EdR+dXzXl3wm1vyLqTSZ3+SX5osngMOo/H+leodaGrM/M8xwrwteUOnQKKKKRwhQaCR2ptACkkmkoooAKKCcUhNAAaKKKACijpSGgANJRXLeMvFsGjoba2xLekcDqE9z7+1VGLk7I0o0Z1ZcsTe1PUrLTYDNe3CRKBxk9fYDqa4fWviLgtHpVsMdBLL/MAf1NcNqV/eajcm4vJ2ldieSeAPQDsKq11U6C6nvUMspwV56s1dT8Q6xqLE3N5IQRgqpwv5CspmLHLEk+5zSZ5oPX+tdkKSXQ7lGMNEgJpCTQetNJPrXV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bN7CH60hrSstC1W8YeRZS7SfvMu0D8TXRaX4Encq9/crEOpRBkn8elcdbMMPQXvyO3DZVi8S0oQZxsMUk0ixxRs7scBVGSTXbeGfBrFlutWGAOVhB5P+8f6V1ek6Lp2mJi1t1VyOXblj+Jq+TXzmOzydVOFHRH2GWcMQotVMQ+Z9ugiIsaBEUKqjgAYApc0ZpK+fbvqz6xJJWQUUUUhhRRRQAUUUhoAUmkoooAKKKKACiikJoADQeaSigArk/iDrYs7P7Bbv+/mHzkHlV/8Ar1v61qMOl6fJdzEYUfKO7N2FeQaleTX97JdTsWeQkn2HYD2Fe9kmX+3qe1mvdR8jxVnCwtH2FN+9L8EQU09falOe9IemSQB619utD8rbuUtYvl0+xecgGTpGpONznoP89ACa9B+E/h9tJ0H7ddLm+vsSSMRyF5IHtnJP4gdhXH+BNE/4SfxCdRuU3aVYnEanpI/rjuD/AC/3q9jGAOBxXw2eY/29T2cHoj9Y4Tyf6nQ9vUXvS/IKKKK8A+wCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAqhr+lW2s6XLYXSjbIPlbAJVuxHuKv0UbBseJmC4sbyXTL1Ss8Bxk5w69mH14qT8K734h+H21KyGo2Sf6faglQP407qfU+n/ANevPradZ4g44PRlPVSOoNdtKakj6jAY320OWW6Ja634deIv7MvRZXTn7LO3BJ4RjwD9D3rkiaAcHNaOKkrHTiKUa0HCR9DAggEEEEZBHcUtcN8N/EwuoF0q9cCaMfumJ+8o7fUV3BOa45RcXY+Or0JUZuEg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AAkGrW7C0hOLWFxwxB5JH1Az6kAdjn1io7aGK2gjghjWOJFCqqjAAHQCpK/OsRiJ4io6kz9twWDp4OjGlTWiCiiisDqCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigClrel2mr6dLY3iBo5BwR1U9iD2INeR3trdaLqbaVqAyRkwy9pEzwfr7f5PtNYvjDQLfxBpbW0mEnTLQygco3+B7itaVRwfkdOGxEqErrY8wPFITVbdc2d7JpmooYruI4IPRwP4ge+etS7s172HhGcU0e6qsZxumaWgazdaNqC3dsxxn50J4Ydwa9n8PaxaazYLc2rDOPnQnlT3BrwQmtLw7rl3od+tzbMSpOHQnhh6H/ABrTEZf7aN47nBjMOqqutz3ukJ/Oszw9rVnrdgtzauM4G9CeVPoa0q+enCUJOMlY8Npp2aCiiioEFFFGaACmSokqGORQyEYKkZBHuKd1pKadtUBwnib4e210zXGkyC3kOSYmyUJ9j2rz7VvD+r6Y5F3ZSqo/jUblI9iK98pHRXUq4DAjBBGRXsYTOq1BJS95HTTxU4qzPm48Eg8EHkYppr32+8M6DeEtPpluW6llXafzGKzpfAXh1jkWzKPQN/k17lLiPD296LRt9bi+h4lnmkJxwa9oHw98OKSfJmJPrIcCpo/AnhtSCbIuR6uf/rV0/wCsuES2YniYniABJ55qzaWN3cttt7WWUk/wISf0r3a18NaDbEGLS7YEYwWQMf1rTihhiULFEiAdAqgD9K5avFUbfu4GMq7Z4xpXgTXrwAvbi2UjrKcH8utdnofw60y0Ky38rXjjHy42oD9OpruKK8XE59i691ey8jBtsjtoIbaJYreJIkXgKoAAH0FSUUhNeNKTbu3diAmkoopAFFFFABRRRQAUmaCfSigAooooAKKKKACikJpDzQApNJRRQAUUUUAFFFITQAtITSUUAFFFFABRRRQAUGg0lAAaKKKACiiigAoopCaAAn0pKKKACiiigAoorM8Q6zbaPaGWUhpGB2Rg8t/9b3rSlSnVkoQWpjiMRTw9N1KjskHiLWbfR7MyysGkIxGgPLH/AAryjU7651G8e5uXLMxyBngDsB7U7VtRudTvGurp9zMeB2UdgKpk191lmWRwkOZ/Ez8iz/Pp5lU5Y6QWy/UMikpaqsl5qV8ukaShe6k++46RL3JPY4/L34z6FfEQw8HOb0PHwWDq4ysqVJXbIo4bvX9WXRNMyQTi4lAOFHcZHt1PoQByRXs2g6TaaLpkdhZR7Y0GSSBlm7k47/yAAHAqp4Q8OWPhzTFtbZd0rfNNKR8znv8AhnPH4nJJNbVfnuYY+eMqOT2P2nJcopZZh1CPxdWFFFFcB7AUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQBz/jPwxa+IbMciG9jH7mcDkH0PqK8skW6s72TTtRjMV3GcYPRx2YHuDXudYHjLwzaeIbIBj5V3ECYZ1HKn39QfSu3B4uWHnrsb0K7pPyPLCccmmE0ydLqwv5NN1KIxXUfr0cdmU9wf89wAmvuMJyVoKcNj0faKWqNPQNZvdEv1urSQjBwyE/Kw9CK9n8LeIbLX7MTW7hZlH7yInlT/AFHvXgZbNWNK1O70u9S7s5WjkQ5yDwfYjuKnH5NHFwvHSSOSvSVRX6n0bRXLeCvGFnr0AhkKwXqj5oycBvUr/hXUE18NiMPUw83TqKzPNlFxdmBNJRRWAgooooAKKKDQAUhNFFABRRRQAUUUUAFGaQnFJQAppKKKACiiigAoopMigBTSZoooAKKKKACiikNAC0hNGTSUAFFFFABRRRQAUHikJoJoADSUUUAFFFFABRRQTQAGkNBooAKKKKACiijjvQAUhoJpKADNFFFABRRRQAUUdOtc34r8TwaWhgtyst2RwAchPc/4Vvh8PUxE+SmtTkxmNo4Ok6lWVkXPEuvW2j2x3EPOw+SMHk+59BXluqX9zqN21zcuXdunoB2AHYUy8up7u4a4uJGkkc5JJ/zxUGTX3OXZZDBxvvI/JM8z6rmU7bQWy/zAmgdaKozTXd5fJpOjwm4vpOCQMrEOMlj0GMg4/Gu+vXhQg5zeh5GEwlXF1VSpK7Y+R7q8vY9K0pPNvZTjIGRGD/EfTjnn0ya9S8FeGrXw5p3lIfNupDunmPJY9wCecZ/PrTfBXhi18O2IHE17IMzznkse4BPIGfz/ACA6GvgczzKeMn/dP2PIcip5XS7ze7CiiivLPoAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAOf8Z+GLXxHY7HIhu4+YZwOVPofUHuK8k1K21DR9ROnatAY5efLkHKSAdwa97rP17R7DW7BrPUIFkjI+U9GQ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gAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKyvEegaZr9p9n1C3DEZKSLw6H1BHP4dD3rVoppuLugPE/E/h3VvDTmScG808sdtygyUGeA4A4+vSsyCWOZN8bh1I4IOa99kRJY2jkRXRgQysMg57EHrXA+JvhvazPJe+HpV0+6PzGEjMLn0x1X8OPavqct4jnStDEarv1FJNnCZI6dKcDmmXsV7pl19j1a1e0nzgFh8j47q3Qj8aX3FfY0MTSxEeenK6Oeo3EtWdzcWcyz20zxSKchlJyK77w38RJECwazH5g4HnIMEe5Hf8ACvOlPY8inrz0rDF4Chio2qR17nO6tmfQOnajZajCJrO5jmU/3TyPYjqKtV8/6ffXlhOJrO4khkHdTjP1Heu50D4huoWLV4dw6GWMc/Uj/Cvkcbw9WpXlR95fiXHER2Z6PRVLS9V0/U4xJZXUcoxyAcMPw6irtfPzpyg7SVjdNNaBRQaTNQMUnFIaKKACiiigAoopDQAGgmkooAKKKKACiiigAoJxSGkoAXNJRRQAUUUUAFFBoJz2oACaSiigAooooAKKKQmgBelJmk60UAFFFFABRRVLU9V0/TYy15cpGccLnLH6Ac1cKcqkkoq5lVrU6MeapJJF2quo6jZ6fEZLudIh2BPJ+g6muK1nxzNIGi0yERKePNcZY+4HQfjXIXd1cXcpluZnlcnlmPNe9g8gq1LSraL8T4/M+MaFFOGGXM+/Q63XvG80u6HS0MSn/lowyx+g7VyFxNLPK0s0jO7HlmOTTM0n1r6nDYKjho2po/P8fmuJx0+atK/l0DrRk0hPGScD3qvayXWpXQs9FtXvZ84ZlH7tBnGS3A456HqMZFaV8RToR5qjsc+EwVfGTVOjG7JJ54oIjJPIsajqScfh7mnaRomveJ5FFmjafpjH57pxhnHcIOv+eorsfDXgG3t5VvdelXUbrqqEfuoz7A9fx/HPWu3RVRAqqFUAAADGMdgK+SzDPp1LwoaLufpOS8G0sO1VxXvS7dP+CY/hTw1pnhyyFvYxEu3Mkz8u57knsPYcfjzWzRRXzjbk7vc+4jFRSSVkgooopFBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAFXU9OsdTtWtr+1iuIj1V1Bx7g9QfcV5t4j+H2oafuufD8jXcAyWtZWG8f7rd/of1r1OiunDYuthp81OVhSipKzPn6K6Xz2trhHtrlDhoZQVYH0x+FWRntXsWv+HdH1yIpqNlHI2MCQDDj6MOe9cDrPw/1fTwZdGuf7QgHIgmIWQewbp+eK+uwPE1OVo4hWfc4auFlvBnPK5HXJqRSDVZ5Hgn+z3kEtpcDrHMu0n3GeoqXtX0lOrTrR5qbujy6jlDSSLVvPPbyiSCV4nHRlJGPyrrdF8eanaBY71Vu4xwSeGH49/wAa4pXYe4qRGX6GufE4KjiFapG5h9ZlB+6z2TSPF+jajtT7R9nkP8MvH4A9DW+jKyhkYMD0IOQa8AFaOma1qmnMDaXciAfwk5X8jxXzuJ4ci9aMvvOmnm1tJo9vorzvS/iDOm1NRtVkGcF4zg/XBrp9N8V6LegAXQhcjJWQbcH0yeK8KvleJofFG53UsfQqbSN2imRyRyIHjdXXGQVIIP5U4mvPaadmdiaaugJpKKKQwooooAKKKQmgBaTNJRQAUUUUAFFFFABQTigmkoADRRRQAUUUUAFFITSUAKTSUUyWWOJC0sixr3LEAfrTScnZEykoq7dkPorC1DxZotoCBc+ew42xDPI9+lc1qPjy7lBWxtkgH95zuP5dK9DD5Viq+0bep4uM4hwGFT5p3flqegO6xqXd1Ve5JAx+dYOq+LtIsSUWU3Mg/hjwQD7npXnGoapqF+xN3dSSDOdpOFH4DiqZzXu4bh2C1rSv6HyeO42qSvHDQt5s6bV/Gmp3eUtttrGePl5b8Sen4Vzcskk0hkldpHJ5LEkn8TTM+lGTXvUMLSw6tTjY+OxeY4nFy5q02wzRnNHbnpVGXU4WuRaWiyXt0TgQwDcQTwMnoPxNaVa0KS5puyMKGGrYmXJSjdl7pVSa8Hni1tYpLu6JwIYRuIJ6ZPQfjXQaL4G1nVAJtcuBp9sefs0BzI3szdvoMV3+iaHpeiwCHTrOOEY5YDLN7k9TXzmN4ihH3aCv5n3OVcE1J2ni3ZdluefaL4C1XVnWfxFP9ktOCLSAnc3QgM35gj9O9ej6RplhpNotpp9tHbxL0VRjJ9SepPuauUV8tiMTVxEuapK5+g4PAYfBQUKMLIKKKKwOwKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAKWraVp2q25g1C0iuI8YAYcj3B6g+4NcHrfw5uoCZvDuoDb1+y3RJX6Kw5H0I/GvSaK6MPi62HfNTlYzqUoVFaSPCr2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+nkBjcbB1BdWUfmQK6oYvDz+Ga+882pgMZT+Km/uNMOPf8qN6/5FZ6alYP8AcvIGz6OKmS5t35WeM57hhWynB7M5ZU6sd4v7i1vXsRQSvqKriaI9JU/BhSl1zjIz2561V49zK0+xMWX1FJkdelRFhjORn60nmJnl1BHXJFO67k2n2JSwo3cVA9zBGMvPGB7sKgk1PT48772BfXLipdSC3aBUqsnpF/cXSw96C3es8atYnGycyZOAURmB9uAasQS3NwA1rpWozg91t2wPrnHqKxnjMPD4pr7zenlmNq/DSl9xPu96TJP0qaLSPE9wuYdBmUnHEzhDz7VYTwf4ynHTTrQkj7zFyM9eQccfSuSpnWDh9q56FLhfM6uvs7erRRHPekd0jBZ3VQOpJAFdDZfDa/fB1TxFKw7rbRhB16Z4PStux+Hvhq3ZXmtZLyQD708pbJ45xn275rgq8S0Y/BFs9ehwNiZfxZpL7/8AI84fVbEOVWYTN/diUuf/AB0GrFvB4gviP7N8PXcikjDzYjXkZzk5P6CvYLPTNOsgBa2FvDg5ykYB65znGetXK8ytxFiJ6QSR7uG4JwVOzqty/A8w07wF4hvBu1XUoLFM8pbLuYj0LHp+H0710elfD/w9ZyLNNDJfTDq1y5cE/Q8Y9q6yivIr46vXfvzufR4XKsHhV+6ppEdvBBbRhIIY4lHQIoA/SpKKK5T0AooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAQqpyCoPrkVBNZWUxLS2kEh6ktGCT+YqxRQKxmS+H9Dlx5mj2J5z/qFGfrgc1BJ4U8OSEbtFsgR0xEBj8q2qKrmkhcifQ52XwR4XcYOj24HooI/rUf/AAgXhPGF0lF91lcfyaumoqvazXVkewpv7K+45geAfCIJ/wCJNET3Jkcn8y1TL4K8LKoU6LbEe4J/rXQ0Ue1qd2HsKX8q+4xk8K+G0ORotke3MQP86nj0DQ4yTHo9gvOeLdQB9Bjj8K0qKnmbLUIrZEENlZwgiG1gjHUhYwM/kKmGAMcAe1LRUlWCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/9k="

"""
    <base64 string for music_icon.png>
"""

# Set ImageMagick path
#os.environ["IMAGEMAGICK_BINARY"] = r"C:\Program Files\ImageMagick-7.1.1-Q16-HDRI\magick.exe"
#change_settings({"IMAGEMAGICK_BINARY": r"C:\Program Files\ImageMagick-7.1.1-Q16-HDRI\magick.exe"})



# Download stopwords from nltk
nltk.download('stopwords')

# Configure API Keys
OPENAI_API_KEY = 'sk-proj-rjJGSlP9rRzc4jNMpt0BT3BlbkFJLMLQHqpdBOaoSow6zM7d'
PIXABAY_API_KEY = '44812949-ba98a63acdbb20b31f0281193'
PEXELS_API_KEY = 'e4agaHhuOEpih3K562pmje6YJiy2jSQ37bYJU1nm5nw6NmeualG8afvG'
UNSPLASH_API_KEY = 'ATMcaMHzCfB789pGt8m6L5Z3YyvdgndRqiBNaxwmbf8'
openai.api_key = OPENAI_API_KEY
client = OpenAI(api_key="sk-proj-rjJGSlP9rRzc4jNMpt0BT3BlbkFJLMLQHqpdBOaoSow6zM7d")  # This uses your OPENAI_API_KEY from env automatically
# Define directories
video_image_folder = r'D:\New Laptop\YouTube Channels\RelaxFlow\Media\CurrentVideo\InVidFiles'
output_directory = r'D:\New Laptop\YouTube Channels\RelaxFlow\Media\CurrentVideo\OutFiles'
music_folder = r'D:\New Laptop\YouTube Channels\RelaxFlow\Media\CurrentVideo\InMusicFiles'
voiceover_directory = r'D:\New Laptop\YouTube Channels\RelaxFlow\Media\CurrentVideo\OutFiles'

output_settings = {
    'youtube': {'codec': 'libx264', 'resolution': (1920, 1080), 'fps': 24},
    'youtube_shorts': {'codec': 'libx264', 'resolution': (1080, 1920), 'fps': 30},
    'tiktok': {'codec': 'libx264', 'resolution': (1080, 1920), 'fps': 30},
    'facebook': {'codec': 'libx264', 'resolution': (1920, 1080), 'fps': 24},
    'instagram': {'codec': 'libx264', 'resolution': (1080, 1920), 'fps': 30},
    '720p': {'codec': 'libx264', 'resolution': (1280, 720), 'fps': 24}

}

def _set_imagemagick_path():
    """
    Pick the right ImageMagick binary for the current OS and
    tell MoviePy about it only once.
    """
    if platform.system() == "Windows":
        path = r"C:\Program Files\ImageMagick-7.1.1-Q16-HDRI\magick.exe"
    else:  # Linux, macOS, WSL, 
        # Prefer 'magick' (IM7) if present, else fall back to 'convert'
        path = shutil.which("magick") or shutil.which("convert")
        if path is None:
            raise FileNotFoundError(
                "ImageMagick binary not found. Install 'imagemagick' "
                "or set IMAGEMAGICK_BINARY manually."
            )

    os.environ["IMAGEMAGICK_BINARY"] = path
    change_settings({"IMAGEMAGICK_BINARY": path})

# ------------ End of Variables and Parameters settings
def _load_counters():
    """Call this once during start-up."""
    global issue_counter, enh_counter, com_counter
    if not os.path.isfile(COUNTER_FILE):
        return   # first run  keep defaults

    try:
        with open(COUNTER_FILE, "r", encoding="utf-8") as fh:
            data = json.load(fh)
        issue_counter = int(data.get("issue_counter", issue_counter))
        enh_counter   = int(data.get("enh_counter",   enh_counter))
        com_counter   = int(data.get("com_counter",   com_counter))
    except Exception as exc:
        print(f"WARNING: Could not load {COUNTER_FILE}: {exc}")


def _save_counters():
    """Write current values to disk."""
    data = dict(
        issue_counter=issue_counter,
        enh_counter=enh_counter,
        com_counter=com_counter,
    )
    try:
        with open(COUNTER_FILE, "w", encoding="utf-8") as fh:
            json.dump(data, fh)
    except Exception as exc:
        print(f"WARNING: Could not save {COUNTER_FILE}: {exc}")


# Automatically load at import time and save on exit
_load_counters()
atexit.register(_save_counters)

def try_delete_file(file_path, attempts=3, delay=1):
    """
    Attempts to remove file_path up to `attempts` times,
    waiting `delay` seconds between each attempt if locked.
    """
    for i in range(attempts):
        try:
            os.remove(file_path)
            # print(f"Deleted {file_path}")
            return True
        except PermissionError as e:
            # File is in use by another process; wait and try again
            # print(f"Attempt {i+1}/{attempts}: {file_path} locked: {e}")
            time.sleep(delay)
        except Exception as e:
            # Some other unexpected error
            print(f"Could not delete {file_path}: {e}")
            return False
    print(f"Could not delete {file_path} after {attempts} attempts.")
    return False

class MediaDraggableWidget(QWidget):
    def __init__(self, media_path, parent=None):
        super().__init__(parent)
        self.media_path = media_path
        layout = QHBoxLayout(self)
        layout.setContentsMargins(2, 2, 2, 2)
        layout.setSpacing(5)

        self.checkbox = QCheckBox(self)
        self.checkbox.setFocusPolicy(Qt.NoFocus)

        self.iconLabel = QLabel("", self)
        font = QFont()
        font.setPointSize(20)
        self.iconLabel.setFont(font)
        self.iconLabel.setAlignment(Qt.AlignCenter)
        self.iconLabel.setMinimumWidth(20)
        self.iconLabel.setCursor(Qt.OpenHandCursor)
        self.iconLabel.setStyleSheet("""
            QLabel {
                color: #666;
                padding: 2px 5px;
                border-radius: 3px;
            }
            QLabel:hover {
                color: #000;
                background-color: #e0e0e0;
            }
        """)

        layout.addWidget(self.checkbox)
        layout.addWidget(self.iconLabel)
        layout.addStretch()
        self.setLayout(layout)

    def getMediaPath(self):
        return self.media_path

    def isChecked(self):
        return self.checkbox.isChecked()

    def setChecked(self, checked):
        self.checkbox.setChecked(checked)

class MediaTableReorder(QTableWidget):

    def __init__(self, main_window, *args, **kwargs):

        """

        main_window: your VideoCreatorGUI instance,

        which must have .target_language_input and .populate_clip_table()

        """

        super().__init__(main_window, *args, **kwargs)

        self.main_window = main_window


        # Table setup

        self.setDragEnabled(True)

        self.setAcceptDrops(True)

        self.setSelectionBehavior(QAbstractItemView.SelectRows)

        self.setDragDropMode(QAbstractItemView.InternalMove)

        self.viewport().setAcceptDrops(True)

        self.setDropIndicatorShown(True)


        # State

        self.drag_source_row = None

        self.dragging = False

        self.drop_indicator_row = -1

        self.last_scroll_position = 0


        # Progress dialog & timer refs

        self.progress = None

        self._flash_timer = None


    def show_progress(self, message: str) -> QProgressDialog:

        """

        Create, style, and show a frameless, ontop, modal QProgressDialog

        with a flashing label. Returns the dialog so you can close it.

        """

        # First clean up any old dialog/timer

        self._cleanup_progress()


        # Grab localized title

        texts = get_texts_for_current_language(

            self.main_window.target_language_input

        )

        title = texts.get(

            "processing_title",

            DEFAULT_STRINGS["processing_title"]

        )


        dlg = QProgressDialog(message, None, 0, 0, self)

        dlg.setWindowModality(Qt.ApplicationModal)

        dlg.setWindowTitle(title)

        dlg.setCancelButton(None)

        dlg.setMinimumDuration(0)

        dlg.setWindowFlags(

            dlg.windowFlags()

            | Qt.FramelessWindowHint

            | Qt.WindowStaysOnTopHint

        )


        # YOUR new rich stylesheet:

        dlg.setStyleSheet("""

            QProgressDialog {

                background-color: rgba(240, 240, 240, 220);

                border-radius: 10px;

                padding: 20px;

            }

            QLabel {

                color: black;

                font-size: 12px;

                font-weight: bold;

            }

        """)


        dlg.setLabelText(message)

        dlg.show()

        dlg.setValue(0)

        QApplication.processEvents()


        # Grab the QLabel to enable HTML + wordwrap + flashing

        lbl = dlg.findChild(QLabel)

        if lbl:

            lbl.setTextFormat(Qt.RichText)

            lbl.setWordWrap(True)


        # Prepare flashing

        orig  = message

        flash = f'<font color="#5d8aa8">{message}</font>'

        state = [False]


        timer = QTimer(dlg)

        timer.setInterval(500)


        def _flash():

            state[0] = not state[0]

            lbl.setText(flash if state[0] else orig)


        timer.timeout.connect(_flash)

        timer.start()


        # Keep refs so cleanup can stop them

        self.progress     = dlg

        self._flash_timer = timer

        return dlg


    def _cleanup_progress(self):

        """Stop & delete any existing flashtimer and dialog."""

        if getattr(self, "_flash_timer", None):

            self._flash_timer.stop()

            self._flash_timer.deleteLater()

            self._flash_timer = None


        if getattr(self, "progress", None):

            self.progress.close()

            self.progress.deleteLater()

            self.progress = None


    def dropEvent(self, event):

        texts = get_texts_for_current_language(

            self.main_window.target_language_input

        )


        if not event.isAccepted() and event.source() == self:

            # compute target row

            drop_row = self.rowAt(event.pos().y())

            if drop_row < 0:

                drop_row = self.rowCount() - 1


            rows = sorted(set(item.row() for item in self.selectedItems()))

            if not rows:

                return

            source_row = rows[0]


            # noop if dropping onto itself

            if source_row == drop_row:

                event.ignore()

                return


            print(f"Moving row {source_row}  {drop_row}")

            try:

                # 1) Show our styled progress

                msg = texts.get(

                    "moving_media_message",

                    DEFAULT_STRINGS["moving_media_message"]

                )

                self.show_progress(msg)


                # 2) Do the actual list reordering

                self.last_scroll_position = self.verticalScrollBar().value()

                clips = getattr(self.main_window, "media_clips", None)

                if clips is None or source_row >= len(clips):

                    raise IndexError("Invalid source_row or no media_clips")


                final = drop_row - (1 if drop_row > source_row else 0)

                clip = clips.pop(source_row)

                clips.insert(min(final, len(clips)), clip)


                event.accept()

                self.dragging = False


                # 3) Refresh table (and close progress) after a tiny delay

                QTimer.singleShot(1, lambda: self._refresh_after_drop(final))

                print("Drop completed successfully")


            except Exception as e:

                print(f"Error during drop operation: {e}")

                self._cleanup_progress()

                event.ignore()

                self.dragging = False


    def _refresh_after_drop(self, target_row):

        """

        Repopulate the table via parent.populate_clip_table(),

        restore scroll & selection, then clean up the dialog.

        """

        try:

            self.blockSignals(True)

            self.main_window.populate_clip_table()

            self.verticalScrollBar().setValue(self.last_scroll_position)

            if 0 <= target_row < self.rowCount():

                self.selectRow(target_row)

        except Exception as e:

            print(f"Error during refresh: {e}")

        finally:

            self.blockSignals(False)

            self._cleanup_progress()

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            item = self.itemAt(event.pos())
            if item:
                if self.columnAt(event.pos().x()) == 0:
                    widget = self.cellWidget(item.row(), 0)
                    if isinstance(widget, MediaDraggableWidget):
                        widget_pos = widget.mapFrom(self, event.pos())
                        if widget.iconLabel.geometry().contains(widget_pos):
                            self.drag_source_row = item.row()
                            self.selectRow(self.drag_source_row)

                            # Start drag immediately
                            drag = QDrag(self)
                            mimeData = QMimeData()
                            mimeData.setText(str(self.drag_source_row))
                            drag.setMimeData(mimeData)

                            pixmap = self.grab(self.visualItemRect(item))
                            drag.setPixmap(pixmap)
                            drag.setHotSpot(event.pos() - self.visualItemRect(item).topLeft())

                            # Execute drag
                            result = drag.exec_(Qt.MoveAction)
                            return
        super().mousePressEvent(event)

    def dragEnterEvent(self, event):
        if event.source() == self:
            event.accept()
            self.dragging = True
        else:
            event.ignore()

    def dragMoveEvent(self, event):
        if event.source() == self:
            event.accept()
            self.drop_indicator_row = self.rowAt(event.pos().y())
        else:
            event.ignore()

    def mouseReleaseEvent(self, event):
        if not self.dragging:
            super().mouseReleaseEvent(event)
        self.drag_source_row = None
        self.dragging = False
        self.drop_indicator_row = -1


class VLCVideoWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        # Initialize state variables
        self.current_media_path = None
        self.is_paused = False
        self.is_seeking = False
        self.is_player_ready = False
        self.last_seek_time = 0
        self.seek_cooldown = 0.2  # 200ms cooldown between seeks
        self.seek_queue = []
        self.seek_lock = threading.Lock()
        self.minimum_seek_interval = 250  # ms
        self.last_successful_seek = 0
        self.player_ready_retries = 0
        self.max_ready_retries = 100  # 5 seconds maximum wait

        # Initialize timers
        self.seek_timer = QTimer()
        self.seek_timer.setSingleShot(True)
        self.seek_timer.timeout.connect(self.process_seek_queue)

        self.player_ready_timer = QTimer(self)
        self.player_ready_timer.setInterval(50)  # Check every 50ms
        self.player_ready_timer.timeout.connect(self.check_player_ready)

        # Create a frame to host the VLC video
        self.videoFrame = QFrame(self)
        self.videoFrame.setStyleSheet("background-color: black;")
        self.videoFrame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        # Create timeline slider
        self.timelineSlider = QSlider(Qt.Horizontal, self)
        self.timelineSlider.setMinimum(0)
        self.timelineSlider.setMaximum(100)
        self.timelineSlider.setValue(0)
        self.timelineSlider.setMaximumHeight(30)
        self.timelineSlider.sliderReleased.connect(self.seek_video)

        # Create time label
        self.timeLabel = QLabel("00:00 / 00:00", self)
        self.timeLabel.setAlignment(Qt.AlignCenter)
        self.timeLabel.setMaximumHeight(20)

        # Set up layout
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(self.videoFrame, stretch=10)
        layout.addWidget(self.timelineSlider, stretch=0)
        layout.addWidget(self.timeLabel, stretch=0)
        self.setLayout(layout)

        # Create VLC instance with error handling options
        vlc_args = [
            '--quiet',
            '--no-xlib',
            '--no-video-title-show',
            '--file-caching=1000',
        ]
        self.instance = vlc.Instance(vlc_args)
        self.player = self.instance.media_player_new()

        # Set up error handling
        self.event_manager = self.player.event_manager()
        self.event_manager.event_attach(vlc.EventType.MediaPlayerEncounteredError,
                                        self.handle_player_error)

        # Set platform-specific output
        self.set_platform_specific_output()

        # Skip duration in seconds
        self.skip_duration = 10

        # Update timer
        self.timer = QTimer(self)
        self.timer.setInterval(500)
        self.timer.timeout.connect(self.update_timeline)

        # State tracking timer
        self.state_timer = QTimer(self)
        self.state_timer.setInterval(100)
        self.state_timer.timeout.connect(self.check_player_state)
        self.state_timer.start()

    def set_time(self, time_value):
        """Set playback position."""
        try:
            if self.is_player_ready and self.player:
                # Ensure the time value is an integer
                time_value = int(time_value)
                # Add boundary check
                media_length = self.get_length()
                if media_length > 0:
                    time_value = max(0, min(time_value, media_length - 100))
                return self.player.set_time(time_value)
            return False
        except Exception as e:
            print(f"Error setting time: {str(e)}")
            return False

    def check_player_ready(self):
        """Check if player is ready and handle pending operations."""
        try:
            if self.player and self.player.is_playing():
                state = self.player.get_state()
                if state in [vlc.State.Playing, vlc.State.Paused]:
                    self.is_player_ready = True
                    self.player_ready_timer.stop()
                    self.player_ready_retries = 0
                    # Process any pending seek operations
                    if self.seek_queue and not self.is_seeking:
                        self.process_seek_queue()
                else:
                    self.player_ready_retries += 1
                    if self.player_ready_retries >= self.max_ready_retries:
                        print("Player failed to become ready, resetting...")
                        self.player_ready_timer.stop()
                        self.reset_player()
            else:
                self.player_ready_retries += 1
                if self.player_ready_retries >= self.max_ready_retries:
                    self.player_ready_timer.stop()
                    self.reset_player()
        except Exception as e:
            print(f"Error checking player ready state: {str(e)}")
            self.player_ready_timer.stop()
            self.reset_player()

    def check_player_state(self):
        """Monitor player state."""
        try:
            if self.player:
                state = self.player.get_state()
                self.is_player_ready = state in [
                    vlc.State.Playing,
                    vlc.State.Paused,
                    vlc.State.NothingSpecial
                ]
        except Exception as e:
            print(f"Error checking player state: {str(e)}")
            self.is_player_ready = False

    def handle_player_error(self, event):
        """Handle VLC player errors."""
        print("VLC player encountered an error. Attempting recovery...")
        self.reset_player()

    def process_seek_queue(self):
        """Process pending seek operations."""
        if not self.seek_queue:
            self.is_seeking = False
            return

        if not self.is_player_ready:
            print("Player not ready, waiting...")
            self.player_ready_timer.start()
            return

        try:
            with self.seek_lock:
                operation = self.seek_queue.pop(0)
                current_time = self.get_time()
                media_length = self.get_length()

                if current_time < 0 or media_length <= 0:
                    print("Invalid time values, skipping seek operation")
                    return

                if operation == 'forward':
                    new_time = min(current_time + (self.skip_duration * 1000), media_length - 100)
                else:  # backward
                    new_time = max(0, current_time - (self.skip_duration * 1000))

                # Additional boundary check
                if new_time < 0 or new_time >= media_length:
                    print(f"Seek target {new_time} out of bounds [0, {media_length}]")
                    return

                success = self.safe_seek(new_time)
                if not success:
                    print("Seek operation failed")
                    if len(self.seek_queue) > 0:
                        self.seek_queue.clear()  # Clear pending seeks if one fails
                    return

        except Exception as e:
            print(f"Error processing seek queue: {str(e)}")
            self.seek_queue.clear()
        finally:
            if self.seek_queue:
                self.seek_timer.start(100)
            else:
                self.is_seeking = False

    def safe_seek(self, target_time):
        """Safely perform seek operation with additional safety checks."""
        if not self.player or not self.is_player_ready:
            return False

        try:
            with self.seek_lock:
                media_length = self.get_length()
                if media_length <= 0:
                    return False

                # Ensure target_time is within valid bounds with some margin
                target_time = max(0, min(target_time, media_length - 100))

                # Store playing state
                was_playing = self.player.is_playing()

                # Pause before seeking
                if was_playing:
                    self.player.pause()
                    time.sleep(0.05)  # Small delay to ensure pause takes effect

                # Perform seek
                result = self.player.set_time(int(target_time))

                # Resume if was playing
                if was_playing:
                    time.sleep(0.05)  # Small delay before resuming
                    self.player.play()

                return result == 0

        except Exception as e:
            print(f"Error during safe seek: {str(e)}")
            return False

    def forward(self):
        """Forward seek operation."""
        if not self.is_player_ready:
            print("Player not ready for forward operation")
            return

        current_time = time.time()
        if current_time - self.last_seek_time < self.seek_cooldown:
            return

        try:
            media_length = self.get_length()
            current_pos = self.get_time()

            # Check if we're already near the end
            if current_pos >= media_length - (self.skip_duration * 1000):
                print("Already near end of media")
                return

            # Calculate new position
            new_pos = current_pos + (self.skip_duration * 1000)
            new_pos = min(new_pos, media_length - 100)  # Keep some margin from the end

            print("DEBUG: Performing forward seek")
            result = self.player.set_time(int(new_pos))
            if result != 0:
                print("Forward seek failed")
            self.last_seek_time = current_time

        except Exception as e:
            print(f" Error during forward: {str(e)}")

    def backward(self):
        """Backward seek operation."""
        if not self.is_player_ready:
            print("Player not ready for backward operation")
            return

        current_time = time.time()
        if current_time - self.last_seek_time < self.seek_cooldown:
            return

        try:
            current_pos = self.get_time()

            # Check if we're already near the start
            if current_pos <= self.skip_duration * 1000:
                print("Already near start of media")
                return

            # Calculate new position
            new_pos = max(0, current_pos - (self.skip_duration * 1000))

            print("DEBUG: Performing backward seek")
            result = self.player.set_time(int(new_pos))
            if result != 0:
                print("Backward seek failed")
            self.last_seek_time = current_time

        except Exception as e:
            print(f" Error during backward: {str(e)}")

    def play(self, media_path=None):
        """Play media file or resume from pause."""
        try:
            self.is_player_ready = False
            if media_path is not None and media_path != self.current_media_path:
                self.current_media_path = media_path
                # Stop any existing playback
                self.player.stop()
                # Clear any pending operations
                self.seek_queue.clear()
                self.is_seeking = False

                # Create new media
                media = self.instance.media_new(media_path)
                self.player.set_media(media)
                self.set_platform_specific_output()
                self.is_paused = False
            elif self.is_paused:
                self.is_paused = False

            # Start playback
            result = self.player.play()
            if result == -1:
                print("Error starting playback")
                self.reset_player()
                return

            # Start timers
            self.timer.start()
            self.player_ready_timer.start()
            self.player_ready_retries = 0

        except Exception as e:
            print(f"Error during play: {str(e)}")
            self.reset_player()

    def set_platform_specific_output(self):
        """Set platform-specific video output."""
        try:
            if sys.platform.startswith('win'):
                self.player.set_hwnd(int(self.videoFrame.winId()))
            elif sys.platform.startswith('linux'):
                self.player.set_xwindow(int(self.videoFrame.winId()))
            else:
                self.player.set_nsobject(int(self.videoFrame.winId()))
        except Exception as e:
            print(f"Error setting platform output: {str(e)}")

    def reset_player(self):
        """Reset VLC player after errors."""
        with self.seek_lock:
            try:
                self.is_player_ready = False
                self.timer.stop()
                self.state_timer.stop()
                self.player_ready_timer.stop()
                self.seek_timer.stop()

                if hasattr(self, 'player'):
                    self.player.stop()
                    self.player.release()
                if hasattr(self, 'instance'):
                    self.instance.release()

                self.seek_queue.clear()
                self.is_seeking = False

                # Reinitialize VLC instance
                self.instance = vlc.Instance('--quiet')
                self.player = self.instance.media_player_new()
                self.set_platform_specific_output()

                if self.current_media_path:
                    media = self.instance.media_new(self.current_media_path)
                    self.player.set_media(media)
                    self.player.play()

                self.timer.start()
                self.state_timer.start()
                self.player_ready_timer.start()
                self.player_ready_retries = 0

            except Exception as e:
                print(f"Error resetting player: {str(e)}")

    def cleanup(self):
        """Clean up resources."""
        with self.seek_lock:
            try:
                self.is_player_ready = False
                self.timer.stop()
                self.state_timer.stop()
                self.player_ready_timer.stop()
                self.seek_timer.stop()
                self.seek_queue.clear()

                if hasattr(self, 'player'):
                    self.player.stop()
                    self.player.release()
                if hasattr(self, 'instance'):
                    self.instance.release()
            except Exception as e:
                print(f"Error during cleanup: {str(e)}")

    def pause(self):
        """Pause playback."""
        if self.is_player_ready:
            self.player.pause()
            self.is_paused = True

    def stop(self):
        """Stop playback."""
        if self.is_player_ready:
            self.player.stop()
            self.timer.stop()
            self.timelineSlider.setValue(0)
            self.timeLabel.setText("00:00 / 00:00")
            self.is_paused = False
            self.current_media_path = None

    def get_time(self):
        """Get current playback time with safety check."""
        try:
            if self.is_player_ready and self.player:
                time = self.player.get_time()
                return max(0, time)  # Ensure we never return negative time
            return 0
        except Exception as e:
            print(f"Error getting time: {str(e)}")
            return 0

    def get_length(self):
        """Get media length with safety check."""
        try:
            if self.is_player_ready and self.player:
                length = self.player.get_length()
                return max(0, length)  # Ensure we never return negative length
            return 0
        except Exception as e:
            print(f"Error getting length: {str(e)}")
            return 0

    def update_timeline(self):
        """Update timeline slider and label."""
        if not self.is_player_ready:
            return

        total_duration = self.get_length()
        if total_duration > 0:
            self.timelineSlider.setMaximum(total_duration)
        else:
            total_duration = 0

        current_time = self.get_time()
        self.timelineSlider.blockSignals(True)
        self.timelineSlider.setValue(current_time)
        self.timelineSlider.blockSignals(False)
        self.timeLabel.setText(f"{self.format_time(current_time)} / {self.format_time(total_duration)}")

    def seek_video(self):
        """Seek to slider position."""
        if self.is_player_ready:
            try:
                new_time = self.timelineSlider.value()
                return self.safe_seek(new_time)
            except Exception as e:
                print(f"Error during slider seek: {str(e)}")
                return False

    def format_time(self, ms):
        """Format time string."""
        seconds = ms // 1000
        hrs = seconds // 3600
        mins = (seconds % 3600) // 60
        secs = seconds % 60
        if hrs > 0:
            return f"{hrs:d}:{mins:02d}:{secs:02d}"
        else:
            return f"{mins:02d}:{secs:02d}"

    def closeEvent(self, event):
        """Handle widget closure."""
        self.cleanup()
        super().closeEvent(event)


def close_log_file():
    global global_log_file
    if global_log_file is not None and not global_log_file.closed:
        global_log_file.close()
        _original_print("Log file closed.")


def custom_print(*args, **kwargs):
    global global_log_file  # declare global for clarity
    sep = kwargs.get("sep", " ")
    end = kwargs.get("end", "\n")
    message = sep.join(str(arg) for arg in args) + end

    if PRINT_ENABLED:
        _original_print(*args, **kwargs)

    if LOG_ENABLED and global_log_file is not None and not global_log_file.closed:
        try:
            global_log_file.write(message)
            global_log_file.flush()  # flush after each write so the log updates immediately
        except Exception as e:
            _original_print(" Logging error:", e, file=sys.stderr)


# Override the built-in print function.
builtins.print = custom_print


def update_log_file(new_log_directory, new_video_title):
    global global_log_file, global_log_file_path
    # Close previous log file if open.
    if global_log_file:
        try:
            if not global_log_file.closed:
                global_log_file.close()
        except Exception:
            pass
        global_log_file = None

    # Only open a new file if both a directory and a video title are provided.
    if new_log_directory and new_video_title:
        log_filename = f"{new_video_title}.log"
        global_log_file_path = os.path.join(new_log_directory, log_filename)
        try:
            global_log_file = open(global_log_file_path, "a", encoding="utf-8")
            print(f"Logging enabled. Log file: {global_log_file_path}")  # This call writes to both console and log.
        except Exception as e:
            _original_print(" Error opening log file:", e, file=sys.stderr)


def get_video_duration(file_path):
    """
    Returns the duration of the video in seconds using MoviePy.
    """
    with VideoFileClip(file_path) as clip:
        return clip.duration


def get_platform_resolution(platform):
    """Returns the resolution tuple (width, height) for the given platform."""
    if platform in output_settings:
        return output_settings[platform]['resolution']
    else:
        print(f" Warning: Platform '{platform}' not found in output_settings. Using default resolution (1920, 1080).")
        return (1920, 1080)  # Explicit default fallback resolution


def get_pixmap_from_base64(base64_string):
    """Convert a base64 string to a QPixmap."""
    image_data = base64.b64decode(base64_string)
    pixmap = QPixmap()
    pixmap.loadFromData(image_data)
    return pixmap


class PreviewLabel(QLabel):
    def __init__(self, file_path, media_type, parent=None):
        super().__init__(parent)
        self.file_path = file_path  # store the file path
        self.media_type = media_type  # "Video", "Image", or "Music"
        self.setCursor(Qt.PointingHandCursor)

    def mouseDoubleClickEvent(self, event):
        # When double-clicked, ask the parent window to show the preview.
        if hasattr(self.parent(), "openPreview"):
            self.parent().openPreview(self.file_path, self.media_type)


class ClickablePreviewLabel(QLabel):
    def __init__(self, file_path, media_type, parent=None):
        super().__init__(parent)
        self.file_path = file_path  # file path to preview
        self.media_type = media_type  # "Video", "Image", or "Music"
        self.setCursor(QCursor(Qt.PointingHandCursor))

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            mainWin = self.window()
            # Call openPreview method from the main window if available.
            if hasattr(mainWin, "openPreview"):
                mainWin.openPreview(self.file_path, self.media_type)
        super().mousePressEvent(event)


# Create a dedicated dialog class for video preview:
class VideoPreviewDialog(QDialog):
    def __init__(self, file_path, parent=None):
        super().__init__(parent)
        #self.setWindowTitle(f"Video Preview: {os.path.basename(file_path)}")
        self.setWindowTitle(texts.get("video_preview_title", DEFAULT_STRINGS["video_preview_title"]).format(
            os.path.basename(file_path)))
        self.resize(800, 600)
        layout = QVBoxLayout(self)
        self.videoWidget = QVideoWidget(self)
        layout.addWidget(self.videoWidget)
        self.player = QMediaPlayer(self)
        self.player.setVideoOutput(self.videoWidget)
        media = QMediaContent(QUrl.fromLocalFile(file_path))
        self.player.setMedia(media)
        self.player.setVolume(50)
        # Use a timer to start playback after the dialog is fully visible.
        QTimer.singleShot(1000, self.player.play)

    def closeEvent(self, event):
        self.player.stop()
        super().closeEvent(event)


# Similarly, for music preview, create a dedicated dialog:
class MusicPreviewDialog(QDialog):
    def __init__(self, file_path, parent=None):
        super().__init__(parent)
        #self.setWindowTitle(f"Music Preview: {os.path.basename(file_path)}")
        self.setWindowTitle(texts.get("music_preview_title", DEFAULT_STRINGS["music_preview_title"]).format(
            os.path.basename(file_path)))

        self.resize(400, 200)
        layout = QVBoxLayout(self)
        self.label = QLabel(f"Playing audio: {os.path.basename(file_path)}", self)
        layout.addWidget(self.label)
        self.player = QMediaPlayer(self)
        media = QMediaContent(QUrl.fromLocalFile(file_path))
        self.player.setMedia(media)
        self.player.setVolume(50)
        QTimer.singleShot(1000, self.player.play)

    def closeEvent(self, event):
        self.player.stop()
        super().closeEvent(event)


# A clickable preview label for images (and used for video/music icons as well)
class ClickablePreviewLabel(QLabel):
    def __init__(self, file_path, media_type, parent=None):
        super().__init__(parent)
        self.file_path = file_path
        self.media_type = media_type  # "Image", "Video", or "Music"
        self.setCursor(QCursor(Qt.PointingHandCursor))

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            # Call openPreview in the top-level window.
            mainWin = self.window()
            if hasattr(mainWin, "openPreview"):
                mainWin.openPreview(self.file_path, self.media_type)
        super().mousePressEvent(event)


def format_seconds(seconds):
    """Convert seconds (float/int) to a mm:ss formatted string."""

    minutes = int(seconds // 60)
    secs = int(seconds % 60)
    return f"{minutes:02d}:{secs:02d}"


def get_test_statement_for_voice(voice_name):
    """Return a test statement based on the voice language code (default is English)."""
    lower_voice = voice_name.lower()

    if lower_voice.startswith("ar-"):
        return "!   .  "
    elif lower_voice.startswith("es-"):
        return "Hola! Esta es una prueba de voz. Cmo sueno?"
    elif lower_voice.startswith("pt-"):
        return "Ol! Este  um teste de voz. Como eu soou?"
    elif lower_voice.startswith("hi-"):
        return "!           ?"
    elif lower_voice.startswith("de-"):
        return "Hallo! Dies ist ein Stimmtest. Wie klinge ich?"
    elif lower_voice.startswith("zh-"):
        return ""
    elif lower_voice.startswith("jp-") or lower_voice.startswith("ja-"):
        return ""
    elif lower_voice.startswith("fr-"):
        return "Bonjour ! Ceci est un test vocal. Comment est ma voix ?"
    elif lower_voice.startswith("ru-"):
        return "!   .   ?"
    # --- new additions below ---
    elif lower_voice.startswith("ko-"):
        return "!   .    ?"
    elif lower_voice.startswith("tr-"):
        return "Merhaba! Bu bir ses testidir. Sesim nasl geliyor?"
    elif lower_voice.startswith("ur-"):
        return "!           "
    # ----------------------------
    else:
        return "Hello! This is a voice test. How do I sound?"


class VoiceSelector(QWidget):
    def __init__(self):
        super().__init__()

        texts = get_texts_for_current_language()
        self._player = QMediaPlayer()

        #self.setWindowTitle("Voice Selector")
        self.setWindowTitle(texts.get("voice_selector_title", DEFAULT_STRINGS["voice_selector_title"]))

        main_layout = QVBoxLayout()

        # Voice selection
        self.voice_label = QLabel("Select Voice:")
        self.voice_input = QComboBox()

        # Fetch available voices (only using locales en-GB and en-US)
        self.voice_list = asyncio.run(list_voices())
        self.voice_input.addItems([voice['ShortName'] for voice in self.voice_list])

        # Default voice: en-US-AndrewMultilingualNeural
        #default_voice = "en-US-AndrewMultilingualNeural"

        default_index = self.voice_input.findText(default_voice)
        if default_index >= 0:
            self.voice_input.setCurrentIndex(default_index)
        else:
            # Optionally print/log if the default voice is not found
            print(f"Default voice '{default_voice}' not found.")

        main_layout.addWidget(self.voice_label)
        main_layout.addWidget(self.voice_input)

        # Add "Test Voice" button
        self.test_button = QPushButton("Test Voice")
        self.test_button.setStyleSheet("""
                QPushButton {
                    background-color: #5d8aa8; /* Base color */
                    color: white;
                    font-weight: bold;
                    font-size: 24px;
                    border: 2px solid #4a739b; /* Darker border for depth */
                    border-radius: 5px;
                    padding: 5px 10px;
                    min-width: 80px;
                    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3); /* Shadow for 3D effect */
                }
                QPushButton:pressed {
                    background-color: #4a739b; /* Darker shade when pressed */
                    border: 2px solid #3b5a7b;
                    box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.3); /* Inset shadow for pressed effect */
                }
                QPushButton:hover {
                    background-color: #6b9ec1; /* Lighter blue on hover */
                }
            """)
        self.test_button.clicked.connect(self.test_selected_voice)
        main_layout.addWidget(self.test_button)

        self.setLayout(main_layout)

    async def play_test_statement(self, voice_name):
        """Play a test statement for the selected voice."""
        try:
            # Generate a unique file name.
            file_name = f"test_voice_{uuid.uuid4()}.mp3"

            # Get language-specific test text based on selected voice.
            test_text = get_test_statement_for_voice(voice_name)
            print(f"Testing voice: {voice_name} with text: {test_text}")

            communicator = Communicate(text=test_text, voice=voice_name)
            await communicator.save(file_name)

            # Ensure the file exists before playback
            for _ in range(10):
                if os.path.exists(file_name) and os.path.getsize(file_name) > 0:
                    break
                time.sleep(0.1)
            else:
                print(f" Error: File {file_name} not found or empty after save.")
                return

            # Now play it
            self._player.setMedia(QMediaContent(QUrl.fromLocalFile(os.path.abspath(file_name))))
            self._player.setVolume(100)
            self._player.play()


        except Exception as e:
            print(f" Error during voice test: {e}")

    def test_selected_voice(self):
        """Test the selected voice."""
        selected_voice = self.get_selected_voice()
        print(f"Voice name type: {type(selected_voice)}")
        if not isinstance(selected_voice, str):
            print(" Error: selected_voice is not a string.")
            return
        asyncio.run(self.play_test_statement(selected_voice))

    def get_selected_voice(self):
        """Get the currently selected voice."""
        return self.voice_input.currentText()


class VoiceoverThread(QThread):
    finished = pyqtSignal()

    def __init__(self, script, output_file, voice):
        super().__init__()
        self.script = script
        self.output_file = output_file
        self.voice = voice

    def run(self):
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            loop.run_until_complete(generate_voiceover(self.script, self.output_file, self.voice))
            print(" Voiceover successfully generated.")
        except Exception as e:
            print(f" Error generating voiceover: {e}")
        finally:
            loop.close()
            self.finished.emit()


# Define parse_srt_time at module level.
def parse_srt_time(time_str):
    """
    Convert a time string into seconds.
    Supports both a simple float string (e.g., "0.000")
    and the standard SRT format "HH:MM:SS,mmm".
    """
    try:
        return float(time_str.replace(",", "."))
    except Exception:
        pass
    try:
        hours, minutes, sec_milli = time_str.split(":")
        seconds, milli = sec_milli.split(",")
        return int(hours) * 3600 + int(minutes) * 60 + int(seconds) + int(milli) / 1000.0
    except Exception as e:
        print(f" Error parsing time '{time_str}': {e}")
        return 0.0


def generate_subtitle_clips_from_srt(srt_content, resolution, scale=1.0):
    """
    Parse SRT content and generate a list of TextClip objects.
    It assumes each subtitle block is separated by a blank line and formatted as:
        timecode (e.g., "0.000 --> 2.214" or "00:00:00,000 --> 00:00:02,214")
        followed by one or more lines of subtitle text.
    The scale factor multiplies each subtitles start and duration.
    Returns a list of TextClip objects.
    """
    global font
    global parse_srt_time  # to ensure availability in the child process
    subtitle_clips = []
    blocks = re.split(r'\n\s*\n', srt_content.strip())
    print(f"DEBUG: Found {len(blocks)} subtitle blocks in SRT content.")
    timecode_re = re.compile(r'(\d+(?:\.\d+)?(?:,\d{3})?)\s*-->\s*(\d+(?:\.\d+)?(?:,\d{3})?)')
    for block in blocks:
        lines = block.splitlines()
        if len(lines) < 2:
            print("DEBUG: Skipping block (insufficient lines):", block)
            continue
        if "-->" in lines[0]:
            time_line = lines[0]
            text = " ".join(lines[1:])
        else:
            time_line = lines[1]
            text = " ".join(lines[2:])
        match = timecode_re.match(time_line)
        if not match:
            print("DEBUG: Timecode format not recognized in block:", block)
            continue
        start_str, end_str = match.groups()
        start_time = parse_srt_time(start_str) * scale
        end_time = parse_srt_time(end_str) * scale
        duration = end_time - start_time
        if duration <= 0:
            continue
        fontsize = 70 if resolution[0] >= 1280 else 48
        video_height = resolution[1]
        y_position = video_height * 0.75

        if re.search(r'[\u0600-\u06FF]', text):
            font = arabic_font
        else:
            font = english_font

        #print(f"Inside generate_subtitle_clips_from_srt font: {font}")
        try:
            clip = (TextClip(text, fontsize=fontsize, color="white", font=font,
                             stroke_color='black', stroke_width=2)
                    .set_position(('center', y_position))
                    .set_start(start_time)
                    .set_duration(duration))
            subtitle_clips.append(clip)
        except Exception as e:
            print(f" Error creating TextClip for text '{text}': {e}")
    print(f"DEBUG: Generated {len(subtitle_clips)} subtitle clips with scale factor {scale:.2f}.")
    return subtitle_clips


def encode_video(media_files, subtitle_file_path, voiceover_file, music_files, final_video_file, platform_settings):
    """
    Rebuilds media clips from file paths and encodes the final video.
    Expects:
      - media_files and music_files as lists of file paths.
      - subtitle_file_path is a string path to the SRT file.
    Raises an Exception if anything goes wrong.
    """
    print("DEBUG: Inside encode_video().")

    video_exts = {".mp4", ".avi", ".mov", ".mkv"}
    music_exts = {".mp3", ".wav", ".flac", ".aac", ".ogg"}
    resolution = platform_settings.get('resolution', (1280, 720))
    fps = platform_settings.get('fps', 24)

    # Lists to record which files were successfully loaded/used.
    used_media_files = []
    used_music_files = []

    new_clips = []
    for file in media_files:
        if not file or file.strip() == "":
            continue
        if not os.path.exists(file):
            print(f" WARNING: File does not exist: {file}")
            continue
        ext = os.path.splitext(file)[1].lower()
        # Skip files that are music.
        if ext in music_exts:
            print(f"DEBUG: Skipping music file from media clip list: {file}")
            continue
        try:
            if ext in video_exts:
                print(f"DEBUG: Loading video clip: {file}")
                clip = VideoFileClip(file)
                if clip.duration <= 0:
                    print(f" WARNING: Clip duration is zero: {file}")
                    clip.close()
                    continue
                clip = clip.resize(newsize=resolution)
                new_clips.append(clip)
                used_media_files.append(file)  # Mark this file as used
            else:
                print(f"DEBUG: Loading image clip: {file}")
                clip = ImageClip(file, duration=5).resize(newsize=resolution)
                new_clips.append(clip)
                used_media_files.append(file)  # Mark as used
        except Exception as e:
            print(f" WARNING: Could not load clip {file}: {e}")

    if not new_clips:
        raise Exception("No valid media clips loaded.")

    print("DEBUG: Concatenating media clips (method='compose')...")
    base_video = concatenate_videoclips(new_clips, method="compose").set_position("center")
    print(f"DEBUG: Base video created; duration: {base_video.duration:.2f}s ({base_video.duration / 60:.2f} minutes)")

    # Generate subtitle clips from the SRT file.
    subtitle_clips = []
    if subtitle_file_path and os.path.exists(subtitle_file_path):
        try:
            with open(subtitle_file_path, "r", encoding="utf-8") as f:
                srt_content = f.read()
            # First, generate raw subtitle clips with scaling factor 1.0.
            raw_subtitle_clips = generate_subtitle_clips_from_srt(srt_content, resolution, scale=1.0)
            max_end = 0
            for clip in raw_subtitle_clips:
                end_time = clip.start + clip.duration
                if end_time > max_end:
                    max_end = end_time
            audio_clip = AudioFileClip(voiceover_file)
            voiceover_duration = audio_clip.duration
            audio_clip.close()
            if max_end > 0 and voiceover_duration > max_end:
                ratio = voiceover_duration / max_end
                print(f"DEBUG: Scaling subtitle timings by factor {ratio:.2f}")
                subtitle_clips = generate_subtitle_clips_from_srt(srt_content, resolution, scale=ratio)
            else:
                subtitle_clips = raw_subtitle_clips
        except Exception as e:
            print(f" WARNING:  Error processing subtitles: {e}")
    else:
        print("DEBUG: Subtitle file not provided or does not exist.")

    if subtitle_clips:
        print("DEBUG: Adding subtitle clips...")
        final_video = CompositeVideoClip([base_video] + subtitle_clips)
    else:
        final_video = base_video

    if not os.path.exists(voiceover_file):
        raise Exception("Voiceover file not found.")
    audio_file_clip = AudioFileClip(voiceover_file)
    print(
        f"DEBUG: Voiceover loaded; duration: {audio_file_clip.duration:.2f}s ({audio_file_clip.duration / 60:.2f} minutes)")

    if music_files:
        music_audio_clips = []
        for mf in music_files:
            if not os.path.exists(mf):
                print(f" WARNING: Music file not found: {mf}")
                continue
            try:
                clip_audio = AudioFileClip(mf)
                music_audio_clips.append(clip_audio)
                used_music_files.append(mf)  # Mark this music file as used.
            except Exception as e:
                print(f" WARNING: Could not load music file {mf}: {e}")
        if music_audio_clips:
            background_music = concatenate_audioclips(music_audio_clips).volumex(0.1)
            final_audio = CompositeAudioClip([audio_file_clip, background_music.set_duration(final_video.duration)])
        else:
            final_audio = CompositeAudioClip([audio_file_clip])
    else:
        final_audio = CompositeAudioClip([audio_file_clip])

    final_audio = final_audio.set_duration(final_video.duration)
    final_video = final_video.set_audio(final_audio)

    print("DEBUG: Writing final video file...")
    final_video.write_videofile(final_video_file,
                                codec="libx264",
                                audio_codec="aac",
                                fps=fps,
                                preset="medium",
                                ffmpeg_params=["-movflags", "+faststart", "-pix_fmt", "yuv420p", "-profile:v",
                                               "baseline", "-level", "3.0", "-ar", "44100"],
                                threads=1)

    # Clean up resources.
    final_video.close()
    final_audio.close()
    for clip in new_clips:
        try:
            clip.close()
        except Exception:
            pass
    gc.collect()




class VideoEncoderThread(QThread):
    encoding_finished = pyqtSignal(bool, str)  # (success, message)

    def __init__(self, media_files, subtitle_clips, voiceover_file, music_files,
                 final_video_file, platform_settings, parent=None):
        super(VideoEncoderThread, self).__init__(parent)
        self.media_files = media_files  # list of media file paths (self.media_clips)
        self.subtitle_clips = subtitle_clips  # Composite subtitle clips (if any)
        self.voiceover_file = voiceover_file
        self.music_files = music_files  # list of music file paths (self.music_clips)
        self.final_video_file = final_video_file
        self.platform_settings = platform_settings
        self.resolution = platform_settings.get('resolution', (1280, 720))
        self.fps = platform_settings.get('fps', 24)

    def run(self):
        try:
            new_clips = []
            video_exts = {".mp4", ".avi", ".mov", ".mkv"}
            # Process each media file, ensuring the file exists
            for file in self.media_files:
                if not file or file.strip() == "":
                    continue
                if not os.path.exists(file):
                    print(f" WARNING (EncoderThread): File does not exist: {file}")
                    continue
                ext = os.path.splitext(file)[1].lower()
                try:
                    if ext in video_exts:
                        print(f"DEBUG (EncoderThread): Loading video clip: {file}")
                        clip = VideoFileClip(file)
                        if clip.duration <= 0:
                            print(f" WARNING (EncoderThread): Clip duration is zero: {file}")
                            clip.close()
                            continue
                        clip = clip.resize(newsize=self.resolution)
                        new_clips.append(clip)
                    else:
                        print(f"DEBUG (EncoderThread): Loading image clip: {file}")
                        clip = ImageClip(file, duration=5).resize(newsize=self.resolution)
                        new_clips.append(clip)
                except Exception as e:
                    print(f" WARNING (EncoderThread): Could not load clip {file}: {e}")
            if not new_clips:
                self.encoding_finished.emit(False, "No valid media clips loaded.")
                return

            print("DEBUG (EncoderThread): Concatenating media clips (method='compose')...")
            base_video = concatenate_videoclips(new_clips, method="compose").set_position("center")

            print(
                f"DEBUG (EncoderThread): Base video created; duration: {base_video.duration:.2f}s ({base_video.duration / 60:.2f} minutes)")

            if self.subtitle_clips:
                print("DEBUG (EncoderThread): Adding subtitle clips...")
                final_video = CompositeVideoClip([base_video] + self.subtitle_clips)
            else:
                final_video = base_video

            # Check voiceover file existence
            if not os.path.exists(self.voiceover_file):
                self.encoding_finished.emit(False, "Voiceover file not found.")
                return
            audio_file_clip = AudioFileClip(self.voiceover_file)

            print(
                f"DEBUG (EncoderThread): Voiceover loaded; duration: {audio_file_clip.duration:.2f}s ({audio_file_clip.duration / 60:.2f} minutes)")

            if self.music_files:
                music_audio_clips = []
                for mf in self.music_files:
                    if not os.path.exists(mf):
                        print(f" WARNING (EncoderThread): Music file not found: {mf}")
                        continue
                    try:
                        clip_audio = AudioFileClip(mf)
                        music_audio_clips.append(clip_audio)
                    except Exception as e:
                        print(f" WARNING (EncoderThread): Could not load music file {mf}: {e}")
                if music_audio_clips:
                    background_music = concatenate_audioclips(music_audio_clips)
                    background_music = background_music.volumex(0.2)
                    final_audio = CompositeAudioClip([audio_file_clip,
                                                      background_music.set_duration(final_video.duration)])
                else:
                    final_audio = CompositeAudioClip([audio_file_clip])
            else:
                final_audio = CompositeAudioClip([audio_file_clip])

            final_audio = final_audio.set_duration(final_video.duration)
            final_video = final_video.set_audio(final_audio)

            print("DEBUG (EncoderThread): Writing final video file...")
            final_video.write_videofile(self.final_video_file,
                                        codec="libx264",
                                        audio_codec="aac",
                                        fps=self.fps,
                                        preset="medium",
                                        ffmpeg_params=["-movflags", "+faststart", "-pix_fmt", "yuv420p", "-profile:v",
                                                       "baseline", "-level", "3.0", "-ar", "44100"],
                                        threads=1)
            self.encoding_finished.emit(True, "Video encoding completed successfully.")
        except Exception as e:
            self.encoding_finished.emit(False, f" Error encoding video: {e}")
        finally:
            try:
                final_video.close()
            except Exception:
                pass
            try:
                final_audio.close()
            except Exception:
                pass
            for clip in new_clips:
                try:
                    clip.close()
                except Exception:
                    pass
            gc.collect()


# (Other needed imports already exist such as QProgressDialog, etc.)

# Assume there is a translation helper that accepts a string and a target language:
# For example:
# def translate_text(text: str, target_lang: str, source_lang: str = "en") -> str:
#     ...   # returns the translated text.

DEFAULT_STRINGS = {  # Default - English
    "missing_required_title": "Missing Required Fields",
    "missing_required_msg": "Please fill all required fields:\n",
    "issue_option": "Issue",
    "enh_option": "Enhancement",
    "comment_option": "Comment",
    "coming_soon_title":        "Coming Soon",
    "coming_soon_msg": (
        "The integration for {} is coming soon.\n\n"
        "Please manually upload the final video.\n"
        "Video path: {}"
    ),
    "youtube_shorts_reminder_title":  "YouTube Shorts Reminder",
    "youtube_shorts_reminder_msg": (
        "NOTE: YouTube Shorts are intended for videos of 60 seconds or less. "
        "Please ensure that your video meets the length requirement for YouTube Shorts."
    ),
    "file_not_found_title":     " WARNING: File Not Found",
    "file_not_found_msg": (
        "Final video file for {} not found. "
        "You may not have generated it for the specific platform. "
        "Please generate it and try again."
    ),
    "yes":            "Yes",
    "no":             "No",
    "video":          "Video",
    "image":          "Image",
    "info":           "Info",
    "switch_account": "Switch Account",
    "main_tab_title": "Main",
    "target_language_label": "Target Language:",
    "voice_label": "Select Narrator Voice:",
    "video_title_label": "Video Title:",
    "platform_label": "Platform:",
    "prompt_label": "Enter the prompt for the video content (in any Language):",
    "genre_label": "Select Instrumental Genre:",
    "modify_label": "Modify Keywords?",
    "bypass_label": "Bypass Text, Subtitles, and Voiceover?",
    "status_label": "Status:",
    "save_subtitles_btn": "Save and Regenerate Subtitles",
    "start_video_btn": "Start Video Creation",
    "play_video_btn_final": "Play Video",
    "replace_clip_btn": "Replace Selected Clip",
    "delete_clip_btn": "Delete Selected Clips",
    "base_directory_label": "Base Directory:",
    "base_browse_btn": "Browse",
    "video_image_folder_label": "Video Image Folder:",
    "output_directory_label": "Output Directory:",
    "music_folder_label": "Music Folder:",
    "voiceover_directory_label": "Voiceover Directory:",
    "review_script_tab": "Review or Edit Script",
    "review_clips_tab": "Review or Edit Media Clips and Subtitles",
    "test_voice_button": "Test Voice",
    "generate_final_video_btn": "Generate Final Video",
    "final_video_tab": "Final Video",
    "upload_video_btn": "Upload to Social Media",
    "clip_table_headers": [
        "Select", "Media Preview", "Media Type", "Media File", "Media Dur",
        "Media Start", "Media End", "Select", "Music Preview", "Music File",
        "Music Dur", "Music Start", "Music End", "Subtitle", "Subtitle Start", "Subtitle End"
    ],
    # Tooltips
    "editable_field_tooltip": "Editable field",
    "readonly_field_tooltip": "Read-only field",
    "bypass_mode_message": (
        "Since you selected bypass Script, Subtitles, and Voiceover mode, "
        "no script/subtitles/voiceover were generated.\n"
        "Please review the downloaded media in the 'Review or Edit Clips and Subtitles' tab.\n"
        "After you're done reviewing, click on 'Generate Final Video' button to generate the final video.\n"
        "After the final video is generated, Click OK on the pop-up alert that will show up.\n"
        "Then, you will be switched automatically to 'Final Video' tab to Preview the video.\n"
        "Click OK to dismiss this notification."
    ),
    "normal_mode_message": (
        "Please review the generated content:\n"
        "1. In the 'Review or Edit Script' tab, please review/edit the generated script.\n"
        "2. Then, click on 'Save and Regenerate Subtitles' button in order to be switched to "
        "the 'Review or Edit Clips and Subtitles' tab for review.\n"
        "After you're done reviewing, click on 'Generate Final Video' button to generate the final video.\n"
        "After the final video is generated, Click OK on the pop-up alert that will show up.\n"
        "Then, you will be switched automatically to 'Final Video' tab to Preview the video.\n"
        "Click OK to dismiss this notification."
    ),
    # Buttons
    "add_media_btn": "Add Media",
    "add_music_btn": "Add Music",
    # Placeholders
    "no_file_placeholder": "No file",
    "none_text": "None",
    # ToolTips
    "switch_account_tooltip": "Check this box if you want to sign in with a different YouTube account.",
    "target_language_tooltip": "Select the target language for the interface translations.",
    "prompt_tooltip": (
        "Provide a comprehensive prompt describing the video content you wish to create.\n"
        "Include key topics, desired style, and all essential details to guide the video generation process.\n"
        "You may write the prompt in any language; the video will be produced in the language selected.\n"
        "The generated output will form a video script that you can review later."
    ),
    "modify_tooltip": (
        "Choose 'Yes' (default) to allow editing of the keywords extracted from the script; selecting 'No' retains the original keywords\n"
        "These keywords determine the selection of downloaded media; more keywords may yield more media (and longer videos),\n"
        "while more precise keywords produce more relevant content.\n"
        "Note: If you use a language other than English for the prompt, English keywords will be added automatically for optimal content results."
    ),
    "modify_yes_tooltip": "Yes: Allow modifications to the extracted keywords.",
    "modify_no_tooltip": "No: Use the originally generated keywords.",
    "bypass_tooltip": (
        "When set to 'Yes', the generation and processing of text, subtitles, and voiceover will be bypassed\n"
        "Example: meditation or Relaxation videos.\n"
        "When set to 'No' (default), text, subtitles, and voiceover are generated."
    ),
    "bypass_yes_tooltip": "Yes: Bypass text, subtitle, and voiceover generation.",
    "bypass_no_tooltip": "No: Generate text, subtitles, and voiceover.",

    # Buttons
    "play_button": "Play",
    "pause_button": "Pause",
    "forward_button": "Forward (+10 s)",
    "backward_button": "Backward (-10 s)",
    "browse_button": "Browse",

    # Window Titles
    "success_text": "Success",
    "video_preview_title": "Video Preview: ",  #
    "music_preview_title": "Music Preview: ",
    "voice_selector_title": "Voice Selector",
    "upload_details_title": "Upload Details",
    "modify_keywords_title": "Modify Keywords",

    # Progress Messages
    "uploading_video": "Uploading Video to YouTube... Please wait.",
    "uploading_thumbnail": "Uploading YouTube thumbnail... Please wait.",
    "generating_final_video": "Generating Final Video... Please wait.",
    "saving_subtitles": "Saving subtitles and regenerating SRT",
    "replacing_media": "Replacing Selected Media... Please wait.",
    "deleting_clips": "Deleting selected clip(s)... Please wait.",
    "inserting_media": "Inserting New Media... Please wait.",
    "inserting_music": "Inserting New Music Media... Please wait.",
    "starting_video": "Starting video creation... Please wait.",

    # Info Messages
    "upload_success": " YouTube Video Upload Completed Successfully!",
    "upload_failure": " An error occurred during upload.",
    "upload_cancelled": "Upload was cancelled by the user.",
    "subtitle_error": " An error occurred during subtitle processing: ",
    "select_media_warning": "Please select a media cell to replace.",
    "unsupported_file": "Selected file type is not supported.",
    "replace_media_error": " An error occurred while Replacing Selected Media: ",
    "no_items_selected": "No media, music, or subtitles selected for deletion.",
    "delete_error": " An error occurred while deleting clips: ",
    "insert_media_error": " An error occurred while Inserting New Media: ",
    "video_success_bypass": "Video creation completed successfully (bypass mode).",
    "video_success": "Video creation completed successfully.",
    "encoding_error": " Error encoding video in separate process.",
    "review_content_title": "Info - Review Content",
    "title_required": "Please enter a video title.",
    "platform_required": "Please select a platform.",
    "prompt_required": "Please enter a Video Script Prompt.",
    "video_not_found": "Video file not found: ",
    "playback_error": " An error occurred while playing the video: ",
    "invalid_platform": " Invalid platform settings for .",

    # Status Messages
    "encoding_complete": "Video encoding completed successfully.",
    "encoding_error_status": " Error encoding video in separate process.",
    "general_error": " An error occurred: ",
    "playing_video": "Playing video: ",
    "subtitles_saved": "Subtitles saved and voiceover generation started...",
    "items_deleted": " Selected items deleted.",
    "no_media_found": " No video or image files found in ",
    "video_processing_error": " Error processing video file : ",
    "image_processing_error": " Error processing image file : ",
    "no_valid_clips": " No valid clips could be processed.",
    "invalid_voiceover": " Invalid voiceover duration. Aborting.",
    "no_music_files": " No music files found; setting music clips as empty list.",
    "review_aborted": "Review aborted by the user. Video creation canceled.",
    "video_creation_started": "Video creation started...",
    "creating_video": "Initiate - Creating Video Titled: ",
    "video_in_progress": "In Progress - Creating Video Titled: ",
    "main_execution_error": " Error in main execution: ",

    # Dialog Messages
    "enter_keywords": "Enter the new keywords, separated by commas:",
    "description_label": "Description:",
    "tags_label": "Tags (comma separated):",
    "privacy_label": "Privacy:",
    "thumbnail_label": "Thumbnail Image:",
    "category_label": "Category:",
    "video_language_label": "Video Language:",
    "recording_date_label": "Recording Date:",
    "switch_account_label": "Switch YouTube Account",
    "select_thumbnail": "Select Thumbnail Image",
    "image_files_filter": "Image Files (*.png *.jpg *.jpeg)",
    "select_platform_title": "Select Platform",
    "select_platform_prompt": "Choose a social media platform:",
    "loading_clips_message": "Loading clips and subtitles... Please wait.",
    "moving_media_message": "Moving media clip... Please wait.",
    "processing_subtitles_message": "Processing subtitles... Please wait.",
    "loading_title": "Loading",
    "processing_title": "Processing",
    "support_tab": "Support",
    "check_faq_label": "Please check our FAQ first:",
    "faq_link_text": "Click here for FAQ",
    "sr_number_label": "SR Number",
    "customer_name_label": "Customer Name",
    "email_label": "Email",
    "phone_label": "Phone",
    "ticket_type_label": "Ticket Type",
    "issue_description_label": "Issue Description",
    "video_name_label": "Video Name",
    "creation_dt_label": "Creation Date/Time (tentative)",
    "desc_label": "Description",
    "send_button": "Send Ticket",
    "sr_sent_title": "Ticket Sent",
    "sr_sent_msg": "Your support request has been sent successfully!"
}

# only invert the entries whose default is a str
REVERSE_DEFAULTS = {
    text: key
    for key, text in DEFAULT_STRINGS.items()
    if isinstance(text, str)
}


HARDCODED_TRANSLATIONS = {
    "en": {},  # fallback to DEFAULT_STRINGS
    # Arabic
    "ar": {
        "missing_required_title": "  ",
        "missing_required_msg": "    :\n",
        "issue_option": "",
        "enh_option":   "",
        "comment_option": "",
        "coming_soon_title":       "",
        "coming_soon_msg": (
            "  {}  .\n\n"
            "    .\n"
            " : {}"
        ),
        "youtube_shorts_reminder_title": " YouTube Shorts",
        "youtube_shorts_reminder_msg": (
            ":  YouTube  (Shorts)     60   . "
            "           YouTube Shorts."
        ),
        "file_not_found_title":    " :   ",
        "file_not_found_msg": (
            "        {}. "
            "      . "
            "    ."
        ),
        "yes":            "",
        "no":             "",
        "video":          "",
        "image":          "",
        "info":           "",
        "switch_account": " ",
        "main_tab_title": "",
        "target_language_label": " :",
        "voice_label": "  :",
        "video_title_label": " :",
        "platform_label": ":",
        "prompt_label": "    ( ):",
        "genre_label": "   :",
        "modify_label": "  ",
        "bypass_label": "    ",
        "status_label": ":",
        "save_subtitles_btn": "    ",
        "start_video_btn": "  ",
        "play_video_btn_final": " ",
        "replace_clip_btn": "  ",
        "delete_clip_btn": "  ",
        "base_directory_label": " :",
        "base_browse_btn": "",
        "video_image_folder_label": "  :",
        "output_directory_label": " :",
        "music_folder_label": " :",
        "voiceover_directory_label": "  :",
        "review_script_tab": "    ",
        "review_clips_tab": "     ",
        "test_voice_button": " ",
        "generate_final_video_btn": "  ",
        "final_video_tab": " ",
        "upload_video_btn": "    ",
        "clip_table_headers": [
            "", " ", " ", " ", " ",
            " ", " ", "", " ", " ",
            " ", " ", " ", "", " ", " "
        ],
        # Tooltips
        "editable_field_tooltip": "  ",
        "readonly_field_tooltip": "  ",
        "bypass_mode_message": (
            "        "
            "   // .\n"
            "         '     '.\n"
            "       '  '   .\n"
            "      OK     .\n"
            "       ' '  .\n"
            "  OK   ."
        ),
        "normal_mode_message": (
            "   :\n"
            ".    '    '  /  .\n"
            ".     '    '    "
            "  '     ' .\n"
            "       '  '   .\n"
            "      OK     .\n"
            "       ' '  .\n"
            "  OK   ."
        ),
        # Buttons
        "add_media_btn": " ",
        "add_music_btn": " ",
        # Placeholders
        "no_file_placeholder": "  ",
        "none_text": " ",
        # ToolTips
        "switch_account_tooltip": "          ",
        "target_language_tooltip": "   ",
        "prompt_tooltip": (
            "        .\n"
            "            .\n"
            "         .\n"
            "       ."
        ),
        "modify_tooltip": (
            " '' ()         ''    \n"
            "                   ( )\n"
            "        .\n"
            ":                 ."
        ),
        "modify_yes_tooltip": ":     ",
        "modify_no_tooltip": ":     ",
        "bypass_tooltip": (
            "  ''        \n"
            ":    .\n"
            "  '' ()      ."
        ),
        "bypass_yes_tooltip": ":      ",
        "bypass_no_tooltip": ":     ",

        # Buttons
        "play_button": "",
        "pause_button": " ",
        "forward_button": " (+10 )",
        "backward_button": " (-10 )",
        "browse_button": "",

        # Window Titles
        "success_text": "",
        "video_preview_title": " : ",
        "music_preview_title": " : ",
        "voice_selector_title": " ",
        "upload_details_title": " ",
        "modify_keywords_title": "  ",

        # Progress Messages
        "uploading_video": "    ...  .",
        "uploading_thumbnail": "   ...  .",
        "generating_final_video": "   ...  .",
        "saving_subtitles": "      SRT",
        "replacing_media": "   ...  .",
        "deleting_clips": "   ...  .",
        "inserting_media": "   ...  .",
        "inserting_music": "   ...  .",
        "starting_video": "   ...  .",

        # Info Messages
        "upload_success": "      !",
        "upload_failure": "    .",
        "upload_cancelled": "     .",
        "subtitle_error": "     : ",
        "select_media_warning": "    .",
        "unsupported_file": "    .",
        "replace_media_error": "      : ",
        "no_items_selected": "        .",
        "delete_error": "     : ",
        "insert_media_error": "      : ",
        "video_success_bypass": "     ( ).",
        "video_success": "    .",
        "encoding_error": "       .",
        "review_content_title": " -  ",
        "title_required": "   .",
        "platform_required": "  .",
        "prompt_required": "    .",
        "video_not_found": "     : ",
        "playback_error": "     : ",
        "invalid_platform": "      .",

        # Status Messages
        "encoding_complete": "   .",
        "encoding_error_status": "       .",
        "general_error": "  : ",
        "playing_video": "  : ",
        "subtitles_saved": "      ...",
        "items_deleted": "    .",
        "no_media_found": "          ",
        "video_processing_error": "      : ",
        "image_processing_error": "      : ",
        "no_valid_clips": "      .",
        "invalid_voiceover": "     .  .",
        "no_music_files": "            .",
        "review_aborted": "     .    .",
        "video_creation_started": "  ...",
        "creating_video": " -   : ",
        "video_in_progress": "  -   : ",
        "main_execution_error": "    : ",

        # Dialog Messages
        "enter_keywords": "     :",
        "description_label": ":",
        "tags_label": " ( ):",
        "privacy_label": ":",
        "thumbnail_label": " :",
        "category_label": ":",
        "video_language_label": " :",
        "recording_date_label": " :",
        "switch_account_label": "  ",
        "select_thumbnail": "  ",
        "image_files_filter": "  (*.png *.jpg *.jpeg)",
        "select_platform_title": " ",
        "select_platform_prompt": "   :",
        "loading_clips_message": "   ...  .",
        "moving_media_message": "   ...  .",
        "processing_subtitles_message": "  ...  .",
        "loading_title": " ",
        "processing_title": " ",
        "support_tab": "",
        "check_faq_label": "      :",
        "faq_link_text": "     ",
        "sr_number_label": " SR",
        "customer_name_label": " ",
        "email_label": " ",
        "phone_label": "",
        "ticket_type_label": " ",
        "issue_description_label": " ",
        "video_name_label": " ",
        "creation_dt_label": "/  ()",
        "desc_label": "",
        "send_button": " ",
        "sr_sent_title": "  ",
        "sr_sent_msg": "      !"
    },
    # Spanish
    "es": {
        "missing_required_title": "Campos obligatorios faltantes",
        "missing_required_msg": "Por favor, complete todos los campos obligatorios:\n",
        "issue_option": "Problema",
        "enh_option":   "Mejora",
        "comment_option": "Comentario",
        "coming_soon_title":       "Prximamente",
        "coming_soon_msg": (
            "La integracin para {} estar disponible pronto.\n\n"
            "Por favor sube el vdeo final manualmente.\n"
            "Ruta del vdeo: {}"
        ),
        "youtube_shorts_reminder_title": "Recordatorio de YouTube Shorts",
        "youtube_shorts_reminder_msg": (
            "NOTA: Los YouTube Shorts estn destinados a videos de 60 segundos o menos. "
            "Por favor, asegrate de que tu video cumpla con el requisito de duracin para YouTube Shorts."
        ),
        "file_not_found_title":    " ADVERTENCIA: Archivo no encontrado",
        "file_not_found_msg": (
            "No se encontr el archivo de vdeo final para {}. "
            "Es posible que no lo hayas generado para esta plataforma. "
            "Por favor, genera el vdeo y vuelve a intentarlo."
        ),
        "yes":            "S",
        "no":             "No",
        "video":          "Vdeo",
        "image":          "Imagen",
        "info":           "Informacin",
        "switch_account": "Cambiar cuenta",
        "main_tab_title": "Principal",
        "target_language_label": "Idioma de destino:",
        "voice_label": "Seleccione la voz del narrador:",
        "video_title_label": "Ttulo del video:",
        "platform_label": "Plataforma:",
        "prompt_label": "Ingrese el mensaje para el contenido del video (en cualquier idioma):",
        "genre_label": "Seleccione el gnero instrumental:",
        "modify_label": "Modificar palabras clave?",
        "bypass_label": "Omitir texto, subttulos y voz en off?",
        "status_label": "Estado:",
        "save_subtitles_btn": "Guardar y regenerar subttulos",
        "start_video_btn": "Iniciar creacin del video",
        "play_video_btn_final": "Reproducir video",
        "replace_clip_btn": "Reemplazar clip seleccionado",
        "delete_clip_btn": "Eliminar clips seleccionados",
        "base_directory_label": "Directorio base:",
        "base_browse_btn": "Explorar",
        "video_image_folder_label": "Carpeta de imgenes del video:",
        "output_directory_label": "Directorio de salida:",
        "music_folder_label": "Carpeta de msica:",
        "voiceover_directory_label": "Directorio de voz en off:",
        "review_script_tab": "Revisar o editar el guin",
        "review_clips_tab": "Revisar o editar clips y subttulos",
        "test_voice_button": "Probar voz",
        "generate_final_video_btn": "Generar video final",
        "final_video_tab": "Video final",
        "upload_video_btn": "Subir a redes sociales",
        "clip_table_headers": [
            "Seleccionar", "Vista previa", "Tipo de medio", "Archivo de medio", "Duracin",
            "Inicio", "Fin", "Seleccionar", "Vista previa msica", "Archivo de msica",
            "Duracin msica", "Inicio msica", "Fin msica", "Subttulo", "Inicio subttulo", "Fin subttulo"
        ],
        "editable_field_tooltip": "Campo editable",
        "readonly_field_tooltip": "Campo de solo lectura",
        "bypass_mode_message": (
            "Como seleccion el modo de omisin de guin, subttulos y voz en off, "
            "no se generaron guin/subttulos/voz en off.\n"
            "Por favor, revise los medios descargados en la pestaa 'Revisar o editar clips y subttulos'.\n"
            "Despus de terminar la revisin, haga clic en el botn 'Generar video final' para generar el video final.\n"
            "Despus de que se genere el video final, haga clic en OK en la alerta emergente que aparecer.\n"
            "Luego, ser transferido automticamente a la pestaa 'Video final' para previsualizar el video.\n"
            "Haga clic en OK para descartar esta notificacin."
        ),
        "normal_mode_message": (
            "Por favor, revise el contenido generado:\n"
            "1. En la pestaa 'Revisar o editar el guin', por favor revise/edite el guin generado.\n"
            "2. Luego, haga clic en el botn 'Guardar y regenerar subttulos' para ser transferido a "
            "la pestaa 'Revisar o editar clips y subttulos' para revisin.\n"
            "Despus de terminar la revisin, haga clic en el botn 'Generar video final' para generar el video final.\n"
            "Despus de que se genere el video final, haga clic en OK en la alerta emergente que aparecer.\n"
            "Luego, ser transferido automticamente a la pestaa 'Video final' para previsualizar el video.\n"
            "Haga clic en OK para descartar esta notificacin."
        ),
        "add_media_btn": "Agregar medio",
        "add_music_btn": "Agregar msica",
        "no_file_placeholder": "Sin archivo",
        "none_text": "Ninguno",
        # ToolTips
        "switch_account_tooltip": "Marque esta casilla si desea iniciar sesin con una cuenta diferente de YouTube",
        "target_language_tooltip": "Seleccione el idioma de destino para las traducciones de la interfaz",
        "prompt_tooltip": (
            "Proporcione una descripcin detallada del contenido del video que desea crear.\n"
            "Incluya temas clave, estilo deseado y todos los detalles esenciales para guiar el proceso de generacin del video.\n"
            "Puede escribir el texto en cualquier idioma; el video se producir en el idioma seleccionado.\n"
            "La salida generada formar un guin de video que podr revisar ms tarde."
        ),
        "modify_tooltip": (
            "Elija 'S' (predeterminado) para permitir la edicin de palabras clave extradas del guin; 'No' mantiene las palabras clave originales\n"
            "Estas palabras clave determinan la seleccin de medios a descargar; ms palabras clave pueden generar ms medios (y videos ms largos),\n"
            "mientras que palabras clave ms precisas producen contenido ms relevante.\n"
            "Nota: Si usa un idioma diferente al ingls, se aadirn automticamente palabras clave en ingls para obtener resultados ptimos."
        ),
        "modify_yes_tooltip": "S: Permitir modificaciones a las palabras clave extradas",
        "modify_no_tooltip": "No: Usar las palabras clave generadas originalmente",
        "bypass_tooltip": (
            "Cuando se establece en 'S', se omitir la generacin y procesamiento de texto, subttulos y voz en off\n"
            "Ejemplo: videos de meditacin o relajacin.\n"
            "Cuando se establece en 'No' (predeterminado), se generan texto, subttulos y voz en off."
        ),
        "bypass_yes_tooltip": "S: Omitir generacin de texto, subttulos y voz en off",
        "bypass_no_tooltip": "No: Generar texto, subttulos y voz en off",

        # Buttons
        "play_button": "Reproducir",
        "pause_button": "Pausar",
        "forward_button": "Adelantar (+10 s)",
        "backward_button": "Retroceder (-10 s)",
        "browse_button": "Explorar",

        # Window Titles
        "success_text": "xito",
        "video_preview_title": "Vista previa del video: ",
        "music_preview_title": "Vista previa de msica: ",
        "voice_selector_title": "Selector de voz",
        "upload_details_title": "Detalles de carga",
        "modify_keywords_title": "Modificar palabras clave",

        # Progress Messages
        "uploading_video": "Subiendo video a YouTube... Por favor espere.",
        "uploading_thumbnail": "Subiendo miniatura... Por favor espere.",
        "generating_final_video": "Generando video final... Por favor espere.",
        "saving_subtitles": "Guardando subttulos y regenerando SRT",
        "replacing_media": "Reemplazando medios seleccionados... Por favor espere.",
        "deleting_clips": "Eliminando clip(s) seleccionado(s)... Por favor espere.",
        "inserting_media": "Insertando nuevos medios... Por favor espere.",
        "inserting_music": "Insertando nueva msica... Por favor espere.",
        "starting_video": "Iniciando creacin de video... Por favor espere.",

        # Info Messages
        "upload_success": " Carga de video a YouTube completada con xito!",
        "upload_failure": " Ocurri un error durante la carga.",
        "upload_cancelled": "La carga fue cancelada por el usuario.",
        "subtitle_error": " Ocurri un error durante el procesamiento de subttulos: ",
        "select_media_warning": "Por favor seleccione una celda de medios para reemplazar.",
        "unsupported_file": "El tipo de archivo seleccionado no es compatible.",
        "replace_media_error": " Ocurri un error al reemplazar los medios seleccionados: ",
        "no_items_selected": "No hay medios, msica o subttulos seleccionados para eliminar.",
        "delete_error": " Ocurri un error al eliminar clips: ",
        "insert_media_error": " Ocurri un error al insertar nuevos medios: ",
        "video_success_bypass": "Creacin de video completada con xito (modo bypass).",
        "video_success": "Creacin de video completada con xito.",
        "encoding_error": " Error al codificar video en proceso separado.",
        "review_content_title": "Informacin - Revisar contenido",
        "title_required": "Por favor ingrese un ttulo para el video.",
        "platform_required": "Por favor seleccione una plataforma.",
        "prompt_required": "Por favor ingrese un texto gua para el video.",
        "video_not_found": "Archivo de video no encontrado: ",
        "playback_error": " Ocurri un error al reproducir el video: ",
        "invalid_platform": " Configuracin de plataforma invlida para .",

        # Status Messages
        "encoding_complete": "Codificacin de video completada con xito.",
        "encoding_error_status": " Error al codificar video en proceso separado.",
        "general_error": " Ocurri un error: ",
        "playing_video": "Reproduciendo video: ",
        "subtitles_saved": "Subttulos guardados e iniciando generacin de voz en off...",
        "items_deleted": " Elementos seleccionados eliminados.",
        "no_media_found": " No se encontraron archivos de video o imagen en ",
        "video_processing_error": " Error al procesar archivo de video : ",
        "image_processing_error": " Error al procesar archivo de imagen : ",
        "no_valid_clips": " No se pudieron procesar clips vlidos.",
        "invalid_voiceover": " Duracin de voz en off invlida. Abortando.",
        "no_music_files": " No se encontraron archivos de msica; estableciendo clips de msica como lista vaca.",
        "review_aborted": "Revisin abortada por el usuario. Creacin de video cancelada.",
        "video_creation_started": "Creacin de video iniciada...",
        "creating_video": "Iniciando - Creando video titulado: ",
        "video_in_progress": "En progreso - Creando video titulado: ",
        "main_execution_error": " Error en ejecucin principal: ",

        # Dialog Messages
        "enter_keywords": "Ingrese las nuevas palabras clave, separadas por comas:",
        "description_label": "Descripcin:",
        "tags_label": "Etiquetas (separadas por comas):",
        "privacy_label": "Privacidad:",
        "thumbnail_label": "Miniatura:",
        "category_label": "Categora:",
        "video_language_label": "Idioma del video:",
        "recording_date_label": "Fecha de grabacin:",
        "switch_account_label": "Cambiar cuenta de YouTube",
        "select_thumbnail": "Seleccionar miniatura",
        "image_files_filter": "Archivos de imagen (*.png *.jpg *.jpeg)",
        "select_platform_title": "Seleccionar plataforma",
        "select_platform_prompt": "Elija una plataforma de redes sociales:",
        "loading_clips_message": "Cargando clips y subttulos... Por favor espere.",
        "moving_media_message": "Moviendo clip multimedia... Por favor espere.",
        "processing_subtitles_message": "Procesando subttulos... Por favor espere.",
        "loading_title": "Cargando",
        "processing_title": "Procesando",
        "support_tab": "Soporte",
        "check_faq_label": "Por favor, revise primero nuestras Preguntas Frecuentes:",
        "faq_link_text": "Haga clic aqu para FAQ",
        "sr_number_label": "Nmero SR",
        "customer_name_label": "Nombre del cliente",
        "email_label": "Correo electrnico",
        "phone_label": "Telfono",
        "ticket_type_label": "Tipo de Ticket",
        "issue_description_label": "Descripcin del problema",
        "video_name_label": "Nombre del video",
        "creation_dt_label": "Fecha/Hora de creacin (tentativa)",
        "desc_label": "Descripcin",
        "send_button": "Enviar Ticket",
        "sr_sent_title": "Ticket Enviado",
        "sr_sent_msg": "Su solicitud de soporte se ha enviado correctamente!"
    },
    # Frensh
    "fr": {
        "missing_required_title": "Champs obligatoires manquants",
        "missing_required_msg": "Veuillez remplir tous les champs obligatoires:\n",
        "issue_option": "Problme",
        "enh_option":   "Amlioration",
        "comment_option": "Commentaire",
        "coming_soon_title":       "Bientt disponible",
        "coming_soon_msg": (
            "L'intgration pour {} sera bientt disponible.\n\n"
            "Veuillez tlcharger manuellement la vido finale.\n"
            "Chemin de la vido : {}"
        ),
        "youtube_shorts_reminder_title": "Rappel YouTube Shorts",
        "youtube_shorts_reminder_msg": (
            "REMARQUE : les YouTube Shorts sont destins  des vidos de 60 secondes ou moins. "
            "Veuillez vous assurer que votre vido rpond  cette exigence de dure pour les YouTube Shorts."
        ),
        "file_not_found_title":    " AVERTISSEMENT : fichier introuvable",
        "file_not_found_msg": (
            "Fichier vido final pour {} introuvable. "
            "Vous ne l'avez peut-tre pas gnr pour cette plateforme. "
            "Veuillez le gnrer et ressayer."
        ),
        "yes": "Oui",
        "no": "Non",
        "video": "Vido",
        "image": "Image",
        "info": "Info",
        "switch_account": "Changer de compte",
        "main_tab_title": "Principal",
        "target_language_label": "Langue cible:",
        "voice_label": "Slectionnez la voix du narrateur :",
        "video_title_label": "Titre de la vido :",
        "platform_label": "Plateforme :",
        "prompt_label": "Entrez l'invite pour le contenu vido (dans n'importe quelle langue) :",
        "genre_label": "Slectionnez le genre instrumental :",
        "modify_label": "Modifier les mots-cls ?",
        "bypass_label": "Contourner le texte, les sous-titres et la voix-off ?",
        "status_label": "Statut :",
        "save_subtitles_btn": "Enregistrer et rgnrer les sous-titres",
        "start_video_btn": "Dmarrer la cration de la vido",
        "play_video_btn_final": "Lire la vido",
        "replace_clip_btn": "Remplacer le clip slectionn",
        "delete_clip_btn": "Supprimer les clips slectionns",
        "base_directory_label": "Rpertoire de base :",
        "base_browse_btn": "Parcourir",
        "video_image_folder_label": "Dossier d'images vido :",
        "output_directory_label": "Rpertoire de sortie :",
        "music_folder_label": "Dossier de musique :",
        "voiceover_directory_label": "Rpertoire de la voix off :",
        "review_script_tab": "Rviser ou modifier le script",
        "review_clips_tab": "Rviser ou modifier les clips et sous-titres",
        "test_voice_button": "Tester la voix",
        "generate_final_video_btn": "Gnrer la vido finale",
        "final_video_tab": "Vido finale",
        "upload_video_btn": "Tlcharger sur les rseaux sociaux",
        "clip_table_headers": [
            "Slectionner", "Aperu mdia", "Type de mdia", "Fichier mdia", "Dure mdia",
            "Dbut mdia", "Fin mdia", "Slectionner", "Aperu musique", "Fichier musique",
            "Dure musique", "Dbut musique", "Fin musique", "Sous-titre", "Dbut sous-titre", "Fin sous-titre"
        ],
        "editable_field_tooltip": "Champ modifiable",
        "readonly_field_tooltip": "Champ en lecture seule",
        "bypass_mode_message": (
            "Puisque vous avez slectionn le mode de contournement du script, des sous-titres et de la voix off, "
            "aucun script/sous-titre/voix off n'a t gnr.\n"
            "Veuillez examiner les mdias tlchargs dans l'onglet 'Rviser ou modifier les clips et sous-titres'.\n"
            "Une fois l'examen termin, cliquez sur le bouton 'Gnrer la vido finale' pour gnrer la vido finale.\n"
            "Aprs la gnration de la vido finale, cliquez sur OK dans l'alerte qui apparatra.\n"
            "Vous serez ensuite automatiquement dirig vers l'onglet 'Vido finale' pour prvisualiser la vido.\n"
            "Cliquez sur OK pour fermer cette notification."
        ),
        "normal_mode_message": (
            "Veuillez examiner le contenu gnr :\n"
            "1. Dans l'onglet 'Rviser ou modifier le script', veuillez examiner/modifier le script gnr.\n"
            "2. Ensuite, cliquez sur le bouton 'Enregistrer et rgnrer les sous-titres' pour tre dirig vers "
            "l'onglet 'Rviser ou modifier les clips et sous-titres' pour examen.\n"
            "Une fois l'examen termin, cliquez sur le bouton 'Gnrer la vido finale' pour gnrer la vido finale.\n"
            "Aprs la gnration de la vido finale, cliquez sur OK dans l'alerte qui apparatra.\n"
            "Vous serez ensuite automatiquement dirig vers l'onglet 'Vido finale' pour prvisualiser la vido.\n"
            "Cliquez sur OK pour fermer cette notification."
        ),
        "add_media_btn": "Ajouter mdia",
        "add_music_btn": "Ajouter musique",
        "no_file_placeholder": "Pas de fichier",
        "none_text": "Aucun",
        # ToolTips
        "switch_account_tooltip": "Cochez cette case si vous souhaitez vous connecter avec un autre compte YouTube",
        "target_language_tooltip": "Slectionnez la langue cible pour les traductions de l'interface",
        "prompt_tooltip": (
            "Fournissez une description dtaille du contenu vido que vous souhaitez crer.\n"
            "Incluez les sujets cls, le style souhait et tous les dtails essentiels pour guider le processus de gnration vido.\n"
            "Vous pouvez crire le texte dans n'importe quelle langue ; la vido sera produite dans la langue slectionne.\n"
            "La sortie gnre formera un script vido que vous pourrez examiner ultrieurement."
        ),
        "modify_tooltip": (
            "Choisissez 'Oui' (par dfaut) pour permettre la modification des mots-cls extraits du script ; 'Non' conserve les mots-cls originaux\n"
            "Ces mots-cls dterminent la slection des mdias  tlcharger ; plus de mots-cls peuvent gnrer plus de mdias (et des vidos plus longues),\n"
            "tandis que des mots-cls plus prcis produisent un contenu plus pertinent.\n"
            "Note : Si vous utilisez une langue autre que l'anglais, des mots-cls en anglais seront automatiquement ajouts pour des rsultats optimaux."
        ),
        "modify_yes_tooltip": "Oui : Permettre les modifications des mots-cls extraits",
        "modify_no_tooltip": "Non : Utiliser les mots-cls gnrs initialement",
        "bypass_tooltip": (
            "Lorsque dfini sur 'Oui', la gnration et le traitement du texte, des sous-titres et de la voix off seront contourns\n"
            "Exemple : vidos de mditation ou de relaxation.\n"
            "Lorsque dfini sur 'Non' (par dfaut), le texte, les sous-titres et la voix off sont gnrs."
        ),
        "bypass_yes_tooltip": "Oui : Contourner la gnration de texte, sous-titres et voix off",
        "bypass_no_tooltip": "Non : Gnrer le texte, les sous-titres et la voix off",

        # Buttons
        "play_button": "Lecture",
        "pause_button": "Pause",
        "forward_button": "Avancer (+10 s)",
        "backward_button": "Reculer (-10 s)",
        "browse_button": "Parcourir",

        # Window Titles
        "success_text": "Succs",
        "video_preview_title": "Aperu vido : ",
        "music_preview_title": "Aperu musical : ",
        "voice_selector_title": "Slecteur de voix",
        "upload_details_title": "Dtails du tlchargement",
        "modify_keywords_title": "Modifier les mots-cls",

        # Progress Messages
        "uploading_video": "Tlchargement de la vido vers YouTube... Veuillez patienter.",
        "uploading_thumbnail": "Tlchargement de la miniature... Veuillez patienter.",
        "generating_final_video": "Gnration de la vido finale... Veuillez patienter.",
        "saving_subtitles": "Sauvegarde des sous-titres et rgnration du SRT",
        "replacing_media": "Remplacement des mdias slectionns... Veuillez patienter.",
        "deleting_clips": "Suppression du/des clip(s) slectionn(s)... Veuillez patienter.",
        "inserting_media": "Insertion de nouveaux mdias... Veuillez patienter.",
        "inserting_music": "Insertion de nouvelle musique... Veuillez patienter.",
        "starting_video": "Dmarrage de la cration vido... Veuillez patienter.",

        # Info Messages
        "upload_success": " Tlchargement YouTube termin avec succs !",
        "upload_failure": " Une erreur s'est produite lors du tlchargement.",
        "upload_cancelled": "Le tlchargement a t annul par l'utilisateur.",
        "subtitle_error": " Une erreur s'est produite lors du traitement des sous-titres : ",
        "select_media_warning": "Veuillez slectionner une cellule mdia  remplacer.",
        "unsupported_file": "Le type de fichier slectionn n'est pas pris en charge.",
        "replace_media_error": " Une erreur s'est produite lors du remplacement des mdias slectionns : ",
        "no_items_selected": "Aucun mdia, musique ou sous-titre slectionn pour la suppression.",
        "delete_error": " Une erreur s'est produite lors de la suppression des clips : ",
        "insert_media_error": " Une erreur s'est produite lors de l'insertion de nouveaux mdias : ",
        "video_success_bypass": "Cration vido termine avec succs (mode contournement).",
        "video_success": "Cration vido termine avec succs.",
        "encoding_error": " Erreur lors de l'encodage vido dans un processus spar.",
        "review_content_title": "Information - Examiner le contenu",
        "title_required": "Veuillez saisir un titre pour la vido.",
        "platform_required": "Veuillez slectionner une plateforme.",
        "prompt_required": "Veuillez saisir un texte guide pour la vido.",
        "video_not_found": "Fichier vido non trouv : ",
        "playback_error": " Une erreur s'est produite lors de la lecture de la vido : ",
        "invalid_platform": " Paramtres de plateforme invalides pour .",

        # Status Messages
        "encoding_complete": "Encodage vido termin avec succs.",
        "encoding_error_status": " Erreur lors de l'encodage vido dans un processus spar.",
        "general_error": " Une erreur s'est produite : ",
        "playing_video": "Lecture de la vido : ",
        "subtitles_saved": "Sous-titres sauvegards et gnration de la voix off dmarre...",
        "items_deleted": " lments slectionns supprims.",
        "no_media_found": " Aucun fichier vido ou image trouv dans ",
        "video_processing_error": " Erreur lors du traitement du fichier vido  : ",
        "image_processing_error": " Erreur lors du traitement du fichier image  : ",
        "no_valid_clips": " Aucun clip valide n'a pu tre trait.",
        "invalid_voiceover": " Dure de voix off invalide. Abandon.",
        "no_music_files": " Aucun fichier musical trouv ; dfinition de la liste des clips musicaux comme vide.",
        "review_aborted": "Examen annul par l'utilisateur. Cration vido annule.",
        "video_creation_started": "Cration vido dmarre...",
        "creating_video": "Initialisation - Cration de la vido intitule : ",
        "video_in_progress": "En cours - Cration de la vido intitule : ",
        "main_execution_error": " Erreur dans l'excution principale : ",

        # Dialog Messages
        "enter_keywords": "Entrez les nouveaux mots-cls, spars par des virgules :",
        "description_label": "Description :",
        "tags_label": "Tags (spars par des virgules) :",
        "privacy_label": "Confidentialit :",
        "thumbnail_label": "Miniature :",
        "category_label": "Catgorie :",
        "video_language_label": "Langue de la vido :",
        "recording_date_label": "Date d'enregistrement :",
        "switch_account_label": "Changer de compte YouTube",
        "select_thumbnail": "Slectionner une miniature",
        "image_files_filter": "Fichiers image (*.png *.jpg *.jpeg)",
        "select_platform_title": "Slectionner une plateforme",
        "select_platform_prompt": "Choisissez une plateforme de mdias sociaux :",
        "loading_clips_message": "Chargement des clips et sous-titres... Veuillez patienter.",
        "moving_media_message": "Dplacement du clip mdia... Veuillez patienter.",
        "processing_subtitles_message": "Traitement des sous-titres... Veuillez patienter.",
        "loading_title": "Chargement",
        "processing_title": "Traitement",
        "support_tab": "Support",
        "check_faq_label": "Veuillez d'abord consulter notre FAQ :",
        "faq_link_text": "Cliquez ici pour la FAQ",
        "sr_number_label": "Numro SR",
        "customer_name_label": "Nom du client",
        "email_label": "Email",
        "phone_label": "Tlphone",
        "ticket_type_label": "Type de ticket",
        "issue_description_label": "Description du problme",
        "video_name_label": "Nom de la vido",
        "creation_dt_label": "Date/Heure de cration (prvision)",
        "desc_label": "Description",
        "send_button": "Envoyer le ticket",
        "sr_sent_title": "Ticket envoy",
        "sr_sent_msg": "Votre demande de support a t envoye avec succs !"
    },
    # German
    "de": {
        "missing_required_title": "Fehlende Pflichtfelder",
        "missing_required_msg": "Bitte fllen Sie alle erforderlichen Felder aus:\n",
        "issue_option": "Problem",
        "enh_option":   "Verbesserung",
        "comment_option": "Kommentar",
        "coming_soon_title":       "Kommt bald",
        "coming_soon_msg": (
            "Die Integration fr {} kommt bald.\n\n"
            "Bitte lade das fertige Video manuell hoch.\n"
            "Videopfad: {}"
        ),
        "youtube_shorts_reminder_title": "YouTube Shorts Erinnerung",
        "youtube_shorts_reminder_msg": (
            "HINWEIS: YouTube Shorts sind fr Videos von 60 Sekunden oder weniger gedacht. "
            "Bitte stelle sicher, dass dein Video die Lngenanforderung fr YouTube Shorts erfllt."
        ),
        "file_not_found_title":    " WARNUNG: Datei nicht gefunden",
        "file_not_found_msg": (
            "Die endgltige Videodatei fr {} wurde nicht gefunden. "
            "Mglicherweise haben Sie sie fr diese Plattform nicht erstellt. "
            "Bitte erstellen Sie sie und versuchen Sie es erneut."
        ),
        "yes":            "Ja",
        "no":             "Nein",
        "video":          "Video",
        "image":          "Bild",
        "info":           "Info",
        "switch_account": "Konto wechseln",
        "main_tab_title": "Haupt",
        "target_language_label": "Zielsprache:",
        "voice_label": "Whlen Sie die Sprecherstimme:",
        "video_title_label": "Videotitel:",
        "platform_label": "Plattform:",
        "prompt_label": "Geben Sie den Text fr den Videoinhalt ein (in jeder Sprache):",
        "genre_label": "Whlen Sie das instrumentale Genre:",
        "modify_label": "Schlsselwrter ndern?",
        "bypass_label": "Text, Untertitel und Voiceover berspringen?",
        "status_label": "Status:",
        "save_subtitles_btn": "Untertitel speichern und neu generieren",
        "start_video_btn": "Videoerstellung starten",
        "play_video_btn_final": "Video abspielen",
        "replace_clip_btn": "Ausgewhlten Clip ersetzen",
        "delete_clip_btn": "Ausgewhlte Clips lschen",
        "base_directory_label": "Basisverzeichnis:",
        "base_browse_btn": "Durchsuchen",
        "video_image_folder_label": "Video-Bildordner:",
        "output_directory_label": "Ausgabeverzeichnis:",
        "music_folder_label": "Musikordner:",
        "voiceover_directory_label": "Voiceover-Verzeichnis:",
        "review_script_tab": "Skript berprfen oder bearbeiten",
        "review_clips_tab": "Clips und Untertitel berprfen oder bearbeiten",
        "test_voice_button": "Stimme testen",
        "generate_final_video_btn": "Finales Video generieren",
        "final_video_tab": "Finales Video",
        "upload_video_btn": "In sozialen Medien hochladen",
        "clip_table_headers": [
            "Auswhlen", "Medienvorschau", "Medientyp", "Mediendatei", "Mediendauer",
            "Medienstart", "Medienende", "Auswhlen", "Musikvorschau", "Musikdatei",
            "Musikdauer", "Musikstart", "Musikende", "Untertitel", "Untertitelstart", "Untertitelende"
        ],
        "editable_field_tooltip": "Bearbeitbares Feld",
        "readonly_field_tooltip": "Schreibgeschtztes Feld",
        "bypass_mode_message": (
            "Da Sie den Bypass-Modus fr Skript, Untertitel und Voiceover ausgewhlt haben, "
            "wurden keine Skript/Untertitel/Voiceover generiert.\n"
            "Bitte berprfen Sie die heruntergeladenen Medien im Tab 'Clips und Untertitel berprfen oder bearbeiten'.\n"
            "Nachdem Sie die berprfung abgeschlossen haben, klicken Sie auf 'Finales Video generieren'.\n"
            "Nachdem das finale Video generiert wurde, klicken Sie auf OK im erscheinenden Popup-Fenster.\n"
            "Dann werden Sie automatisch zum Tab 'Finales Video' weitergeleitet, um das Video voranzusehen.\n"
            "Klicken Sie auf OK, um diese Benachrichtigung zu schlieen."
        ),
        "normal_mode_message": (
            "Bitte berprfen Sie den generierten Inhalt:\n"
            "1. Im Tab 'Skript berprfen oder bearbeiten' berprfen/bearbeiten Sie bitte das generierte Skript.\n"
            "2. Klicken Sie dann auf 'Untertitel speichern und neu generieren', um zum "
            "Tab 'Clips und Untertitel berprfen oder bearbeiten' zu gelangen.\n"
            "Nachdem Sie die berprfung abgeschlossen haben, klicken Sie auf 'Finales Video generieren'.\n"
            "Nachdem das finale Video generiert wurde, klicken Sie auf OK im erscheinenden Popup-Fenster.\n"
            "Dann werden Sie automatisch zum Tab 'Finales Video' weitergeleitet, um das Video voranzusehen.\n"
            "Klicken Sie auf OK, um diese Benachrichtigung zu schlieen."
        ),
        "add_media_btn": "Medien hinzufgen",
        "add_music_btn": "Musik hinzufgen",
        "no_file_placeholder": "Keine Datei",
        "none_text": "Keine",
        # ToolTips
        "switch_account_tooltip": "Aktivieren Sie dieses Kontrollkstchen, wenn Sie sich mit einem anderen YouTube-Konto anmelden mchten",
        "target_language_tooltip": "Whlen Sie die Zielsprache fr die Benutzeroberflchen-bersetzungen",
        "prompt_tooltip": (
            "Geben Sie eine ausfhrliche Beschreibung des Videoinhalts ein, den Sie erstellen mchten.\n"
            "Fgen Sie Schlsselthemen, gewnschten Stil und alle wesentlichen Details hinzu, um den Videogenerierungsprozess zu steuern.\n"
            "Sie knnen den Text in jeder Sprache schreiben; das Video wird in der ausgewhlten Sprache erstellt.\n"
            "Die generierte Ausgabe bildet ein Videoskript, das Sie spter berprfen knnen."
        ),
        "modify_tooltip": (
            "Whlen Sie 'Ja' (Standard), um die aus dem Skript extrahierten Schlsselwrter zu bearbeiten; 'Nein' behlt die ursprnglichen Schlsselwrter bei\n"
            "Diese Schlsselwrter bestimmen die Auswahl der herunterzuladenden Medien; mehr Schlsselwrter knnen mehr Medien (und lngere Videos) ergeben,\n"
            "whrend przisere Schlsselwrter relevantere Inhalte produzieren.\n"
            "Hinweis: Wenn Sie eine andere Sprache als Englisch verwenden, werden automatisch englische Schlsselwrter fr optimale Ergebnisse hinzugefgt."
        ),
        "modify_yes_tooltip": "Ja: nderungen an extrahierten Schlsselwrtern erlauben",
        "modify_no_tooltip": "Nein: Ursprnglich generierte Schlsselwrter verwenden",
        "bypass_tooltip": (
            "Wenn auf 'Ja' gesetzt, wird die Generierung und Verarbeitung von Text, Untertiteln und Sprachausgabe umgangen\n"
            "Beispiel: Meditations- oder Entspannungsvideos.\n"
            "Wenn auf 'Nein' (Standard) gesetzt, werden Text, Untertitel und Sprachausgabe generiert."
        ),
        "bypass_yes_tooltip": "Ja: Text-, Untertitel- und Sprachausgabe-Generierung umgehen",
        "bypass_no_tooltip": "Nein: Text, Untertitel und Sprachausgabe generieren",

        # Buttons
        "play_button": "Abspielen",
        "pause_button": "Pause",
        "forward_button": "Vorwrts (+10 s)",
        "backward_button": "Rckwrts (-10 s)",
        "browse_button": "Durchsuchen",

        # Window Titles
        "success_text": "Erfolg",
        "video_preview_title": "Videovorschau: ",
        "music_preview_title": "Musikvorschau: ",
        "voice_selector_title": "Stimmenauswahl",
        "upload_details_title": "Upload-Details",
        "modify_keywords_title": "Schlsselwrter bearbeiten",

        # Progress Messages
        "uploading_video": "Video wird zu YouTube hochgeladen... Bitte warten.",
        "uploading_thumbnail": "Vorschaubild wird hochgeladen... Bitte warten.",
        "generating_final_video": "Finales Video wird generiert... Bitte warten.",
        "saving_subtitles": "Untertitel werden gespeichert und SRT wird neu generiert",
        "replacing_media": "Ausgewhlte Medien werden ersetzt... Bitte warten.",
        "deleting_clips": "Ausgewhlte Clip(s) werden gelscht... Bitte warten.",
        "inserting_media": "Neue Medien werden eingefgt... Bitte warten.",
        "inserting_music": "Neue Musik wird eingefgt... Bitte warten.",
        "starting_video": "Videoerstellung wird gestartet... Bitte warten.",

        # Info Messages
        "upload_success": " YouTube-Video-Upload erfolgreich abgeschlossen!",
        "upload_failure": " Beim Upload ist ein Fehler aufgetreten.",
        "upload_cancelled": "Upload wurde vom Benutzer abgebrochen.",
        "subtitle_error": " Bei der Verarbeitung der Untertitel ist ein Fehler aufgetreten: ",
        "select_media_warning": "Bitte whlen Sie eine Medienzelle zum Ersetzen aus.",
        "unsupported_file": "Der ausgewhlte Dateityp wird nicht untersttzt.",
        "replace_media_error": " Beim Ersetzen der ausgewhlten Medien ist ein Fehler aufgetreten: ",
        "no_items_selected": "Keine Medien, Musik oder Untertitel zum Lschen ausgewhlt.",
        "delete_error": " Beim Lschen der Clips ist ein Fehler aufgetreten: ",
        "insert_media_error": " Beim Einfgen neuer Medien ist ein Fehler aufgetreten: ",
        "video_success_bypass": "Videoerstellung erfolgreich abgeschlossen (Bypass-Modus).",
        "video_success": "Videoerstellung erfolgreich abgeschlossen.",
        "encoding_error": " Fehler beim Codieren des Videos in separatem Prozess.",
        "review_content_title": "Info - Inhalt berprfen",
        "title_required": "Bitte geben Sie einen Videotitel ein.",
        "platform_required": "Bitte whlen Sie eine Plattform aus.",
        "prompt_required": "Bitte geben Sie einen Video-Skript-Prompt ein.",
        "video_not_found": "Videodatei nicht gefunden: ",
        "playback_error": " Beim Abspielen des Videos ist ein Fehler aufgetreten: ",
        "invalid_platform": " Ungltige Plattform-Einstellungen fr .",

        # Status Messages
        "encoding_complete": "Videocodierung erfolgreich abgeschlossen.",
        "encoding_error_status": " Fehler beim Codieren des Videos in separatem Prozess.",
        "general_error": " Ein Fehler ist aufgetreten: ",
        "playing_video": "Video wird abgespielt: ",
        "subtitles_saved": "Untertitel gespeichert und Sprachausgabe-Generierung gestartet...",
        "items_deleted": " Ausgewhlte Elemente gelscht.",
        "no_media_found": " Keine Video- oder Bilddateien gefunden in ",
        "video_processing_error": " Fehler bei der Verarbeitung der Videodatei : ",
        "image_processing_error": " Fehler bei der Verarbeitung der Bilddatei : ",
        "no_valid_clips": " Es konnten keine gltigen Clips verarbeitet werden.",
        "invalid_voiceover": " Ungltige Sprachausgabe-Dauer. Abbruch.",
        "no_music_files": " Keine Musikdateien gefunden; Musik-Clips werden als leere Liste gesetzt.",
        "review_aborted": "berprfung vom Benutzer abgebrochen. Videoerstellung abgebrochen.",
        "video_creation_started": "Videoerstellung gestartet...",
        "creating_video": "Initialisierung - Video wird erstellt mit Titel: ",
        "video_in_progress": "In Bearbeitung - Video wird erstellt mit Titel: ",
        "main_execution_error": " Fehler in der Hauptausfhrung: ",

        # Dialog Messages
        "enter_keywords": "Geben Sie die neuen Schlsselwrter ein, durch Kommas getrennt:",
        "description_label": "Beschreibung:",
        "tags_label": "Tags (durch Kommas getrennt):",
        "privacy_label": "Datenschutz:",
        "thumbnail_label": "Vorschaubild:",
        "category_label": "Kategorie:",
        "video_language_label": "Videosprache:",
        "recording_date_label": "Aufnahmedatum:",
        "switch_account_label": "YouTube-Konto wechseln",
        "select_thumbnail": "Vorschaubild auswhlen",
        "image_files_filter": "Bilddateien (*.png *.jpg *.jpeg)",
        "select_platform_title": "Plattform auswhlen",
        "select_platform_prompt": "Whlen Sie eine Social-Media-Plattform:",
        "loading_clips_message": "Lade Clips und Untertitel... Bitte warten.",
        "moving_media_message": "Verschiebe Medienclip... Bitte warten.",
        "processing_subtitles_message": "Verarbeite Untertitel... Bitte warten.",
        "loading_title": "Laden",
        "processing_title": "Verarbeitung",
        "support_tab": "Support",
        "check_faq_label": "Bitte sehen Sie zuerst in unseren FAQ nach:",
        "faq_link_text": "Hier klicken fr FAQ",
        "sr_number_label": "SR-Nummer",
        "customer_name_label": "Kundenname",
        "email_label": "E-Mail",
        "phone_label": "Telefon",
        "ticket_type_label": "Ticket-Typ",
        "issue_description_label": "Problembeschreibung",
        "video_name_label": "Videoname",
        "creation_dt_label": "Erstellungsdatum/-zeit (geschtzt)",
        "desc_label": "Beschreibung",
        "send_button": "Ticket senden",
        "sr_sent_title": "Ticket gesendet",
        "sr_sent_msg": "Ihre Support-Anfrage wurde erfolgreich gesendet!"
    },
    # Portuguese
    "pt": {
        "missing_required_title": "Campos obrigatrios ausentes",
        "missing_required_msg": "Por favor, preencha todos os campos obrigatrios:\n",
        "issue_option": "Problema",
        "enh_option":   "Aprimoramento",
        "comment_option": "Comentrio",
        "coming_soon_title":       "Em breve",
        "coming_soon_msg": (
            "A integrao com {} estar disponvel em breve.\n\n"
            "Por favor, carregue o vdeo final manualmente.\n"
            "Caminho do vdeo: {}"
        ),
        "youtube_shorts_reminder_title": "Lembrete do YouTube Shorts",
        "youtube_shorts_reminder_msg": (
            "NOTA: Os YouTube Shorts destinam-se a vdeos de 60 segundos ou menos. "
            "Por favor, certifique-se de que o seu vdeo cumpra o requisito de durao para o YouTube Shorts."
        ),
        "file_not_found_title":    " AVISO: Arquivo no encontrado",
        "file_not_found_msg": (
            "Arquivo de vdeo final para {} no encontrado. "
            "Voc pode no t-lo gerado para esta plataforma. "
            "Gere-o e tente novamente."
        ),
        "yes":            "Sim",
        "no":             "No",
        "video":          "Vdeo",
        "image":          "Imagem",
        "info":           "Informao",
        "switch_account": "Mudar Conta",
        "main_tab_title": "Principal",
        "target_language_label": "Idioma de destino:",
        "voice_label": "Selecione a voz do narrador:",
        "video_title_label": "Ttulo do vdeo:",
        "platform_label": "Plataforma:",
        "prompt_label": "Digite o prompt para o contedo do vdeo (em qualquer idioma):",
        "genre_label": "Selecione o gnero instrumental:",
        "modify_label": "Modificar palavras-chave?",
        "bypass_label": "Ignorar texto, legendas e narrao?",
        "status_label": "Status:",
        "save_subtitles_btn": "Salvar e regenerar legendas",
        "start_video_btn": "Iniciar criao do vdeo",
        "play_video_btn_final": "Reproduzir vdeo",
        "replace_clip_btn": "Substituir clipe selecionado",
        "delete_clip_btn": "Excluir clipes selecionados",
        "base_directory_label": "Diretrio base:",
        "base_browse_btn": "Procurar",
        "video_image_folder_label": "Pasta de imagens do vdeo:",
        "output_directory_label": "Diretrio de sada:",
        "music_folder_label": "Pasta de msica:",
        "voiceover_directory_label": "Diretrio de narrao:",
        "review_script_tab": "Revisar ou editar o roteiro",
        "review_clips_tab": "Revisar ou editar clipes e legendas",
        "test_voice_button": "Testar voz",
        "generate_final_video_btn": "Gerar vdeo final",
        "final_video_tab": "Vdeo final",
        "upload_video_btn": "Enviar para redes sociais",
        "clip_table_headers": [
            "Selecionar", "Prvia de mdia", "Tipo de mdia", "Arquivo de mdia", "Durao mdia",
            "Incio mdia", "Fim mdia", "Selecionar", "Prvia msica", "Arquivo msica",
            "Durao msica", "Incio msica", "Fim msica", "Legenda", "Incio legenda", "Fim legenda"
        ],
        "editable_field_tooltip": "Campo editvel",
        "readonly_field_tooltip": "Campo somente leitura",
        "bypass_mode_message": (
            "Como voc selecionou o modo de bypass de roteiro, legendas e narrao, "
            "nenhum roteiro/legenda/narrao foi gerado.\n"
            "Por favor, revise a mdia baixada na aba 'Revisar ou editar clipes e legendas'.\n"
            "Depois de terminar a reviso, clique no boto 'Gerar vdeo final' para gerar o vdeo final.\n"
            "Aps o vdeo final ser gerado, clique em OK no alerta que aparecer.\n"
            "Ento, voc ser automaticamente direcionado para a aba 'Vdeo final' para visualizar o vdeo.\n"
            "Clique em OK para dispensar esta notificao."
        ),
        "normal_mode_message": (
            "Por favor, revise o contedo gerado:\n"
            "1. Na aba 'Revisar ou editar o roteiro', por favor revise/edite o roteiro gerado.\n"
            "2. Em seguida, clique no boto 'Salvar e regenerar legendas' para ser direcionado  "
            "aba 'Revisar ou editar clipes e legendas' para reviso.\n"
            "Depois de terminar a reviso, clique no boto 'Gerar vdeo final' para gerar o vdeo final.\n"
            "Aps o vdeo final ser gerado, clique em OK no alerta que aparecer.\n"
            "Ento, voc ser automaticamente direcionado para a aba 'Vdeo final' para visualizar o vdeo.\n"
            "Clique em OK para dispensar esta notificao."
        ),
        "add_media_btn": "Adicionar mdia",
        "add_music_btn": "Adicionar msica",
        "no_file_placeholder": "Sem arquivo",
        "none_text": "Nenhum",
        # ToolTips
        "switch_account_tooltip": "Marque esta caixa se quiser fazer login com uma conta diferente do YouTube",
        "target_language_tooltip": "Selecione o idioma alvo para as tradues da interface",
        "prompt_tooltip": (
            "Fornea uma descrio detalhada do contedo do vdeo que deseja criar.\n"
            "Inclua tpicos principais, estilo desejado e todos os detalhes essenciais para guiar o processo de gerao do vdeo.\n"
            "Voc pode escrever o texto em qualquer idioma; o vdeo ser produzido no idioma selecionado.\n"
            "A sada gerada formar um roteiro de vdeo que voc poder revisar posteriormente."
        ),
        "modify_tooltip": (
            "Escolha 'Sim' (padro) para permitir a edio das palavras-chave extradas do roteiro; 'No' mantm as palavras-chave originais\n"
            "Essas palavras-chave determinam a seleo de mdia a ser baixada; mais palavras-chave podem gerar mais mdia (e vdeos mais longos),\n"
            "enquanto palavras-chave mais precisas produzem contedo mais relevante.\n"
            "Nota: Se voc usar um idioma diferente do ingls, palavras-chave em ingls sero adicionadas automaticamente para resultados ideais."
        ),
        "modify_yes_tooltip": "Sim: Permitir modificaes nas palavras-chave extradas",
        "modify_no_tooltip": "No: Usar palavras-chave geradas originalmente",
        "bypass_tooltip": (
            "Quando definido como 'Sim', a gerao e processamento de texto, legendas e narrao sero ignorados\n"
            "Exemplo: vdeos de meditao ou relaxamento.\n"
            "Quando definido como 'No' (padro), texto, legendas e narrao so gerados."
        ),
        "bypass_yes_tooltip": "Sim: Ignorar gerao de texto, legendas e narrao",
        "bypass_no_tooltip": "No: Gerar texto, legendas e narrao",

        # Buttons
        "play_button": "Reproduzir",
        "pause_button": "Pausar",
        "forward_button": "Avanar (+10 s)",
        "backward_button": "Retroceder (-10 s)",
        "browse_button": "Procurar",

        # Window Titles
        "success_text": "Sucesso",
        "video_preview_title": "Pr-visualizao do vdeo: ",
        "music_preview_title": "Pr-visualizao da msica: ",
        "voice_selector_title": "Seletor de voz",
        "upload_details_title": "Detalhes do upload",
        "modify_keywords_title": "Modificar palavras-chave",

        # Progress Messages
        "uploading_video": "Fazendo upload do vdeo para o YouTube... Por favor, aguarde.",
        "uploading_thumbnail": "Fazendo upload da miniatura... Por favor, aguarde.",
        "generating_final_video": "Gerando vdeo final... Por favor, aguarde.",
        "saving_subtitles": "Salvando legendas e regenerando SRT",
        "replacing_media": "Substituindo mdia selecionada... Por favor, aguarde.",
        "deleting_clips": "Excluindo clip(s) selecionado(s)... Por favor, aguarde.",
        "inserting_media": "Inserindo nova mdia... Por favor, aguarde.",
        "inserting_music": "Inserindo nova msica... Por favor, aguarde.",
        "starting_video": "Iniciando criao do vdeo... Por favor, aguarde.",

        # Info Messages
        "upload_success": " Upload do vdeo para o YouTube concludo com sucesso!",
        "upload_failure": " Ocorreu um erro durante o upload.",
        "upload_cancelled": "Upload foi cancelado pelo usurio.",
        "subtitle_error": " Ocorreu um erro durante o processamento das legendas: ",
        "select_media_warning": "Por favor, selecione uma clula de mdia para substituir.",
        "unsupported_file": "O tipo de arquivo selecionado no  suportado.",
        "replace_media_error": " Ocorreu um erro ao substituir a mdia selecionada: ",
        "no_items_selected": "Nenhuma mdia, msica ou legenda selecionada para excluso.",
        "delete_error": " Ocorreu um erro ao excluir clips: ",
        "insert_media_error": " Ocorreu um erro ao inserir nova mdia: ",
        "video_success_bypass": "Criao do vdeo concluda com sucesso (modo bypass).",
        "video_success": "Criao do vdeo concluda com sucesso.",
        "encoding_error": " Erro ao codificar vdeo em processo separado.",
        "review_content_title": "Informao - Revisar contedo",
        "title_required": "Por favor, insira um ttulo para o vdeo.",
        "platform_required": "Por favor, selecione uma plataforma.",
        "prompt_required": "Por favor, insira um prompt para o roteiro do vdeo.",
        "video_not_found": "Arquivo de vdeo no encontrado: ",
        "playback_error": " Ocorreu um erro ao reproduzir o vdeo: ",
        "invalid_platform": " Configuraes de plataforma invlidas para .",

        # Status Messages
        "encoding_complete": "Codificao do vdeo concluda com sucesso.",
        "encoding_error_status": " Erro ao codificar vdeo em processo separado.",
        "general_error": " Ocorreu um erro: ",
        "playing_video": "Reproduzindo vdeo: ",
        "subtitles_saved": "Legendas salvas e gerao de narrao iniciada...",
        "items_deleted": " Itens selecionados excludos.",
        "no_media_found": " Nenhum arquivo de vdeo ou imagem encontrado em ",
        "video_processing_error": " Erro ao processar arquivo de vdeo : ",
        "image_processing_error": " Erro ao processar arquivo de imagem : ",
        "no_valid_clips": " No foi possvel processar clips vlidos.",
        "invalid_voiceover": " Durao de narrao invlida. Abortando.",
        "no_music_files": " Nenhum arquivo de msica encontrado; definindo lista de clips de msica como vazia.",
        "review_aborted": "Reviso abortada pelo usurio. Criao do vdeo cancelada.",
        "video_creation_started": "Criao do vdeo iniciada...",
        "creating_video": "Inicializando - Criando vdeo intitulado: ",
        "video_in_progress": "Em andamento - Criando vdeo intitulado: ",
        "main_execution_error": " Erro na execuo principal: ",

        # Dialog Messages
        "enter_keywords": "Digite as novas palavras-chave, separadas por vrgulas:",
        "description_label": "Descrio:",
        "tags_label": "Tags (separadas por vrgulas):",
        "privacy_label": "Privacidade:",
        "thumbnail_label": "Miniatura:",
        "category_label": "Categoria:",
        "video_language_label": "Idioma do vdeo:",
        "recording_date_label": "Data de gravao:",
        "switch_account_label": "Trocar conta do YouTube",
        "select_thumbnail": "Selecionar miniatura",
        "image_files_filter": "Arquivos de imagem (*.png *.jpg *.jpeg)",
        "select_platform_title": "Selecionar plataforma",
        "select_platform_prompt": "Escolha uma plataforma de mdia social:",
        "loading_clips_message": "Carregando clipes e legendas... Por favor, aguarde.",
        "moving_media_message": "Movendo clipe de mdia... Por favor, aguarde.",
        "processing_subtitles_message": "Processando legendas... Por favor, aguarde.",
        "loading_title": "Carregando",
        "processing_title": "Processando",
        "support_tab": "Suporte",
        "check_faq_label": "Por favor, verifique primeiro nossas Perguntas Frequentes:",
        "faq_link_text": "Clique aqui para o FAQ",
        "sr_number_label": "Nmero SR",
        "customer_name_label": "Nome do Cliente",
        "email_label": "E-mail",
        "phone_label": "Telefone",
        "ticket_type_label": "Tipo de Ticket",
        "issue_description_label": "Descrio do Problema",
        "video_name_label": "Nome do Vdeo",
        "creation_dt_label": "Data/Hora de Criao (estimada)",
        "desc_label": "Descrio",
        "send_button": "Enviar Ticket",
        "sr_sent_title": "Ticket Enviado",
        "sr_sent_msg": "Seu pedido de suporte foi enviado com sucesso!"
    },
    # Russian
    "ru": {
        "missing_required_title": "  ",
        "missing_required_msg": ",    :\n",
        "issue_option": "",
        "enh_option":   "",
        "comment_option": "",
        "coming_soon_title":       " ",
        "coming_soon_msg": (
            "  {}   .\n\n"
            ",    .\n"
            "  : {}"
        ),
        "youtube_shorts_reminder_title": " YouTube Shorts",
        "youtube_shorts_reminder_msg": (
            ": YouTube Shorts     60   . "
            ", ,        YouTube Shorts."
        ),
        "file_not_found_title":    "  :   ",
        "file_not_found_msg": (
            "      {}. "
            ",       . "
            ",     ."
        ),
        "yes":            "",
        "no":             "",
        "video":          "",
        "image":          "",
        "info":           "",
        "switch_account": " ",
        "main_tab_title": "",
        "target_language_label": " :",
        "voice_label": "  :",
        "video_title_label": " :",
        "platform_label": ":",
        "prompt_label": "     (  ):",
        "genre_label": "  :",
        "modify_label": "  ?",
        "bypass_label": " ,   ?",
        "status_label": ":",
        "save_subtitles_btn": "   ",
        "start_video_btn": "  ",
        "play_video_btn_final": " ",
        "replace_clip_btn": "  ",
        "delete_clip_btn": "  ",
        "base_directory_label": " :",
        "base_browse_btn": "",
        "video_image_folder_label": "   :",
        "output_directory_label": " :",
        "music_folder_label": "  :",
        "voiceover_directory_label": " :",
        "review_script_tab": "   ",
        "review_clips_tab": "     ",
        "test_voice_button": " ",
        "generate_final_video_btn": "  ",
        "final_video_tab": " ",
        "upload_video_btn": "   ",
        "clip_table_headers": [
            "", " ", " ", "", " ",
            " ", " ", "", " ", " ",
            " ", " ", " ", "", " ", " "
        ],
        "editable_field_tooltip": " ",
        "readonly_field_tooltip": "   ",
        "bypass_mode_message": (
            "     ,   , "
            "//   .\n"
            ",      '     '.\n"
            "     '  '.\n"
            "     OK   .\n"
            "       ' '  .\n"
            " OK,    ."
        ),
        "normal_mode_message": (
            ",   :\n"
            "1.   '   ' /  .\n"
            "2.    '   ',    "
            " '     '  .\n"
            "     '  '.\n"
            "     OK   .\n"
            "       ' '  .\n"
            " OK,    ."
        ),
        "add_media_btn": " ",
        "add_music_btn": " ",
        "no_file_placeholder": " ",
        "none_text": "",
        # ToolTips
        "switch_account_tooltip": "  ,       YouTube",
        "target_language_tooltip": "     ",
        "prompt_tooltip": (
            "   ,    .\n"
            "  ,           .\n"
            "      ;      .\n"
            "   ,     ."
        ),
        "modify_tooltip": (
            " '' ( ),     ,   ; ''    \n"
            "      ;        (   ),\n"
            "           .\n"
            ":    ,   ,         ."
        ),
        "modify_yes_tooltip": ":     ",
        "modify_no_tooltip": ":     ",
        "bypass_tooltip": (
            "  ''    ,      \n"
            ":     .\n"
            "  '' ( ) ,      ."
        ),
        "bypass_yes_tooltip": ":   ,    ",
        "bypass_no_tooltip": ":  ,    ",

        # Buttons
        "play_button": "",
        "pause_button": "",
        "forward_button": " (+10 )",
        "backward_button": " (-10 )",
        "browse_button": "",

        # Window Titles
        "success_text": "",
        "video_preview_title": " : ",
        "music_preview_title": " : ",
        "voice_selector_title": " ",
        "upload_details_title": " ",
        "modify_keywords_title": "  ",

        # Progress Messages
        "uploading_video": "   YouTube... , .",
        "uploading_thumbnail": " ... , .",
        "generating_final_video": "  ... , .",
        "saving_subtitles": "     SRT",
        "replacing_media": "  ... , .",
        "deleting_clips": "  ... , .",
        "inserting_media": "  ... , .",
        "inserting_music": "  ... , .",
        "starting_video": "  ... , .",

        # Info Messages
        "upload_success": "    YouTube  !",
        "upload_failure": "    .",
        "upload_cancelled": "   .",
        "subtitle_error": "     : ",
        "select_media_warning": ",     .",
        "unsupported_file": "    .",
        "replace_media_error": "      : ",
        "no_items_selected": "  ,     .",
        "delete_error": "     : ",
        "insert_media_error": "      : ",
        "video_success_bypass": "    ( ).",
        "video_success": "   .",
        "encoding_error": "      .",
        "review_content_title": " -  ",
        "title_required": ",   .",
        "platform_required": ",  .",
        "prompt_required": ",    .",
        "video_not_found": "  : ",
        "playback_error": "     : ",
        "invalid_platform": "     .",

        # Status Messages
        "encoding_complete": "   .",
        "encoding_error_status": "      .",
        "general_error": "  : ",
        "playing_video": " : ",
        "subtitles_saved": "      ...",
        "items_deleted": "   .",
        "no_media_found": "       ",
        "video_processing_error": "    : ",
        "image_processing_error": "    : ",
        "no_valid_clips": "     .",
        "invalid_voiceover": "    . .",
        "no_music_files": "    ;      .",
        "review_aborted": "  .   .",
        "video_creation_started": "  ...",
        "creating_video": " -    : ",
        "video_in_progress": "  -    : ",
        "main_execution_error": "    : ",

        # Dialog Messages
        "enter_keywords": "   ,  :",
        "description_label": ":",
        "tags_label": " ( ):",
        "privacy_label": ":",
        "thumbnail_label": ":",
        "category_label": ":",
        "video_language_label": " :",
        "recording_date_label": " :",
        "switch_account_label": "  YouTube",
        "select_thumbnail": " ",
        "image_files_filter": "  (*.png *.jpg *.jpeg)",
        "select_platform_title": " ",
        "select_platform_prompt": "   :",
        "loading_clips_message": "   ... , .",
        "moving_media_message": " ... , .",
        "processing_subtitles_message": " ... , .",
        "loading_title": "",
        "processing_title": "",
        "support_tab": "",
        "check_faq_label": ",     FAQ:",
        "faq_link_text": " ,    FAQ",
        "sr_number_label": " SR",
        "customer_name_label": " ",
        "email_label": " ",
        "phone_label": "",
        "ticket_type_label": " ",
        "issue_description_label": " ",
        "video_name_label": " ",
        "creation_dt_label": "/  ()",
        "desc_label": "",
        "send_button": " ",
        "sr_sent_title": " ",
        "sr_sent_msg": "      !"
    },
    # Chinese (Simplified)
    "zh": {
        "missing_required_title": "",
        "missing_required_msg": "\n",
        "issue_option": "",
        "enh_option":   "",
        "comment_option": "",
        "coming_soon_title":       "",
        "coming_soon_msg": (
            "{} \n\n"
            "\n"
            "{}"
        ),
        "youtube_shorts_reminder_title": "YouTube Shorts ",
        "youtube_shorts_reminder_msg": (
            "YouTube Shorts  60 "
            " YouTube Shorts "
        ),
        "file_not_found_title":    " ",
        "file_not_found_msg": (
            "{} "
            ""
            ""
        ),
        "yes":            "",
        "no":             "",
        "video":          "",
        "image":          "",
        "info":           "",
        "switch_account": "",
        "main_tab_title": "",
        "target_language_label": ":",
        "voice_label": "",
        "video_title_label": "",
        "platform_label": "",
        "prompt_label": "",
        "genre_label": "",
        "modify_label": "",
        "bypass_label": "",
        "status_label": "",
        "save_subtitles_btn": "",
        "start_video_btn": "",
        "play_video_btn_final": "",
        "replace_clip_btn": "",
        "delete_clip_btn": "",
        "base_directory_label": "",
        "base_browse_btn": "",
        "video_image_folder_label": "",
        "output_directory_label": "",
        "music_folder_label": "",
        "voiceover_directory_label": "",
        "review_script_tab": "",
        "review_clips_tab": "",
        "test_voice_button": "",
        "generate_final_video_btn": "",
        "final_video_tab": "",
        "upload_video_btn": "",
        "clip_table_headers": [
            "", "", "", "", "",
            "", "", "", "", "",
            "", "", "", "", "", ""
        ],
        "editable_field_tooltip": "",
        "readonly_field_tooltip": "",
        "bypass_mode_message": """ 
        //
        ""
        ""
         OK
        ""
         OK """,
        "normal_mode_message": """
        1. ""/
        2. """"
        ""
         OK
        ""
         OK """,
        "add_media_btn": "",
        "add_music_btn": "",
        "no_file_placeholder": "",
        "none_text": "",
        # ToolTips
        "switch_account_tooltip": "YouTube",
        "target_language_tooltip": "",
        "prompt_tooltip": (
            "\n"
            "\n"
            "\n"
            ""
        ),
        "modify_tooltip": (
            "''''\n"
            "\n"
            "\n"
            ""
        ),
        "modify_yes_tooltip": "",
        "modify_no_tooltip": "",
        "bypass_tooltip": (
            "''\n"
            "\n"
            "''"
        ),
        "bypass_yes_tooltip": "",
        "bypass_no_tooltip": "",

        # Buttons
        "play_button": "",
        "pause_button": "",
        "forward_button": " (+10)",
        "backward_button": " (-10)",
        "browse_button": "",

        # Window Titles
        "success_text": "",
        "video_preview_title": ": ",
        "music_preview_title": ": ",
        "voice_selector_title": "",
        "upload_details_title": "",
        "modify_keywords_title": "",

        # Progress Messages
        "uploading_video": "YouTube... ",
        "uploading_thumbnail": "... ",
        "generating_final_video": "... ",
        "saving_subtitles": "SRT",
        "replacing_media": "... ",
        "deleting_clips": "... ",
        "inserting_media": "... ",
        "inserting_music": "... ",
        "starting_video": "... ",

        # Info Messages
        "upload_success": " YouTube",
        "upload_failure": " ",
        "upload_cancelled": "",
        "subtitle_error": " ",
        "select_media_warning": "",
        "unsupported_file": "",
        "replace_media_error": " ",
        "no_items_selected": "",
        "delete_error": " ",
        "insert_media_error": " ",
        "video_success_bypass": "",
        "video_success": "",
        "encoding_error": " ",
        "review_content_title": " - ",
        "title_required": "",
        "platform_required": "",
        "prompt_required": "",
        "video_not_found": "",
        "playback_error": " ",
        "invalid_platform": " ",

        # Status Messages
        "encoding_complete": "",
        "encoding_error_status": " ",
        "general_error": " ",
        "playing_video": "",
        "subtitles_saved": "...",
        "items_deleted": " ",
        "no_media_found": " ",
        "video_processing_error": " ",
        "image_processing_error": " ",
        "no_valid_clips": " ",
        "invalid_voiceover": " ",
        "no_music_files": " ",
        "review_aborted": "",
        "video_creation_started": "...",
        "creating_video": " - ",
        "video_in_progress": " - ",
        "main_execution_error": " ",

        # Dialog Messages
        "enter_keywords": "",
        "description_label": "",
        "tags_label": "",
        "privacy_label": "",
        "thumbnail_label": "",
        "category_label": "",
        "video_language_label": "",
        "recording_date_label": "",
        "switch_account_label": "YouTube",
        "select_thumbnail": "",
        "image_files_filter": " (*.png *.jpg *.jpeg)",
        "select_platform_title": "",
        "select_platform_prompt": "",
        "loading_clips_message": "...",
        "moving_media_message": "...",
        "processing_subtitles_message": "...",
        "loading_title": "",
        "processing_title": "",
        "support_tab": "",
        "check_faq_label": "",
        "faq_link_text": "FAQ",
        "sr_number_label": "SR",
        "customer_name_label": "",
        "email_label": "",
        "phone_label": "",
        "ticket_type_label": "",
        "issue_description_label": "",
        "video_name_label": "",
        "creation_dt_label": "/",
        "desc_label": "",
        "send_button": "",
        "sr_sent_title": "",
        "sr_sent_msg": ""
    },
    # Japanese
    "ja": {
        "missing_required_title": "",
        "missing_required_msg": ":\n",
        "issue_option": "",
        "enh_option":   "",
        "comment_option": "",
        "coming_soon_title":       "",
        "coming_soon_msg": (
            "{} \n\n"
            "\n"
            "{}"
        ),
        "youtube_shorts_reminder_title": "YouTube Shorts ",
        "youtube_shorts_reminder_msg": (
            "YouTube Shorts 60"
            " YouTube Shorts "
        ),
        "file_not_found_title":    " : ",
        "file_not_found_msg": (
            "{} "
            ""
            ""
        ),
        "yes": "",
        "no": "",
        "video": "",
        "image": "",
        "info": "",
        "switch_account": "",
        "main_tab_title": "",
        "target_language_label": ":",
        "voice_label": "",
        "video_title_label": "",
        "platform_label": "",
        "prompt_label": "",
        "genre_label": "",
        "modify_label": "",
        "bypass_label": "",
        "status_label": "",
        "save_subtitles_btn": "",
        "start_video_btn": "",
        "play_video_btn_final": "",
        "replace_clip_btn": "",
        "delete_clip_btn": "",
        "base_directory_label": "",
        "base_browse_btn": "",
        "video_image_folder_label": "",
        "output_directory_label": "",
        "music_folder_label": "",
        "voiceover_directory_label": "",
        "review_script_tab": "",
        "review_clips_tab": "",
        "test_voice_button": "",
        "generate_final_video_btn": "",
        "final_video_tab": "",
        "upload_video_btn": "",
        "clip_table_headers": [
            "", "", "", "", "",
            "", "", "", "", "",
            "", "", "", "", "", ""
        ],
        "editable_field_tooltip": "",
        "readonly_field_tooltip": "",
        "bypass_mode_message": (
            ""
            "//\n"
            "\n"
            "\n"
            " OK \n"
            "\n"
            "OK "
        ),
        "normal_mode_message": (
            "\n"
            "1. /\n"
            "2. "
            "\n"
            "\n"
            " OK \n"
            "\n"
            "OK "
        ),
        "add_media_btn": "",
        "add_music_btn": "",
        "no_file_placeholder": "",
        "none_text": "",
        # ToolTips
        "switch_account_tooltip": "YouTube",
        "target_language_tooltip": "",
        "prompt_tooltip": (
            "\n"
            "\n"
            "\n"
            ""
        ),
        "modify_tooltip": (
            "''''\n"
            "\n"
            "\n"
            ""
        ),
        "modify_yes_tooltip": "",
        "modify_no_tooltip": "",
        "bypass_tooltip": (
            "''\n"
            "\n"
            "''"
        ),
        "bypass_yes_tooltip": "",
        "bypass_no_tooltip": "",

        # Buttons
        "play_button": "",
        "pause_button": "",
        "forward_button": " (+10)",
        "backward_button": " (-10)",
        "browse_button": "",

        # Window Titles
        "success_text": "",
        "video_preview_title": ": ",
        "music_preview_title": ": ",
        "voice_selector_title": "",
        "upload_details_title": "",
        "modify_keywords_title": "",

        # Progress Messages
        "uploading_video": "YouTube... ",
        "uploading_thumbnail": "... ",
        "generating_final_video": "... ",
        "saving_subtitles": "SRT",
        "replacing_media": "... ",
        "deleting_clips": "... ",
        "inserting_media": "... ",
        "inserting_music": "... ",
        "starting_video": "... ",

        # Info Messages
        "upload_success": " YouTube",
        "upload_failure": " ",
        "upload_cancelled": "",
        "subtitle_error": " : ",
        "select_media_warning": "",
        "unsupported_file": "",
        "replace_media_error": " : ",
        "no_items_selected": "",
        "delete_error": " : ",
        "insert_media_error": " : ",
        "video_success_bypass": "",
        "video_success": "",
        "encoding_error": " ",
        "review_content_title": " - ",
        "title_required": "",
        "platform_required": "",
        "prompt_required": "",
        "video_not_found": ": ",
        "playback_error": " : ",
        "invalid_platform": " ",

        # Status Messages
        "encoding_complete": "",
        "encoding_error_status": " ",
        "general_error": " : ",
        "playing_video": ": ",
        "subtitles_saved": "...",
        "items_deleted": " ",
        "no_media_found": " ",
        "video_processing_error": " : ",
        "image_processing_error": " : ",
        "no_valid_clips": " ",
        "invalid_voiceover": " ",
        "no_music_files": " ",
        "review_aborted": "",
        "video_creation_started": "...",
        "creating_video": " - ",
        "video_in_progress": " - ",
        "main_execution_error": " : ",

        # Dialog Messages
        "enter_keywords": ":",
        "description_label": ":",
        "tags_label": ":",
        "privacy_label": ":",
        "thumbnail_label": ":",
        "category_label": ":",
        "video_language_label": ":",
        "recording_date_label": ":",
        "switch_account_label": "YouTube",
        "select_thumbnail": "",
        "image_files_filter": " (*.png *.jpg *.jpeg)",
        "select_platform_title": "",
        "select_platform_prompt": ":",
        "loading_clips_message": "... ",
        "moving_media_message": "... ",
        "processing_subtitles_message": "... ",
        "loading_title": "",
        "processing_title": "",
        "support_tab": "",
        "check_faq_label": "FAQ:",
        "faq_link_text": "FAQ",
        "sr_number_label": "SR",
        "customer_name_label": "",
        "email_label": "",
        "phone_label": "",
        "ticket_type_label": "",
        "issue_description_label": "",
        "video_name_label": "",
        "creation_dt_label": "",
        "desc_label": "",
        "send_button": "",
        "sr_sent_title": "",
        "sr_sent_msg": ""
    },
    # Hindi
    "hi": {
        "missing_required_title": "   ",
        "missing_required_msg": "    :\n",
        "issue_option": "",
        "enh_option":   "",
        "comment_option": "",
        "coming_soon_title":       "   ",
        "coming_soon_msg": (
            "{}        \n\n"
            "       \n"
            " : {}"
        ),
        "youtube_shorts_reminder_title": "YouTube Shorts ",
        "youtube_shorts_reminder_msg": (
            ": YouTube Shorts 60            "
            "      YouTube Shorts       "
        ),
        "file_not_found_title":    " :   ",
        "file_not_found_msg": (
            "{}        "
            "            "
            "      "
        ),
        "yes":            "",
        "no":             "",
        "video":          "",
        "image":          "",
        "info":           "",
        "switch_account": " ",
        "main_tab_title": "",
        "target_language_label": " :",
        "voice_label": "   :",
        "video_title_label": "  :",
        "platform_label": ":",
        "prompt_label": "       (   ):",
        "genre_label": "  :",
        "modify_label": "   ?",
        "bypass_label": ",    ?",
        "status_label": ":",
        "save_subtitles_btn": "   :  ",
        "start_video_btn": "   ",
        "play_video_btn_final": " ",
        "replace_clip_btn": "  ",
        "delete_clip_btn": "  ",
        "base_directory_label": " :",
        "base_browse_btn": " ",
        "video_image_folder_label": "  :",
        "output_directory_label": " :",
        "music_folder_label": " :",
        "voiceover_directory_label": " :",
        "review_script_tab": "     ",
        "review_clips_tab": "       ",
        "test_voice_button": "  ",
        "generate_final_video_btn": "   ",
        "final_video_tab": " ",
        "upload_video_btn": "    ",
        "clip_table_headers": [
            "", " ", " ", " ", " ",
            " ", " ", "", " ", " ",
            " ", " ", " ", "", " ", " "
        ],
        "editable_field_tooltip": "  ",
        "readonly_field_tooltip": "  ",
        "bypass_mode_message": (
            "  ,         , "
            " //   \n"
            " '       '         \n"
            "    ,      '   '    \n"
            "     , -   OK   \n"
            ",         ' '      \n"
            "       OK   "
        ),
        "normal_mode_message": (
            "       :\n"
            "1. '     '  ,       / \n"
            "2. ,    '       '      "
            "'   :  '    \n"
            "    ,      '   '    \n"
            "     , -   OK   \n"
            ",         ' '      \n"
            "       OK   "
        ),
        "add_media_btn": " ",
        "add_music_btn": " ",
        "no_file_placeholder": "  ",
        "none_text": " ",
        # ToolTips
        "switch_account_tooltip": "   YouTube            ",
        "target_language_tooltip": "      ",
        "prompt_tooltip": (
            "           \n"
            " ,                \n"
            "        ;       \n"
            "               "
        ),
        "modify_tooltip": (
            "'' ()           ; ''    \n"
            "           ;     (  )    ,\n"
            "         \n"
            ":            ,            "
        ),
        "modify_yes_tooltip": ":        ",
        "modify_no_tooltip": ":          ",
        "bypass_tooltip": (
            " ''     ,  ,            \n"
            ":     \n"
            " '' ()     ,  ,       "
        ),
        "bypass_yes_tooltip": ": ,       ",
        "bypass_no_tooltip": ": ,     ",

        # Buttons
        "play_button": "",
        "pause_button": "",
        "forward_button": " (+10 )",
        "backward_button": " (-10 )",
        "browse_button": " ",

        # Window Titles
        "success_text": "",
        "video_preview_title": " : ",
        "music_preview_title": " : ",
        "voice_selector_title": " ",
        "upload_details_title": " ",
        "modify_keywords_title": "  ",

        # Progress Messages
        "uploading_video": "YouTube      ...   ",
        "uploading_thumbnail": "    ...   ",
        "generating_final_video": "     ...   ",
        "saving_subtitles": "      SRT     ",
        "replacing_media": "     ...   ",
        "deleting_clips": " ()    ...   ",
        "inserting_media": "     ...   ",
        "inserting_music": "     ...   ",
        "starting_video": "     ...   ",

        # Info Messages
        "upload_success": " YouTube     !",
        "upload_failure": "      ",
        "upload_cancelled": "      ",
        "subtitle_error": "       : ",
        "select_media_warning": "       ",
        "unsupported_file": "     ",
        "replace_media_error": "        : ",
        "no_items_selected": "    ,      ",
        "delete_error": "       : ",
        "insert_media_error": "       : ",
        "video_success_bypass": "     ( )",
        "video_success": "    ",
        "encoding_error": "       ",
        "review_content_title": " -  ",
        "title_required": "     ",
        "platform_required": "   ",
        "prompt_required": "      ",
        "video_not_found": "   : ",
        "playback_error": "      : ",
        "invalid_platform": "      ",

        # Status Messages
        "encoding_complete": "    ",
        "encoding_error_status": "       ",
        "general_error": "   : ",
        "playing_video": "   : ",
        "subtitles_saved": "       ...",
        "items_deleted": "     ",
        "no_media_found": "         ",
        "video_processing_error": "        : ",
        "image_processing_error": "        : ",
        "no_valid_clips": "        ",
        "invalid_voiceover": "        ",
        "no_music_files": "     ;             ",
        "review_aborted": "          ",
        "video_creation_started": "   ...",
        "creating_video": " -        : ",
        "video_in_progress": "  -        : ",
        "main_execution_error": "    : ",

        # Dialog Messages
        "enter_keywords": "   ,    :",
        "description_label": ":",
        "tags_label": " (  ):",
        "privacy_label": ":",
        "thumbnail_label": ":",
        "category_label": ":",
        "video_language_label": " :",
        "recording_date_label": " :",
        "switch_account_label": "YouTube  ",
        "select_thumbnail": " ",
        "image_files_filter": "  (*.png *.jpg *.jpeg)",
        "select_platform_title": " ",
        "select_platform_prompt": "    :",
        "loading_clips_message": "      ...   ",
        "moving_media_message": "     ...   ",
        "processing_subtitles_message": "    ...   ",
        "loading_title": "   ",
        "processing_title": "",
        "support_tab": "",
        "check_faq_label": "   FAQ :",
        "faq_link_text": "FAQ     ",
        "sr_number_label": "SR ",
        "customer_name_label": "  ",
        "email_label": "",
        "phone_label": "",
        "ticket_type_label": "  ",
        "issue_description_label": "  ",
        "video_name_label": "  ",
        "creation_dt_label": " / ()",
        "desc_label": "",
        "send_button": " ",
        "sr_sent_title": "  ",
        "sr_sent_msg": "      !"
    },
    # Korean
    "ko": {
        "missing_required_title": "  ",
        "missing_required_msg": "    :\n",
        "issue_option": "",
        "enh_option":   " ",
        "comment_option": "",
        "coming_soon_title":       "  ",
        "coming_soon_msg": (
            "{}    .\n\n"
            "   \n"
            " : {}"
        ),
        "youtube_shorts_reminder_title": "YouTube Shorts ",
        "youtube_shorts_reminder_msg": (
            ": YouTube Shorts 60    "
            " YouTube Shorts    "
        ),
        "file_not_found_title":    " :    ",
        "file_not_found_msg": (
            "{}       "
            "     "
            "   "
        ),
        "yes": "",
        "no": "",
        "video": "",
        "image": "",
        "info": "",
        "switch_account": " ",
        "main_tab_title": "",
        "target_language_label": " :",
        "voice_label": "  :",
        "video_title_label": " :",
        "platform_label": ":",
        "prompt_label": "    (  ):",
        "genre_label": "  :",
        "modify_label": " ?",
        "bypass_label": " ?",
        "status_label": ":",
        "save_subtitles_btn": "   ",
        "start_video_btn": "  ",
        "play_video_btn_final": " ",
        "replace_clip_btn": "  ",
        "delete_clip_btn": "  ",
        "base_directory_label": " :",
        "base_browse_btn": "",
        "video_image_folder_label": "  :",
        "output_directory_label": " :",
        "music_folder_label": " :",
        "voiceover_directory_label": " :",
        "review_script_tab": " /",
        "review_clips_tab": " /",
        "test_voice_button": " ",
        "generate_final_video_btn": "  ",
        "final_video_tab": " ",
        "upload_video_btn": "  ",
        "clip_table_headers": [
            "", "", " ", "", "",
            "", "", "", " ", " ",
            " ", " ", " ", "",
            " ", " "
        ],
        "editable_field_tooltip": "  ",
        "readonly_field_tooltip": "  ",
        "bypass_mode_message": (
            "     .\n"
            "' /'   .\n"
            "  '  '   '' "
            "' '   ."
        ),
        "normal_mode_message": (
            "  :\n"
            "1. ' /'   \n"
            "2. '   ' ' /'  \n"
            "  '  '   '' "
            "' '   ."
        ),
        "add_media_btn": " ",
        "add_music_btn": " ",
        "no_file_placeholder": " ",
        "none_text": "",
        "switch_account_tooltip": " YouTube   .",
        "target_language_tooltip": "    .",
        "prompt_tooltip": (
            "       .\n"
            " ,      .\n"
            "      ."
        ),
        "modify_tooltip": (
            " ''    , ''  .\n"
            "      ,      ."
        ),
        "modify_yes_tooltip": ":   ",
        "modify_no_tooltip": ":   ",
        "bypass_tooltip": (
            "''    \n"
            ":  \n"
            "''()   "
        ),
        "bypass_yes_tooltip": ":  ",
        "bypass_no_tooltip": ": ",
        "play_button": "",
        "pause_button": "",
        "forward_button": " (+10)",
        "backward_button": " (-10)",
        "browse_button": "",
        "success_text": "",
        "video_preview_title": " : ",
        "music_preview_title": " : ",
        "voice_selector_title": " ",
        "upload_details_title": " ",
        "modify_keywords_title": " ",
        "uploading_video": "YouTube   ...  .",
        "uploading_thumbnail": "  ...  .",
        "generating_final_video": "   ...  .",
        "saving_subtitles": "   SRT ",
        "replacing_media": "  ...  .",
        "deleting_clips": "  ...  .",
        "inserting_media": "  ...  .",
        "inserting_music": "  ...  .",
        "starting_video": "   ...  .",
        "upload_success": "  !",
        "upload_failure": "    .",
        "upload_cancelled": " .",
        "subtitle_error": "   : ",
        "select_media_warning": "  .",
        "unsupported_file": "   .",
        "replace_media_error": "   : ",
        "no_items_selected": "  .",
        "delete_error": "  : ",
        "insert_media_error": "   : ",
        "video_success_bypass": "    .",
        "video_success": "  .",
        "encoding_error": "   .",
        "review_content_title": " -  ",
        "title_required": " .",
        "platform_required": " .",
        "prompt_required": " .",
        "video_not_found": "   : ",
        "playback_error": "    : ",
        "invalid_platform": "   : ",
        "encoding_complete": " .",
        "encoding_error_status": "   .",
        "general_error": "  : ",
        "playing_video": "  : ",
        "subtitles_saved": "     ...",
        "items_deleted": "    .",
        "no_media_found": "     .",
        "video_processing_error": "    (): ",
        "image_processing_error": "    (): ",
        "no_valid_clips": "    .",
        "invalid_voiceover": "   . .",
        "no_music_files": "   ;   .",
        "review_aborted": " .   .",
        "video_creation_started": "  ...",
        "creating_video": " -   : ",
        "video_in_progress": "  -   : ",
        "main_execution_error": "    : ",
        "enter_keywords": "    :",
        "description_label": ":",
        "tags_label": " ( ):",
        "privacy_label": " :",
        "thumbnail_label": " :",
        "category_label": ":",
        "video_language_label": " :",
        "recording_date_label": " :",
        "switch_account_label": "YouTube  ",
        "select_thumbnail": " ",
        "image_files_filter": "  (*.png *.jpg *.jpeg)",
        "select_platform_title": " ",
        "select_platform_prompt": "   :",
        "loading_clips_message": "  ...  .",
        "moving_media_message": "   ...  .",
        "processing_subtitles_message": "  ...  .",
        "loading_title": " ",
        "processing_title": " ",
        "support_tab": "",
        "check_faq_label": "FAQ   :",
        "faq_link_text": "FAQ ",
        "sr_number_label": "SR ",
        "customer_name_label": " ",
        "email_label": "",
        "phone_label": "",
        "ticket_type_label": " ",
        "issue_description_label": " ",
        "video_name_label": " ",
        "creation_dt_label": " ()",
        "desc_label": "",
        "send_button": " ",
        "sr_sent_title": " ",
        "sr_sent_msg": "    !"
    },

    # Turkish
    "tr": {
        "missing_required_title": "Eksik Zorunlu Alanlar",
        "missing_required_msg": "Ltfen tm zorunlu alanlar doldurun:\n",
        "issue_option": "Sorun",
        "enh_option":   "Gelitirme",
        "comment_option": "Yorum",
        "coming_soon_title":       "Yaknda",
        "coming_soon_msg": (
            "{} iin entegrasyon yaknda geliyor\n\n"
            "Ltfen son videoyu manuel olarak ykleyin\n"
            "Video yolu: {}"
        ),
        "youtube_shorts_reminder_title": "YouTube Shorts Hatrlatmas",
        "youtube_shorts_reminder_msg": (
            "NOT: YouTube Shorts, 60 saniye veya daha ksa videolar iindir"
            "Ltfen videonuzun YouTube Shorts uzunluk gereksinimini karladndan emin olun"
        ),
        "file_not_found_title":    " UYARI: Dosya Bulunamad",
        "file_not_found_msg": (
            "{} iin son video dosyas bulunamad"
            "Belki bu platform iin oluturmadnz"
            "Ltfen oluturun ve tekrar deneyin"
        ),
        "yes": "Evet",
        "no": "Hayr",
        "video": "Video",
        "image": "Resim",
        "info": "Bilgi",
        "switch_account": "Hesap Deitir",
        "main_tab_title": "Ana",
        "target_language_label": "Hedef Dil:",
        "voice_label": "Anlatc Sesi Sein:",
        "video_title_label": "Video Bal:",
        "platform_label": "Platform:",
        "prompt_label": "Video ierii iin komut girin (her dilde):",
        "genre_label": "Enstrmantal Tr Sein:",
        "modify_label": "Anahtar Kelimeleri Deitir?",
        "bypass_label": "Metin, Altyaz, Seslendir. Atla?",
        "status_label": "Durum:",
        "save_subtitles_btn": "Altyaz Kaydet ve Yeniden Olutur",
        "start_video_btn": "Video Oluturmaya Bala",
        "play_video_btn_final": "Videoyu Oynat",
        "replace_clip_btn": "Seili Klipi Deitir",
        "delete_clip_btn": "Seili Klipleri Sil",
        "base_directory_label": "Temel Dizin:",
        "base_browse_btn": "Gzat",
        "video_image_folder_label": "Video Resim Klasr:",
        "output_directory_label": "kt Dizini:",
        "music_folder_label": "Mzik Klasr:",
        "voiceover_directory_label": "Seslendirme Dizini:",
        "review_script_tab": "Metni ncele/Dzenle",
        "review_clips_tab": "Klip & Altyaz ncele/Dzenle",
        "test_voice_button": "Sesi Test Et",
        "generate_final_video_btn": "Son Videoyu Olutur",
        "final_video_tab": "Son Video",
        "upload_video_btn": "Sosyal Medyaya Ykle",
        "clip_table_headers": [
            "Se", "nizleme", "Tr", "Dosya", "Sre",
            "Ba", "Bitir", "Se", "Mzik nizleme", "Mzik Dosya",
            "Mzik Sre", "Mzik Ba", "Mzik Biti", "Altyaz",
            "Altyaz Ba", "Altyaz Bit"
        ],
        "editable_field_tooltip": "Dzenlenebilir alan",
        "readonly_field_tooltip": "Salt okunur alan",
        "bypass_mode_message": (
            "Atla modu seildi; metin, altyaz, seslendirme oluturulmad.\n"
            "'Klip & Altyaz ncele/Dzenle' sekmesinde medya inceleyin.\n"
            "nceleme bitince 'Son Videoyu Olutur' butonuna tklayn.\n"
            "Oluturma tamamlannca uyarda Tamama basn."
        ),
        "normal_mode_message": (
            "Oluturulan ierii inceleyin:\n"
            "1. 'Metni ncele/Dzenle' sekmesinde metni gzden geirin.\n"
            "2. 'Altyaz Kaydet ve Yeniden Olutur' tklayn  'Klip & Altyaz ncele/Dzenle' sekmesine gei.\n"
            "nceleme bitince 'Son Videoyu Olutur' tklayn  uyarda Tamama tklayn."
        ),
        "add_media_btn": "Medya Ekle",
        "add_music_btn": "Mzik Ekle",
        "no_file_placeholder": "Dosya yok",
        "none_text": "Yok",
        "switch_account_tooltip": "Baka YouTube hesabyla giri yapmak iin iaretleyin.",
        "target_language_tooltip": "Arayz evirisi iin hedef dili sein.",
        "prompt_tooltip": (
            "Oluturmak istediiniz video ieriini ayrntl ekilde tanmlayn.\n"
            "Temel konular, stil ve gerekli tm ayrntlar ekleyin.\n"
            "Herhangi bir dilde yazabilirsiniz; video seilen dilde retilir."
        ),
        "modify_tooltip": (
            "'Evet' (varsaylan) anahtar kelimeleri dzenlemeye izin verir;\n"
            "'Hayr' orijinal kelimeleri korur.\n"
            "Daha fazla kelime, daha fazla medya getirir; daha z kelimeler daha ilgili ierik retir."
        ),
        "modify_yes_tooltip": "Evet: Dzenleme izin ver",
        "modify_no_tooltip": "Hayr: Orijinal kullan",
        "bypass_tooltip": (
            "'Evet' text, altyaz, ses oluturmay atlar.\n"
            "rnek: meditasyon videolar.\n"
            "'Hayr'(varsaylan) hepsi oluturulur."
        ),
        "bypass_yes_tooltip": "Evet: Atla",
        "bypass_no_tooltip": "Hayr: Olutur",
        "play_button": "Oynat",
        "pause_button": "Duraklat",
        "forward_button": "leri (+10 sn)",
        "backward_button": "Geri (-10 sn)",
        "browse_button": "Gzat",
        "success_text": "Baar",
        "video_preview_title": "Video nizleme: ",
        "music_preview_title": "Mzik nizleme: ",
        "voice_selector_title": "Ses Seici",
        "upload_details_title": "Ykleme Detaylar",
        "modify_keywords_title": "Anahtar Kelimeleri Dzenle",
        "uploading_video": "YouTubea video ykleniyor... Ltfen bekleyin.",
        "uploading_thumbnail": "Thumbnail ykleniyor... Ltfen bekleyin.",
        "generating_final_video": "Son video oluturuluyor... Ltfen bekleyin.",
        "saving_subtitles": "Altyazlar kaydediliyor ve SRT yeniden oluturuluyor",
        "replacing_media": "Medya deitiriliyor... Ltfen bekleyin.",
        "deleting_clips": "Klipler siliniyor... Ltfen bekleyin.",
        "inserting_media": "Yeni medya ekleniyor... Ltfen bekleyin.",
        "inserting_music": "Yeni mzik ekleniyor... Ltfen bekleyin.",
        "starting_video": "Video oluturma balatlyor... Ltfen bekleyin.",
        "upload_success": " Ykleme baarl!",
        "upload_failure": " Ykleme srasnda hata olutu.",
        "upload_cancelled": "Ykleme iptal edildi.",
        "subtitle_error": " Altyaz ileme hatas: ",
        "select_media_warning": "Ltfen bir medya sein.",
        "unsupported_file": "Desteklenmeyen dosya tr.",
        "replace_media_error": " Medya deitirme hatas: ",
        "no_items_selected": "Silinecek e yok.",
        "delete_error": " Silme hatas: ",
        "insert_media_error": " Medya ekleme hatas: ",
        "video_success_bypass": "Atla modunda video baaryla oluturuldu.",
        "video_success": "Video baaryla oluturuldu.",
        "encoding_error": " Ayr ilemde kodlama hatas.",
        "review_content_title": "Bilgi - erii ncele",
        "title_required": "Ltfen bir balk girin.",
        "platform_required": "Ltfen bir platform sein.",
        "prompt_required": "Ltfen bir video komutu girin.",
        "video_not_found": "Video bulunamad: ",
        "playback_error": " Oynatma hatas: ",
        "invalid_platform": " Geersiz platform ayar: ",
        "encoding_complete": "Video kodlama baaryla tamamland.",
        "encoding_error_status": " Kodlama hatas olutu.",
        "general_error": " Bir hata olutu: ",
        "playing_video": "Video oynatlyor: ",
        "subtitles_saved": "Altyazlar kaydedildi, seslendirme oluturuluyor...",
        "items_deleted": " Seili eler silindi.",
        "no_media_found": "  iinde medya bulunamad",
        "video_processing_error": " Video ileme hatas (): ",
        "image_processing_error": " Resim ileme hatas (): ",
        "no_valid_clips": " Geerli klip yok.",
        "invalid_voiceover": " Geersiz ses uzunluu. ptal ediliyor.",
        "no_music_files": " Mzik dosyas bulunamad; bo liste ayarland.",
        "review_aborted": "nceleme iptal edildi. Video oluturma durduruldu.",
        "video_creation_started": "Video oluturma balad...",
        "creating_video": "Balatlyor  Video oluturuluyor: ",
        "video_in_progress": "Devam ediyor  Video oluturuluyor: ",
        "main_execution_error": " Ana yrtmede hata: ",
        "enter_keywords": "Yeni anahtar kelimeleri virglle ayrarak girin:",
        "description_label": "Aklama:",
        "tags_label": "Etiketler (virglle):",
        "privacy_label": "Gizlilik:",
        "thumbnail_label": "Thumbnail Resim:",
        "category_label": "Kategori:",
        "video_language_label": "Video Dili:",
        "recording_date_label": "Kayt Tarihi:",
        "switch_account_label": "YouTube Hesab Deitir",
        "select_thumbnail": "Thumbnail Se",
        "image_files_filter": "Resim Dosyalar (*.png *.jpg *.jpeg)",
        "select_platform_title": "Platform Se",
        "select_platform_prompt": "Sosyal medya platformu sein:",
        "loading_clips_message": "Klip & altyazlar ykleniyor... Ltfen bekleyin.",
        "moving_media_message": "Medya klibi tanyor... Ltfen bekleyin.",
        "processing_subtitles_message": "Altyazlar ileniyor... Ltfen bekleyin.",
        "loading_title": "Ykleniyor",
        "processing_title": "leniyor",
        "support_tab": "Destek",
        "check_faq_label": "Ltfen nce SSS sayfamza bakn:",
        "faq_link_text": "SSS iin buraya tklayn",
        "sr_number_label": "SR Numaras",
        "customer_name_label": "Mteri Ad",
        "email_label": "E-posta",
        "phone_label": "Telefon",
        "ticket_type_label": "Talep Tr",
        "issue_description_label": "Sorunun Aklamas",
        "video_name_label": "Video Ad",
        "creation_dt_label": "Oluturma Tarihi/Saati (tahmini)",
        "desc_label": "Aklama",
        "send_button": "Talebi Gnder",
        "sr_sent_title": "Talep Gnderildi",
        "sr_sent_msg": "Destek talebiniz baaryla gnderildi!"

    },

    # Urdu
    "ur": {
        "missing_required_title": "   ",
        "missing_required_msg": "      :\n",
        "issue_option": "",
        "enh_option":   "",
        "comment_option": "",
        "coming_soon_title":       "  ",
        "coming_soon_msg": (
            "{}      \n\n"
            "          \n"
            "  : {}"
        ),
        "youtube_shorts_reminder_title": "YouTube Shorts  ",
        "youtube_shorts_reminder_msg": (
            ": YouTube Shorts 60          "
            "        YouTube Shorts       "
        ),
        "file_not_found_title":    " :   ",
        "file_not_found_msg": (
            "{}       "
            "                "
            "        "
        ),
        "yes": " ",
        "no": "",
        "video": "",
        "image": "",
        "info": "",
        "switch_account": "  ",
        "main_tab_title": "",
        "target_language_label": " :",
        "voice_label": "    :",
        "video_title_label": " :",
        "platform_label": " :",
        "prompt_label": "      (   ):",
        "genre_label": "   :",
        "modify_label": "   ",
        "bypass_label": "    ",
        "status_label": ":",
        "save_subtitles_btn": "      ",
        "start_video_btn": "   ",
        "play_video_btn_final": " ",
        "replace_clip_btn": "   ",
        "delete_clip_btn": "   ",
        "base_directory_label": " :",
        "base_browse_btn": " ",
        "video_image_folder_label": "  :",
        "output_directory_label": "  :",
        "music_folder_label": " :",
        "voiceover_directory_label": "  :",
        "review_script_tab": "  / ",
        "review_clips_tab": "   / ",
        "test_voice_button": " ",
        "generate_final_video_btn": "  ",
        "final_video_tab": " ",
        "upload_video_btn": "     ",
        "clip_table_headers": [
            " ", " ", "", "", "",
            "", "", " ", "  ",
            " ", " ", " ",
            " ", " ", "  ",
            "  "
        ],
        "editable_field_tooltip": "  ",
        "readonly_field_tooltip": "   ",
        "bypass_mode_message": (
            "          \n"
            "/ /    \n"
            "'  /'    \n"
            "   '  '      ' '  \n"
            "' '    "
        ),
        "normal_mode_message": (
            "       :\n"
            "1. ' /'   / \n"
            "2. '      '   '  /'   \n"
            "   '  '      ' ' ."
        ),
        "add_media_btn": "  ",
        "add_music_btn": "  ",
        "no_file_placeholder": "  ",
        "none_text": " ",
        "switch_account_tooltip": " YouTube         ",
        "target_language_tooltip": "       ",
        "prompt_tooltip": (
            "        \n"
            "        \n"
            "             "
        ),
        "modify_tooltip": (
            "'' ()        \n"
            "''      \n"
            "            "
        ),
        "modify_yes_tooltip": ":   ",
        "modify_no_tooltip": ":   ",
        "bypass_tooltip": (
            "''       \n"
            ":   .\n"
            "''()   ."
        ),
        "bypass_yes_tooltip": ":  ",
        "bypass_no_tooltip": ":  ",
        "play_button": "",
        "pause_button": "",
        "forward_button": " (+10 )",
        "backward_button": " (-10 )",
        "browse_button": " ",
        "success_text": "",
        "video_preview_title": "  : ",
        "music_preview_title": "  : ",
        "voice_selector_title": " ",
        "upload_details_title": "  ",
        "modify_keywords_title": "   ",
        "uploading_video": "     ...    ",
        "uploading_thumbnail": "      ...    ",
        "generating_final_video": "     ...    ",
        "saving_subtitles": "     SRT  ",
        "replacing_media": "      ...    ",
        "deleting_clips": "      ...    ",
        "inserting_media": "      ...    ",
        "inserting_music": "      ...    ",
        "starting_video": "     ...    ",
        "review_content_title": " -   ",
        "title_required": "      ",
        "platform_required": "      ",
        "prompt_required": "      ",
        "video_not_found": "   : ",
        "playback_error": "    : ",
        "invalid_platform": "     : ",
        "encoding_complete": "      ",
        "encoding_error_status": "      ",
        "general_error": "    : ",
        "playing_video": "   : ",
        "subtitles_saved": "           ",
        "items_deleted": "      ",
        "no_media_found": "       ",
        "video_processing_error": "      (): ",
        "image_processing_error": "      (): ",
        "no_valid_clips": "     ",
        "invalid_voiceover": "          ",
        "no_music_files": "           ",
        "review_aborted": "       ",
        "video_creation_started": "    ...",
        "creating_video": " -     : ",
        "video_in_progress": "  -     : ",
        "main_execution_error": "    : ",
        "enter_keywords": "         :",
        "description_label": ":",
        "tags_label": " (  ):",
        "privacy_label": ":",
        "thumbnail_label": "  :",
        "category_label": ":",
        "video_language_label": " :",
        "recording_date_label": "  :",
        "loading_clips_message": "       ...    ",
        "moving_media_message": "      ...    ",
        "processing_subtitles_message": "     ...    ",
        "loading_title": "   ",
        "processing_title": "  ",
        "support_tab": "",
        "check_faq_label": "    FAQ :",
        "faq_link_text": "FAQ     ",
        "sr_number_label": "SR ",
        "customer_name_label": "  ",
        "email_label": " ",
        "phone_label": "",
        "ticket_type_label": "  ",
        "issue_description_label": "  ",
        "video_name_label": "  ",
        "creation_dt_label": "  / ()",
        "desc_label": "",
        "send_button": " ",
        "sr_sent_title": "   ",
        "sr_sent_msg": "          !"
    },
    # Persian
    "fa": {
        "missing_required_title": "   ",
        "missing_required_msg": "      :\n",
        "issue_option": "",
        "enh_option":   "",
        "comment_option": "",
        "coming_soon_title": " ",
        "coming_soon_msg": (
            "  {}    .\n\n"
            "       .\n"
            " : {}"
        ),
        "youtube_shorts_reminder_title": " YouTube Shorts",
        "youtube_shorts_reminder_msg": (
            ": YouTube Shorts        . "
            "        YouTube Shorts  ."
        ),
        "file_not_found_title": " :   ",
        "file_not_found_msg": (
            "    {}  . "
            "       . "
            "          ."
        ),
        "yes": "",
        "no": "",
        "video": "",
        "image": "",
        "info": "",
        "switch_account": "  ",
        "main_tab_title": "",
        "target_language_label": " :",
        "voice_label": "    :",
        "video_title_label": " :",
        "platform_label": ":",
        "prompt_label": "  (Prompt)       (  ):",
        "genre_label": "     :",
        "modify_label": "     ",
        "bypass_label": "     ",
        "status_label": ":",
        "save_subtitles_btn": "   ",
        "start_video_btn": "  ",
        "play_video_btn_final": " ",
        "replace_clip_btn": "  ",
        "delete_clip_btn": " () ",
        "base_directory_label": " :",
        "base_browse_btn": "",
        "video_image_folder_label": "  :",
        "output_directory_label": " :",
        "music_folder_label": " :",
        "voiceover_directory_label": " :",
        "review_script_tab": "    ",
        "review_clips_tab": "     ",
        "test_voice_button": " ",
        "generate_final_video_btn": "  ",
        "final_video_tab": " ",
        "upload_video_btn": "   ",
        "clip_table_headers": [
            "", " ", " ", " ", " ",
            " ", " ", "", " ", " ",
            " ", " ", " ", "", " ", " "
        ],
        # Tooltips
        "editable_field_tooltip": "  ",
        "readonly_field_tooltip": "  ",
        "bypass_mode_message": (
            "             "
            "       .\n"
            "             .\n"
            "          .\n"
            "      OK     .\n"
            "             .\n"
            "     OK  ."
        ),
        "normal_mode_message": (
            "     :\n"
            ".              .\n"
            ".             "
            "      .\n"
            "              .\n"
            "         OK  .\n"
            "             .\n"
            "     OK  ."
        ),
        # Buttons
        "add_media_btn": " ",
        "add_music_btn": " ",
        # Placeholders
        "no_file_placeholder": " ",
        "none_text": "",
        # ToolTips
        "switch_account_tooltip": "             .",
        "target_language_tooltip": "        .",
        "prompt_tooltip": (
            "   (Prompt)         .\n"
            "              .\n"
            "              .\n"
            "            ."
        ),
        "modify_tooltip": (
            "  ()            "
            "      .\n"
            "          "
            "    (  )               .\n"
            ":                    ."
        ),
        "modify_yes_tooltip": ":     .",
        "modify_no_tooltip": ":      .",
        "bypass_tooltip": (
            "               .\n"
            ":    .\n"
            "  ()         ."
        ),
        "bypass_yes_tooltip": ":       .",
        "bypass_no_tooltip": ":     .",

        # Buttons
        "play_button": "",
        "pause_button": " ",
        "forward_button": " (+10 )",
        "backward_button": " (-10 )",
        "browse_button": "",

        # Window Titles
        "success_text": "",
        "video_preview_title": " : ",
        "music_preview_title": " : ",
        "voice_selector_title": " ",
        "upload_details_title": " ",
        "modify_keywords_title": "  ",

        # Progress Messages
        "uploading_video": "     ...   .",
        "uploading_thumbnail": "     ...   .",
        "generating_final_video": "    ...   .",
        "saving_subtitles": "       SRT",
        "replacing_media": "    ...   .",
        "deleting_clips": "   () ...   .",
        "inserting_media": "    ...   .",
        "inserting_music": "    ...   .",
        "starting_video": "    ...   .",

        # Info Messages
        "upload_success": "       !",
        "upload_failure": "      .",
        "upload_cancelled": "    .",
        "subtitle_error": "      : ",
        "select_media_warning": "        .",
        "unsupported_file": "    .",
        "replace_media_error": "        : ",
        "no_items_selected": "         .",
        "delete_error": "    ()   : ",
        "insert_media_error": "        : ",
        "video_success_bypass": "      ( ).",
        "video_success": "     .",
        "encoding_error": "       .",
        "review_content_title": " -  ",
        "title_required": "      .",
        "platform_required": "    .",
        "prompt_required": "      .",
        "video_not_found": "   : ",
        "playback_error": "       : ",
        "invalid_platform": "     .",

        # Status Messages
        "encoding_complete": "      .",
        "encoding_error_status": "       .",
        "general_error": "     : ",
        "playing_video": "   : ",
        "subtitles_saved": "       ...",
        "items_deleted": "    .",
        "no_media_found": "         : ",
        "video_processing_error": "     : ",
        "image_processing_error": "     : ",
        "no_valid_clips": "      .",
        "invalid_voiceover": "    .   .",
        "no_music_files": "         .",
        "review_aborted": "    .    .",
        "video_creation_started": "   ...",
        "creating_video": "      : ",
        "video_in_progress": "   -    : ",
        "main_execution_error": "    : ",

        # Dialog Messages
        "enter_keywords": "         :",
        "description_label": ":",
        "tags_label": " (   ):",
        "privacy_label": " :",
        "thumbnail_label": " :",
        "category_label": ":",
        "video_language_label": " :",
        "recording_date_label": " :",
        "switch_account_label": "  ",
        "select_thumbnail": "  ",
        "image_files_filter": "  (*.png *.jpg *.jpeg)",
        "select_platform_title": " ",
        "select_platform_prompt": "    :",
        "loading_clips_message": "     ...   .",
        "moving_media_message": "    ...   .",
        "processing_subtitles_message": "   ...   .",
        "loading_title": "  ",
        "processing_title": "  ",
        "support_tab": "",
        "check_faq_label": "       :",
        "faq_link_text": "  FAQ   ",
        "sr_number_label": " SR",
        "customer_name_label": " ",
        "email_label": "",
        "phone_label": "",
        "ticket_type_label": " ",
        "issue_description_label": " ",
        "video_name_label": " ",
        "creation_dt_label": "/  ()",
        "desc_label": "",
        "send_button": " ",
        "sr_sent_title": "  ",
        "sr_sent_msg": "      !"
    }
}


def get_texts_for_current_language(combo_box=None, auto_translate=False):

    """
    combo_box: QComboBox, any QWidget in your UI, or a bare 2-letter str
    auto_translate: if True, will call translate_text() to fill gaps
    """
    # 1) DERIVE TWO-LETTER LANG CODE
    if isinstance(combo_box, str):
        # caller already passed "es", "ar", etc.
        lang = combo_box.lower()

    elif combo_box is None:
        # no selector  default to English
        lang = "en"

    else:
        # 1A) try direct API on whatever was passed in
        lang = None
        try:
            maybe = combo_box.currentData() or combo_box.currentText()
            lang = maybe
        except Exception:
            try:
                lang = combo_box.text()
            except Exception:
                lang = None

        # 1B) if that failed, climb widget parents and look for your language combo

        if not lang or not isinstance(lang, str):
            w = combo_box
            combo = None
            while w is not None:
                # adjust "languageCombo" to your actual objectName
                combo = w.findChild(QComboBox, "languageCombo")
                if combo:
                    break
                # move up
                w = w.parentWidget() if isinstance(w, QWidget) else None

            if combo:
                try:
                    lang = combo.currentData() or combo.currentText()
                except Exception:
                    lang = None

        # normalize
        lang = (lang or "en").lower()


    # 2) ENGLISH? immediate return

    if lang == "en":
        return DEFAULT_STRINGS

    # 3) HARDCODED DICT?
    if lang in HARDCODED_TRANSLATIONS:
        return HARDCODED_TRANSLATIONS[lang]

    # 4) AUTO-TRANSLATE ON DEMAND?

    if auto_translate:
        out = {}
        for key, default in DEFAULT_STRINGS.items():
            try:
                out[key] = translate_text(default, lang, "en")
            except Exception:
                out[key] = default
        return out

    # 5) FALLBACK  English
    return DEFAULT_STRINGS



class TooltipTranslator(QObject):
    def __init__(self, lang_combo):
        super().__init__()
        self.lang_combo = lang_combo

    def eventFilter(self, watched, event):
        if event.type() == QEvent.ToolTip:
            orig = watched.toolTip()
            # look up the English  key mapping
            key = REVERSE_DEFAULTS.get(orig)
            if not key:
                # no translation for this text? let Qt do its default thing
                return False

            # we *do* have a key, so swap in the translated string
            texts = get_texts_for_current_language(self.lang_combo)
            translated = texts.get(key, orig)
            QToolTip.showText(event.globalPos(), translated, watched)
            # we handled it
            return True

        return super().eventFilter(watched, event)



# from your_i18n_module import get_texts_for_current_language, DEFAULT_STRINGS

class UploadDialog(QDialog):
    def __init__(self,
                 default_description="",
                 default_tags=None,
                 default_privacy="private",
                 default_thumbnail="",
                 parent=None):
        super().__init__(parent)

        # 1) pull translations from the main windows language selector
        combo = getattr(parent, "target_language_input", None)
        texts = get_texts_for_current_language(combo)

        # 2) remember lastused thumbnail folder
        self.last_thumbnail_path = default_thumbnail or ""

        # 3) window title
        self.setWindowTitle(
            texts.get("upload_details_title",
                      DEFAULT_STRINGS["upload_details_title"])
        )

        # 4) form layout
        layout = QFormLayout(self)

        #  Description 
        self.description_edit = QPlainTextEdit(self)
        self.description_edit.setPlainText(default_description)
        layout.addRow(
            texts.get("description_label", "Description:"),
            self.description_edit
        )

        #  Tags 
        self.tags_edit = QLineEdit(self)
        self.tags_edit.setMaxLength(500)
        default_tags = default_tags or []
        self.tags_edit.setText(", ".join(default_tags))
        layout.addRow(
            texts.get("tags_label", "Tags (comma separated):"),
            self.tags_edit
        )

        #  Privacy 
        self.privacy_combo = QComboBox(self)
        self.privacy_combo.addItems(["private", "public"])
        idx = self.privacy_combo.findText(default_privacy)
        if idx != -1:
            self.privacy_combo.setCurrentIndex(idx)
        layout.addRow(
            texts.get("privacy_label", "Privacy:"),
            self.privacy_combo
        )

        #  Thumbnail + Browse button 
        self.thumbnail_edit = QLineEdit(self)
        self.thumbnail_edit.setText(default_thumbnail)
        browse_btn = QPushButton(
            texts.get("browse_button", "Browse"), self
        )
        browse_btn.clicked.connect(self.browse_thumbnail)

        thumb_hbox = QHBoxLayout()
        thumb_hbox.addWidget(self.thumbnail_edit)
        thumb_hbox.addWidget(browse_btn)
        layout.addRow(
            texts.get("thumbnail_label", "Thumbnail Image:"),
            thumb_hbox
        )

        #  Category 
        self.category_combo = QComboBox(self)
        #----------------------------
        # Add (visible text, category ID) pairs
        self.category_combo.addItem("Autos & Vehicles", 2)
        self.category_combo.addItem("Comedy", 23)
        self.category_combo.addItem("Education", 27)
        self.category_combo.addItem("Entertainment", 24)
        self.category_combo.addItem("Film & Animation", 1)
        self.category_combo.addItem("Gaming", 20)
        self.category_combo.addItem("Howto & Style", 26)
        self.category_combo.addItem("Music", 10)
        self.category_combo.addItem("News & Politics", 25)
        self.category_combo.addItem("Nonprofits & Activism", 29)
        self.category_combo.addItem("People & Blogs", 22)
        self.category_combo.addItem("Pets & Animals", 15)
        self.category_combo.addItem("Science & Technology", 28)
        self.category_combo.addItem("Sports", 17)
        self.category_combo.addItem("Travel & Events", 19)

        #layout.addRow("Category:", self.category_combo)

        layout.addRow(
            texts.get("category_label", "Category:"),
            self.category_combo
        )

        # Retrieve the integer category ID

        index = self.category_combo.currentIndex()
        category_id = self.category_combo.itemData(index)  # will be an int

        #-------------------------------
        #  Video Language 
        self.language_combo = QComboBox(self)
        self.language_combo.addItems(
            ["en", "es", "ar", "pt", "hi", "de", "zh", "jp", "fr", "ru", "ko", "tr", "ur", "fa"]
        )
        self.language_combo.setCurrentText("en")
        layout.addRow(
            texts.get("video_language_label", "Video Language:"),
            self.language_combo
        )

        #  Recording Date 
        self.recording_date_edit = QDateEdit(self)
        self.recording_date_edit.setCalendarPopup(True)
        self.recording_date_edit.setDate(QDate.currentDate())
        layout.addRow(
            texts.get("recording_date_label", "Recording Date:"),
            self.recording_date_edit
        )

        #  Switch YouTube Account 
        self.switch_account_checkbox = QCheckBox(
            texts.get("switch_account_label", "Switch YouTube Account"),
            self
        )
        self.switch_account_checkbox.setToolTip(
            texts.get("switch_account_tooltip",
                      DEFAULT_STRINGS["switch_account_tooltip"])
        )
        layout.addRow(
            texts.get("switch_account", DEFAULT_STRINGS["switch_account"]),
            self.switch_account_checkbox
        )

        #  OK / Cancel buttons 
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel, parent=self
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

        print("DEBUG: UploadDialog initialized successfully.")

    def browse_thumbnail(self):
        """
        Open a file dialog for images, remember last folder,
        and set thumbnail_edit.
        """
        combo = getattr(self.parent(), "target_language_input", None)
        texts = get_texts_for_current_language(combo)

        start_dir = (
            self.last_thumbnail_path
            or QStandardPaths.writableLocation(QStandardPaths.DesktopLocation)
        )

        file_path, _ = QFileDialog.getOpenFileName(
            self,
            texts.get("select_thumbnail",
                      DEFAULT_STRINGS["select_thumbnail"]),
            start_dir,
            texts.get("image_files_filter",
                      DEFAULT_STRINGS["image_files_filter"])
        )
        if not file_path:
            return

        # remember for next time
        self.last_thumbnail_path = file_path
        self.thumbnail_edit.setText(file_path)

    def getData(self):
        """
        Returns:
          (description: str,
           tags: [str],
           privacy: str,
           thumbnail: str,
           categoryId: str,
           language: str,
           recording_date: str,
           switch_account: bool)
        """
        import re

        description = self.description_edit.toPlainText().strip()
        tags = [
            t.strip()
            for t in self.tags_edit.text().split(",")
            if t.strip()
        ]
        privacy = self.privacy_combo.currentText()
        thumbnail = self.thumbnail_edit.text().strip()

        # Retrieve categoryId directly from the combo item's userData
        idx = self.category_combo.currentIndex()
        categoryId = str(self.category_combo.itemData(idx))  # Convert to string if needed

        language = self.language_combo.currentText()
        recording_date = self.recording_date_edit.date().toString("yyyy-MM-dd")
        switch_account = self.switch_account_checkbox.isChecked()

        print("DEBUG: UploadDialog.getData returning:")
        print("    description:", repr(description))
        print("    tags:", repr(tags))
        print("    privacy:", repr(privacy))
        print("    thumbnail:", repr(thumbnail))
        print("    categoryId:", repr(categoryId))
        print("    language:", repr(language))
        print("    recording date:", repr(recording_date))
        print("    switchAccount:", repr(switch_account))

        return (
            description,
            tags,
            privacy,
            thumbnail,
            categoryId,
            language,
            recording_date,
            switch_account
        )


def choose_social_media_platform(parent):

    #texts = get_texts_for_current_language(self.target_language_input)
    texts = get_texts_for_current_language(parent.target_language_input)
    # Define a list of platforms; you may add more later.
    platforms = ["YouTube", "Youtube_Shorts", "Instagram", "TikTok", "Facebook", "720p"]

    print("DEBUG: Presenting social media platform choices:", platforms)
    # Use QInputDialog.getItem to prompt the user with a drop-down
    item, ok = QInputDialog.getItem(
        parent,
        parent.tr(texts.get("select_platform_title", DEFAULT_STRINGS["select_platform_title"])),
        parent.tr(texts.get("select_platform_prompt", DEFAULT_STRINGS["select_platform_prompt"])),
        platforms,
        0,  # default index
        False  # not editable
    )
    "select_platform_prompt"
    print("DEBUG: User selected:", repr(item), "OK =", ok)
    if ok and item:
        return item  # or item.lower() if you want a specific format later
    else:
        return None


def get_output_filename(title, platform, output_dir, ext=".mp4"):
    """
    Create a filename such as "Singing Birds_youtube.mp4".
    """
    return os.path.join(output_dir, f"{title}_{platform}{ext}")


def ensure_platform_file(title, desired_platform, output_dir):
    """
    Look for the desired platform file.
    If it doesn't exist, try to copy it from an allowed alternative platform:
     - For "facebook", only copy from "youtube" (if it exists)
     - For "youtube", only copy from "facebook"
     - For "youtube_shorts", copy from "tiktok" or "instagram"
     - For "tiktok", copy from "youtube_shorts" or "instagram"
     - For "instagram", copy from "youtube_shorts" or "tiktok"
    Returns the file path (existing or newly copied) or None if not found.
    """
    # Build the desired filename.
    desired_file = get_output_filename(title, desired_platform, output_dir)
    if os.path.exists(desired_file):
        print(f"[INFO] {desired_platform} file already exists: {desired_file}")
        return desired_file

    # Get alternative platforms based on our rules. If no rule is set, use an empty list.
    allowed_alternatives = ALTERNATIVE_PLATFORMS.get(desired_platform, [])

    for alt_platform in allowed_alternatives:
        alt_file = get_output_filename(title, alt_platform, output_dir)
        if os.path.exists(alt_file):
            try:
                shutil.copy(alt_file, desired_file)
                print(f"[INFO] Copied {alt_platform} file to {desired_platform}: {desired_file}")
                return desired_file
            except Exception as e:
                print(f"[ ERROR] Could not copy file from {alt_platform} to {desired_platform}: {e}")
                # If copying fails, you might choose to continue to the next alternative.
                continue

    print(f"[INFO] No allowed alternative file found for {desired_platform}.")
    return None


def safe_str(obj) -> str:
    """
    Safely convert obj to str. If obj has a callable .text() method (e.g., a QLineEdit),
    call that and convert to str. Otherwise, just return str(obj).
    """
    if isinstance(obj, str):
        return obj
    if hasattr(obj, 'text') and callable(obj.text):
        return str(obj.text())
    return str(obj)

def archive_subdirs(base_dir: str,
                    video_filename: str,
                    subdirs=("OutFiles", "InVidFiles", "InMusicFiles")) -> None:
    """
    Inside base_dir create   <video_filename>.<timestamp>
    and move the listed sub-directories there.
    """

    if not base_dir or not os.path.isdir(base_dir):
        print(f"  archive_subdirs: '{base_dir}' is not a valid directory.")
        return

    # sanitise the name: keep letters, digits, '_', '-'
    safe_name = re.sub(r"[^A-Za-z0-9_\-]", "", os.path.splitext(video_filename)[0]) or "untitled"
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")

    dest_dir = os.path.join(base_dir, f"{safe_name}.{timestamp}")
    try:
        os.makedirs(dest_dir, exist_ok=False)
    except FileExistsError:
        # extremely unlikely but still possible  back-off with counter
        i = 1
        while True:
            alt = f"{dest_dir}_{i}"
            try:
                os.makedirs(alt, exist_ok=False)
                dest_dir = alt
                break
            except FileExistsError:
                i += 1

    for sub in subdirs:
        src = os.path.join(base_dir, sub)
        if os.path.exists(src):
            try:
                shutil.move(src, dest_dir)
                print(f"   moved {src}    {dest_dir}")
            except Exception as e:
                print(f" could not move '{src}': {e}")
        else:
            print(f"   skipped {src} (does not exist)")

    print(f" Archiving complete.  Working dirs are now in\n   {dest_dir}")

class VideoCreatorGUI(QMainWindow):

    def __init__(self):
        super().__init__()
        self.texts = DEFAULT_STRINGS  # default
        self.last_output_path = ""
        self._player = QMediaPlayer()
        # make sure we clean up exactly once, even if other code also
        # connects to aboutToQuit  Qt will call all slots.
        QApplication.instance().aboutToQuit.connect(self.on_app_quit)
        self.uploading = False
        self.setWindowTitle("Video Creator")
        screen_rect = QApplication.primaryScreen().availableGeometry()

        # Calculate a size slightly smaller than the screen to ensure fit (e.g., 90% width and height)
        width = int(screen_rect.width() * 0.95)
        height = int(screen_rect.height() * 0.95)

        size = QSize(width, height)
        centered = QStyle.alignedRect(
            Qt.LeftToRight,
            Qt.AlignCenter,
            size,
            screen_rect
        )
        self.setGeometry(centered)

        self.resize(width, height)
        self.setMinimumWidth(int(width * 0.95))  # keep min width reasonable

        # Create a central tab widget.
        self.tabs = QTabWidget()

        bar = self.tabs.tabBar()
        bar.setElideMode(Qt.ElideNone)



        self.tabs.setStyleSheet("""
            /*  All tabs  */
            QTabBar::tab {
                background: #E0E0E0;
                color: #333;
                font-size: 11px;
                padding: 10px 16px;
                min-width: 145px;
                min-height: 12px;
                border: 1px solid #AAA;
                border-bottom: none;
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                margin-right: -1px;
                margin-bottom: 0px;
            }

            /*  Selected (active) tab  */
            QTabBar::tab:selected {
                background: #5d8aa8;
                color: white;
                font-size: 11px;
                padding: 10px 16px;
                min-width: 145px;
                min-height: 12px;
                border: 1px solid #AAA;
                border-color: #4a739b;
                border-bottom: 2px solid #4a739b;
                margin-top: 0px;
            }

            /*  Unselected candidates  */
            QTabBar::tab:!selected {
                margin-top: 2px;
            }

            /*  The content pane under the tabs  */
            QTabWidget::pane {
                border: 1px solid #AAA;
                top: -1px;
                padding: 12px;
            }
        """)

        # == Insert a top widget with a logo on the right ==
        self.top_widget = QWidget()
        top_layout = QHBoxLayout(self.top_widget)
        top_layout.setContentsMargins(0, 0, 0, 0)

        # (Optionally, something on the left or just a spacer)
        left_spacer = QLabel("")
        top_layout.addWidget(left_spacer)
        top_layout.addStretch(1)  # push the logo to the far right

        # Logo on the right
        self.logo_label = QLabel()
        pixmap = QPixmap(APP_LOGO)
        # Optionally scale the logo if needed:
        pixmap = pixmap.scaled(40, 40, Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.logo_label.setPixmap(pixmap)
        top_layout.addWidget(self.logo_label)

        #self.logo_label.setScaledContents(True)  # Let the label resize the image internally
        #self.logo_label.setFixedSize(120, 50)  # Force the QLabel to that size (or use setMaximumSize)

        # Now create a central widget that holds top_widget plus the tab widget.
        central_widget = QWidget(self)
        main_vlayout = QVBoxLayout(central_widget)
        main_vlayout.setContentsMargins(0, 0, 0, 0)
        # 1) Add the top widget (with the logo)
        main_vlayout.addWidget(self.top_widget)


        main_vlayout.addWidget(self.tabs)  # your QTabWidget
        # Finally, set the central_widget as the QMainWindows central widget
        self.setCentralWidget(central_widget)
        # SURGICAL FIX: Set the background color on the entire QMainWindow:
        self.setStyleSheet("QMainWindow { background-color: rgba(250,242,231,255); }")

        #self.setCentralWidget(self.tabs)
        self.status_text = QPlainTextEdit()
        self.status_text.setReadOnly(True)
        self.media_clips = []  # Initialize media_clips as an empty list
        #print("VideoCreatorGUI initialized with media_clips:", self.media_clips)

        # Add QLineEdit widgets for video & music folder references
        # so that calling .text() is valid in bypass mode
        #self.video_image_folder = QLineEdit(self)
        #self.music_folder = QLineEdit(self)

        # If you want them to start as empty strings, you can do so:
        #self.video_image_folder.setText("")
        #self.music_folder.setText("")

        #  inside your init/UI setup 

        # 1) Build your language list
        self.language_options = [
            {"label": "English    (Default)",   "code": "en", "flag": QIcon("flags/us.png")},
            {"label": "Arabic     ",     "code": "ar", "flag": QIcon("flags/sa.png")},
            {"label": "Spanish    Espaol",     "code": "es", "flag": QIcon("flags/es.png")},
            {"label": "Frensh     Franais",    "code": "fr", "flag": QIcon("flags/fr.png")},
            {"label": "German     Deutsch",     "code": "de", "flag": QIcon("flags/de.png")},
            {"label": "Portuguese Portugus",   "code": "pt", "flag": QIcon("flags/pt.png")},
            {"label": "Russian    ",     "code": "ru", "flag": QIcon("flags/ru.png")},
            {"label": "Chinese    ",         "code": "zh", "flag": QIcon("flags/cn.png")},
            {"label": "Japanese   ",       "code": "ja", "flag": QIcon("flags/jp.png")},
            {"label": "Hindi      ",         "code": "hi", "flag": QIcon("flags/in.png")},
            {"label": "Korean     ",       "code": "ko", "flag": QIcon("flags/kr.png")},
            {"label": "Turkish    Trke",      "code": "tr", "flag": QIcon("flags/tr.png")},
            {"label": "Urdu       ",        "code": "ur", "flag": QIcon("flags/pk.png")},
            {"label": "Persian    ",       "code": "fa", "flag": QIcon("flags/ir.png")}
        ]

        # 2) Create the combo box
        self.target_language_input = QComboBox()
        self.target_language_input.setIconSize(QSize(26, 26))
        self.target_language_input.setMaxVisibleItems(len(self.language_options))
        self.target_language_input.setFixedHeight(30)
        self.target_language_input.setStyleSheet(
            "QComboBox { font-size: 11px; padding: 1px 4px; }"
            "QComboBox QAbstractItemView { font-size: 11px; }"
        )

        # Populate the combo box
        self.target_language_input.clear()
        for lang in self.language_options:
            self.target_language_input.addItem(
                lang["flag"],
                lang["label"],
                userData=lang["code"]
            )

        #  continue adding your other widgets to self.main_layout 
        self._tt_translator = TooltipTranslator(self.target_language_input)
        QApplication.instance().installEventFilter(self._tt_translator)

        # -------------------- First Tab: Main Controls --------------------
        # Main tab.
        self.main_tab = QWidget()
        self.main_tab.setProperty("tabFunction", "main")
        self.tabs.addTab(self.main_tab, "Main")
        main_layout = QVBoxLayout()
        self.main_tab.setLayout(main_layout)

        language_layout = QHBoxLayout()
        self.target_language_label_widget = QLabel(DEFAULT_STRINGS["target_language_label"])


        language_layout.addWidget(self.target_language_label_widget)
        language_layout.addWidget(self.target_language_input)
        main_layout.addLayout(language_layout)

        # Get the language code from the combo box's userData instead of using self.target_languages.
        target_lang = self.target_language_input.currentData() or "en"

        # print(f"DEBUG: Inside Main tab. target_lang: {target_lang}")

        texts = get_texts_for_current_language(self.target_language_input)

        self.target_language_label_widget.setToolTip(
            texts.get("target_language_tooltip", DEFAULT_STRINGS["target_language_tooltip"]))
        # Voice selection row.
        voice_layout = QHBoxLayout()
        self.voice_label = QLabel(DEFAULT_STRINGS["voice_label"])
        self.video_title_label = QLabel(DEFAULT_STRINGS["video_title_label"])
        self.voice_selector = VoiceSelector()
        self.voice_input = self.voice_selector.voice_input
        voice_layout.addWidget(self.voice_label)
        voice_layout.addWidget(self.voice_input)
        self.test_voice_button = QPushButton(DEFAULT_STRINGS["test_voice_button"])
        self.test_voice_button.setStyleSheet(BTN_STYLE)

        self.test_voice_button.clicked.connect(self.voice_selector.test_selected_voice)
        voice_layout.addWidget(self.test_voice_button)
        main_layout.addLayout(voice_layout)


        # Video title input.
        self.video_title_label = QLabel(DEFAULT_STRINGS["video_title_label"])
        self.video_title_input = QLineEdit()
        main_layout.addWidget(self.video_title_label)
        main_layout.addWidget(self.video_title_input)

        # Default value for video_title
        self.video_title = "default_video"

        # Connect the textChanged signal to your new set_video_title method
        self.video_title_input.textChanged.connect(self.set_video_title)

        # Platform input.
        self.platform_label = QLabel(DEFAULT_STRINGS["platform_label"])
        self.platform_input = QComboBox()
        self.platform_input.addItems(["youtube", "youtube_shorts", "tiktok", "facebook", "instagram", "720p"])
        main_layout.addWidget(self.platform_label)
        main_layout.addWidget(self.platform_input)

        # Video script prompt input.
        prompt_container = QWidget()
        prompt_layout = QHBoxLayout(prompt_container)
        prompt_layout.setSpacing(3)
        prompt_layout.setContentsMargins(0, 0, 0, 0)
        prompt_layout.setSizeConstraint(QLayout.SetFixedSize)

        self.prompt_label = QLabel(DEFAULT_STRINGS["prompt_label"])
        prompt_layout.addWidget(self.prompt_label)
        prompt_info = QToolButton()
        prompt_info.setIcon(QApplication.style().standardIcon(QStyle.SP_MessageBoxInformation))
        prompt_info.setAutoRaise(True)
        #prompt_info.setToolTip(
        #    "Provide a comprehensive prompt describing the video content you wish to create.\n"
        #    "Include key topics, desired style, and all essential details to guide the video generation process.\n"
        #    "You may write the prompt in any language; the video will be produced in the language selected.\n"
        #    "The generated output will form a video script that you can review later."
        #)
        #global target_lang
        target_lang = self.target_language_input.currentData() or "en"

        #print(f"DEBUG: Inside Main tab. target_lang: {target_lang}")

        texts = get_texts_for_current_language(self.target_language_input)

        prompt_info.setToolTip(texts.get("prompt_tooltip", DEFAULT_STRINGS["prompt_tooltip"]))
        prompt_layout.addWidget(prompt_info)
        main_layout.addWidget(prompt_container)
        self.prompt_input = QPlainTextEdit()
        self.prompt_input.setFixedHeight(50)  # Adjust value as needed (e.g., 100 pixels)
        main_layout.addWidget(self.prompt_input)

        # Instrumental Genre selection.
        genre_layout = QHBoxLayout()
        self.genre_label = QLabel(DEFAULT_STRINGS["genre_label"])
        self.genre_input = QComboBox()
        self.genre_input.addItems(["Ambient", "Classical", "Electronic", "Folk", "Jazz", "Lo-fi",
                                   "New Age", "Post-Rock", "Soundtrack", "World Music"])
        default_genre = "Soundtrack"
        default_genre_index = self.genre_input.findText(default_genre)
        if default_genre_index >= 0:
            self.genre_input.setCurrentIndex(default_genre_index)
        genre_layout.addWidget(self.genre_label)
        genre_layout.addWidget(self.genre_input)
        main_layout.addLayout(genre_layout)

        # Modify Keywords container.
        modify_container = QWidget()
        modify_layout = QHBoxLayout(modify_container)
        modify_layout.setSpacing(3)
        modify_layout.setContentsMargins(0, 0, 0, 0)
        modify_layout.setSizeConstraint(QLayout.SetFixedSize)
        self.modify_label = QLabel(texts.get("modify_label", DEFAULT_STRINGS["modify_label"]))

        modify_layout.addWidget(self.modify_label)
        modify_info = QToolButton()
        modify_info.setIcon(QApplication.style().standardIcon(QStyle.SP_MessageBoxInformation))
        modify_info.setAutoRaise(True)
        modify_info.setToolTip(texts.get("modify_tooltip", DEFAULT_STRINGS["modify_tooltip"]))
        modify_layout.addWidget(modify_info)

        self.modify_yes = QRadioButton(texts.get("yes", DEFAULT_STRINGS["yes"]))
        self.modify_yes.setToolTip(texts.get("modify_yes_tooltip", DEFAULT_STRINGS["modify_yes_tooltip"]))
        self.modify_no = QRadioButton(texts.get("no", DEFAULT_STRINGS["no"]))
        self.modify_no.setToolTip(texts.get("modify_no_tooltip", DEFAULT_STRINGS["modify_no_tooltip"]))
        self.modify_yes.setChecked(True)
        self.modify_group = QButtonGroup()
        self.modify_group.addButton(self.modify_yes)
        self.modify_group.addButton(self.modify_no)

        modify_layout.addWidget(self.modify_yes)
        modify_layout.addWidget(self.modify_no)

        main_layout.addWidget(modify_container)

        # Bypass container.
        bypass_container = QWidget()
        bypass_layout = QHBoxLayout(bypass_container)
        bypass_layout.setSpacing(3)
        bypass_layout.setContentsMargins(0, 0, 0, 0)
        bypass_layout.setSizeConstraint(QLayout.SetFixedSize)

        self.bypass_label = QLabel(DEFAULT_STRINGS["bypass_label"])
        bypass_layout.addWidget(self.bypass_label)

        bypass_info = QToolButton()
        bypass_info.setIcon(QApplication.style().standardIcon(QStyle.SP_MessageBoxInformation))
        bypass_info.setAutoRaise(True)
        bypass_info.setToolTip(texts.get("bypass_tooltip", DEFAULT_STRINGS["bypass_tooltip"]))
        bypass_layout.addWidget(bypass_info)

        self.bypass_yes = QRadioButton(texts.get("yes", DEFAULT_STRINGS["yes"]))
        self.bypass_yes.setToolTip(texts.get("bypass_yes_tooltip", DEFAULT_STRINGS["bypass_yes_tooltip"]))
        self.bypass_no = QRadioButton(texts.get("no", DEFAULT_STRINGS["no"]))
        self.bypass_no.setToolTip(texts.get("bypass_no_tooltip", DEFAULT_STRINGS["bypass_no_tooltip"]))
        self.bypass_no.setChecked(True)
        self.bypass_group = QButtonGroup()
        self.bypass_group.addButton(self.bypass_yes)
        self.bypass_group.addButton(self.bypass_no)

        bypass_layout.addWidget(self.bypass_yes)
        bypass_layout.addWidget(self.bypass_no)

        main_layout.addWidget(bypass_container)

        # Directories Section
        self.directories_layout = QGridLayout()
        main_layout.addLayout(self.directories_layout)

        # Base Directory Row:
        self.base_directory_label = QLabel(DEFAULT_STRINGS["base_directory_label"])
        self.base_directory = QLineEdit()
        self.base_browse_button = QPushButton(DEFAULT_STRINGS["base_browse_btn"])
        self.base_browse_button.setStyleSheet(BTN_STYLE)
        self.base_browse_button.clicked.connect(self.browse_base_directory)
        # Place label in column 0, line edit in column 1, and Browse button in column 2.
        self.directories_layout.addWidget(self.base_directory_label, 0, 0)
        self.directories_layout.addWidget(self.base_directory, 0, 1)
        self.directories_layout.addWidget(self.base_browse_button, 0, 2)

        # Video Image Folder Row.
        self.video_image_folder_label = QLabel(DEFAULT_STRINGS["video_image_folder_label"])
        self.video_image_folder = QLineEdit()
        self.video_image_folder.setReadOnly(True)
        self.directories_layout.addWidget(self.video_image_folder_label, 1, 0)
        self.directories_layout.addWidget(self.video_image_folder, 1, 1)

        # Output Directory Row.
        self.output_directory_label = QLabel(DEFAULT_STRINGS["output_directory_label"])
        self.output_directory = QLineEdit()
        self.output_directory.setReadOnly(True)
        self.directories_layout.addWidget(self.output_directory_label, 2, 0)
        self.directories_layout.addWidget(self.output_directory, 2, 1)

        #self.output_directory_path = self.output_directory.text().strip()

        # Music Folder Row.
        self.music_folder_label = QLabel(DEFAULT_STRINGS["music_folder_label"])
        self.music_folder = QLineEdit()
        self.music_folder.setReadOnly(True)
        self.directories_layout.addWidget(self.music_folder_label, 3, 0)
        self.directories_layout.addWidget(self.music_folder, 3, 1)

        # Voiceover Directory Row.
        self.voiceover_directory_label = QLabel(DEFAULT_STRINGS["voiceover_directory_label"])
        self.voiceover_directory = QLineEdit()
        self.voiceover_directory.setReadOnly(True)
        self.directories_layout.addWidget(self.voiceover_directory_label, 4, 0)
        self.directories_layout.addWidget(self.voiceover_directory, 4, 1)

        self.base_directory.textChanged.connect(self.update_derived_directories)

        # Status Section.
        self.status_label = QLabel(DEFAULT_STRINGS["status_label"])
        main_layout.addWidget(self.status_label)
        self.status_text = QPlainTextEdit()
        self.status_text.setReadOnly(True)
        self.status_text.setFixedHeight(30)  # Adjust value as needed (e.g., 100 pixels)
        main_layout.addWidget(self.status_text)

        # Start and Play buttons.
        self.start_button = QPushButton(DEFAULT_STRINGS["start_video_btn"])
        self.start_button.setStyleSheet(BTN_STYLE)
        self.start_button.clicked.connect(self.start_video_creation)
        main_layout.addWidget(self.start_button)
        #------------------------------------
        # Removed Play Video button from Main
        #
        # ===================== Second Tab: Review / Edit Script =====================

        # Subtitles tab.
        self.subtitles_tab = QWidget()
        self.subtitles_tab.setProperty("tabFunction", "script")
        self.tabs.addTab(self.subtitles_tab, "Review or Edit Script")
        self.subtitles_layout = QVBoxLayout()
        self.subtitles_tab.setLayout(self.subtitles_layout)
        self.subtitles_editor = QTextEdit()
        self.subtitles_layout.addWidget(self.subtitles_editor)
        self.save_button = QPushButton(DEFAULT_STRINGS["save_subtitles_btn"])
        self.save_button.setStyleSheet(BTN_LF_STYLE)
        self.save_button.clicked.connect(self.save_and_regenerate)
        self.subtitles_layout.addWidget(self.save_button)
        self.tabs.currentChanged.connect(self.on_tab_changed)

        # ===================== Third Tab: Review / Edit Clips & Subtitles =====================
        # Clips and subtitles tab.
        self.clip_sub_tab = QWidget()
        self.clip_sub_tab.setProperty("tabFunction", "clips")
        self.tabs.addTab(self.clip_sub_tab, "Review or Edit Clips and Subtitles")
        clip_sub_layout = QVBoxLayout()
        self.clip_sub_tab.setLayout(clip_sub_layout)

        # Initialize the clip table using our custom MediaTableReorder.
        # This table now lets you drag from column 0 (Select) and only reorders columns 06.
        # Initialize the clip table
        self.clip_table = MediaTableReorder(self)
        self.clip_table.setColumnCount(16)

        # Use the imported texts
        headers = texts.get("clip_table_headers", DEFAULT_STRINGS["clip_table_headers"])

        self.clip_table.setHorizontalHeaderLabels(headers)
        self.clip_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.clip_table.setEditTriggers(QAbstractItemView.DoubleClicked | QAbstractItemView.SelectedClicked)
        clip_sub_layout.addWidget(self.clip_table)

        # Control layout for buttons
        clip_control_layout = QHBoxLayout()
        self.replace_clip_btn = QPushButton(DEFAULT_STRINGS["replace_clip_btn"])
        self.replace_clip_btn.setStyleSheet(BTN_LF_STYLE)
        self.delete_clip_btn = QPushButton(DEFAULT_STRINGS["delete_clip_btn"])
        self.delete_clip_btn.setStyleSheet(BTN_LF_STYLE)
        clip_control_layout.addWidget(self.replace_clip_btn)
        clip_control_layout.addWidget(self.delete_clip_btn)
        clip_sub_layout.addLayout(clip_control_layout)

        # Connect button actions
        self.replace_clip_btn.clicked.connect(self.replace_selected_clip)
        self.delete_clip_btn.clicked.connect(self.delete_selected_items)

        # Final video generation button
        self.generate_final_video_btn = QPushButton(DEFAULT_STRINGS["generate_final_video_btn"])
        self.generate_final_video_btn.setStyleSheet(BTN_LF_STYLE)
        clip_sub_layout.addWidget(self.generate_final_video_btn)

        # ------------------Fourth Tab: Create Final Video ------------------------------
        texts = get_texts_for_current_language(self.target_language_input)
        self.final_video_tab = QWidget()
        self.final_video_tab.setProperty("tabFunction", "final_video")
        #self.tabs.addTab(self.final_video_tab, DEFAULT_STRINGS.get("final_video_tab", "Final Video"))
        self.tabs.addTab(self.final_video_tab,texts.get("final_video_tab", DEFAULT_STRINGS["final_video_tab"]))
        final_layout = QVBoxLayout(self.final_video_tab)

        # Create a QStackedWidget to hold the VLC widget and the preview label
        self.video_stack = QStackedWidget(self.final_video_tab)
        self.video_stack.setMinimumSize(800, 450)  # adjust as needed
        final_layout.addWidget(self.video_stack)

        # Create the VLC-based embedded player widget
        self.vlcWidget = VLCVideoWidget(self.video_stack)
        self.vlcWidget.setMinimumSize(800, 450)  # adjust as needed
        self.video_stack.addWidget(self.vlcWidget)

        # Create the QLabel for video preview
        self.video_preview_label = QLabel(self.video_stack)
        self.video_preview_label.setMinimumSize(800, 450)  # Match the size of the VLC widget
        self.video_preview_label.setAlignment(Qt.AlignCenter)
        self.video_preview_label.setText("Video Preview")  # Placeholder text
        self.video_preview_label.setStyleSheet("background-color: rgba(0, 0, 0, 0.5);")  # Semi-transparent background
        self.video_preview_label.setVisible(False)  # Initially hidden
        self.video_stack.addWidget(self.video_preview_label)

        # Create a control panel for video controls
        self.control_panel = QHBoxLayout()


        # Play Button
        #self.play_button = QPushButton("Play")
        self.play_button = QPushButton(texts.get("play_button", DEFAULT_STRINGS["play_button"]))

        self.play_button.clicked.connect(self.playVideoVLC)
        self.control_panel.addWidget(self.play_button)

        # Pause Button
        #self.pause_button = QPushButton("Pause")
        self.pause_button = QPushButton(texts.get("pause_button", DEFAULT_STRINGS["pause_button"]))

        self.pause_button.clicked.connect(self.pauseVideo)
        self.control_panel.addWidget(self.pause_button)

        # Forward Button
        #self.forward_button = QPushButton("Forward (+10 s)")
        self.forward_button = QPushButton(texts.get("forward_button", DEFAULT_STRINGS["forward_button"]))

        self.forward_button.clicked.connect(self.forwardVideo)
        self.control_panel.addWidget(self.forward_button)

        # Backward Button
        #self.backward_button = QPushButton("Backward (-10 s)")
        self.backward_button = QPushButton(texts.get("backward_button", DEFAULT_STRINGS["backward_button"]))

        self.backward_button.clicked.connect(self.backwardVideo)
        self.control_panel.addWidget(self.backward_button)

        # Add the control panel to the final layout
        final_layout.addLayout(self.control_panel)

        # Now add the Play Video button.
        self.play_video_btn_final = QPushButton(DEFAULT_STRINGS.get("play_video_btn_final", "Play Video"))
        self.play_video_btn_final.setStyleSheet(BTN_LF_STYLE)
        final_layout.addWidget(self.play_video_btn_final)

        # Connect the button to our new VLC-based playback method:
        self.play_video_btn_final.clicked.connect(self.playVideoVLC)

        # Optionally, add an upload widget/button to support social media integration.
        self.upload_video_btn = QPushButton(DEFAULT_STRINGS.get("upload_video_btn", "Upload to Social Media"))
        self.upload_video_btn.setStyleSheet(BTN_LF_STYLE)
        final_layout.addWidget(self.upload_video_btn)
        self.upload_video_btn.clicked.connect(self.on_upload_video)

        if hasattr(self, "generate_final_video_btn"):
            self.generate_final_video_btn.clicked.connect(self.on_generate_final_video)

        # ---------------------------------------------------------------------------
        # Fifth Tab: Support / SR Ticket Creation
        # ---------------------------------------------------------------------------
            # ===================== Fifth Tab: Support =====================
            self.support_tab = QWidget()
            self.support_tab.setProperty("tabFunction", "support")
            # Temporarily set tab text. We'll localize in update_translated_texts
            self.tabs.addTab(self.support_tab, DEFAULT_STRINGS["support_tab"])
            support_layout = QVBoxLayout(self.support_tab)

            # Check FAQ label & link as instance attrs, so we can update them in update_translated_texts
            self.check_faq_label = QLabel(DEFAULT_STRINGS["check_faq_label"])
            support_layout.addWidget(self.check_faq_label)

            self.faq_link_label = QLabel(
                f'<a href="{FAQ_LINK}" style="color:blue;">{DEFAULT_STRINGS["faq_link_text"]}</a>'
            )
            self.faq_link_label.setOpenExternalLinks(True)
            support_layout.addWidget(self.faq_link_label)

            # SR form
            form_widget = QWidget()
            form_layout = QFormLayout(form_widget)
            support_layout.addWidget(form_widget)

            self.sr_number_label = QLabel(DEFAULT_STRINGS["sr_number_label"])
            self.sr_number_value = QLabel("")
            form_layout.addRow(self.sr_number_label, self.sr_number_value)

            self.customer_name_label = QLabel(DEFAULT_STRINGS["customer_name_label"] + " *")
            self.customer_name_input = QLineEdit()
            form_layout.addRow(self.customer_name_label, self.customer_name_input)

            self.email_label = QLabel(DEFAULT_STRINGS["email_label"] + " *")
            self.email_input = QLineEdit()
            form_layout.addRow(self.email_label, self.email_input)

            self.phone_label = QLabel(DEFAULT_STRINGS["phone_label"])
            self.phone_input = QLineEdit()
            form_layout.addRow(self.phone_label, self.phone_input)

            self.ticket_type_label = QLabel(DEFAULT_STRINGS["ticket_type_label"] + " *")
            self.ticket_type_combo = QComboBox()
            #self.ticket_type_combo.addItems(["Issue", "Enhancement", "Comment"])
            form_layout.addRow(self.ticket_type_label, self.ticket_type_combo)

            self.issue_description_label = QLabel(DEFAULT_STRINGS["issue_description_label"] + " *")
            self.issue_description_input = QPlainTextEdit()
            form_layout.addRow(self.issue_description_label, self.issue_description_input)

            self.video_name_label = QLabel(DEFAULT_STRINGS["video_name_label"] + " *")
            self.video_name_input = QLineEdit()
            form_layout.addRow(self.video_name_label, self.video_name_input)

            self.creation_dt_label = QLabel(DEFAULT_STRINGS["creation_dt_label"] + " *")
            # self.creation_dt_input = QLineEdit()
            self.creation_dt_input = QDateTimeEdit()
            # *** Set the desired display format ***
            # MM: Month (01-12)
            # dd: Day (01-31)
            # yy: Year (00-99)
            # HH: Hour (00-23) - Use hh for 01-12 with AP for AM/PM
            # mm: Minute (00-59)
            # zzz: Timezone name (e.g., "EDT", "PST"). Note: This depends on system locale and can be inconsistent.
            # Alternatively, use 'z' for timezone offset (e.g., "+0500")
            # Or simply state "(System Timezone)" as a static part if 'zzz' is unreliable.
            # Let's use 'zzz' as it's closest to your request, but be aware of its behavior.
            #  "AP" = AM/PM in uppercase

            format_string = "MM-dd-yy @ hh:mm AP"

            self.creation_dt_input.setDisplayFormat(format_string)

            # *** Optional: Set an initial value (e.g., current date/time) ***
            self.creation_dt_input.setDateTime(QDateTime.currentDateTime())

            # You can also set minimum/maximum dates if needed
            self.creation_dt_input.setMinimumDateTime(QDateTime(2023, 1, 1, 0, 0))
            self.creation_dt_input.setMaximumDateTime(QDateTime.currentDateTime().addYears(1))

            form_layout.addRow(self.creation_dt_label, self.creation_dt_input)

            self.desc_label = QLabel(DEFAULT_STRINGS["desc_label"] + " *")
            self.desc_input = QPlainTextEdit()
            form_layout.addRow(self.desc_label, self.desc_input)

            self.ticket_type_combo.currentIndexChanged.connect(self.on_ticket_type_changed)

            self.on_ticket_type_changed()  # Hide or show fields initially

            self.send_button = QPushButton(DEFAULT_STRINGS["send_button"])
            self.send_button.setStyleSheet(BTN_LF_STYLE)
            form_layout.addRow(self.send_button)
            self.send_button.clicked.connect(self.on_send_support_ticket)

            # Connect language changes
            self.target_language_input.currentIndexChanged.connect(self.update_translated_texts)

            # Final translations
            self.update_translated_texts()

    #--------------------------------------------------------------------------------
    # METHOD: generate_sr_number
    #--------------------------------------------------------------------------------

    def generate_sr_number(self, sr_type: str) -> str:
        """
        Generate system SR numbers and auto-persist the counters.
        """
        global issue_counter, enh_counter, com_counter

        sr_type = sr_type.lower() if sr_type else "issue"

        if sr_type == "issue":
            sr_id = f"ISS-{issue_counter:07d}"
            issue_counter += 1
        elif sr_type == "enhancement":
            sr_id = f"ENH-{enh_counter:07d}"
            enh_counter += 1
        else:  # treat everything else as 'comment'
            sr_id = f"COM-{com_counter:07d}"
            com_counter += 1

        # _save_counters()  # persist immediately (cheap: one tiny JSON)
        return sr_id

    #--------------------------------------------------------------------------------
    # METHOD: on_ticket_type_changed
    #--------------------------------------------------------------------------------

    def on_ticket_type_changed(self):
        global issue_counter, enh_counter, com_counter
        """
        Called when the user changes the Ticket Type combo.
        Retrieves the userData (issue/enhancement/comment),
        generates a new SR number, and shows/hides relevant fields.
        """
        # Retrieve the behind-the-scenes type
        sr_type = self.ticket_type_combo.currentData()  # "issue", "enhancement", or "comment"

        # Generate new SR ID
        sr_num = self.generate_sr_number(sr_type)
        self.sr_number_value.setText(sr_num)

        if sr_type == "issue":
            issue_counter -= 1
            # Show issue-only fields
            self.issue_description_label.show()
            self.issue_description_input.show()
            self.video_name_label.show()
            self.video_name_input.show()
            self.creation_dt_label.show()
            self.creation_dt_input.show()

            # Hide enhancement/comment fields
            self.desc_label.hide()
            self.desc_input.hide()
        else:
            if sr_type == "enhancement":
                enh_counter -= 1
            else:
                com_counter -= 1
            # For enhancement or comment, hide the issue fields
            self.issue_description_label.hide()
            self.issue_description_input.hide()
            self.video_name_label.hide()
            self.video_name_input.hide()
            self.creation_dt_label.hide()
            self.creation_dt_input.hide()

            # Show the generic description field
            self.desc_label.show()
            self.desc_input.show()

    #--------------------------------------------------------------------------------
    # METHOD: on_send_support_ticket
    #--------------------------------------------------------------------------------

    def send_email(self, ticket_details):
        print("DEBUG: Inside send_email")
        msg = MIMEMultipart()
        msg['From'] = FROM_EMAIL
        msg['To'] = SUPPORT_EMAIL
        msg['Cc'] = ticket_details.get("customer_email", "")
        msg['Subject'] = f"Support Ticket {ticket_details.get('sr_num')} - {ticket_details.get('sr_type').title()}"

        print(f"DEBUG: after msg: {msg}")
        body_lines = [
            f"Ticket Number: {ticket_details.get('sr_num')}",
            f"Type: {ticket_details.get('sr_type')}",
            f"Customer Name: {ticket_details.get('customer_name')}",
            f"Customer Email: {ticket_details.get('customer_email')}"
        ]
        print(f"DEBUG: after body_lines: {body_lines}")

        description_key = 'issue_description' if ticket_details.get('sr_type') == "issue" else 'desc'
        description = ticket_details.get(description_key, '')

        # Detect language and translate if not English
        try:
            detected_lang = detect(description)
            print(f"DEBUG: Detected language: {detected_lang}")
            if detected_lang != 'en':
                prompt = f"Translate the following text to English and specify the original language:\n\n\"{description}\""
                translation = generate_text_chatgpt(prompt)
                print(f"DEBUG: Translation result: {translation}")
                description += f"\n\n[Translated from {detected_lang.upper()}]:\n{translation}"
        except Exception as e:
            print(f"DEBUG: Language detection or translation failed: {e}")

        if ticket_details.get('sr_type') == "issue":
            body_lines.append(f"Issue Description: {description}")
            body_lines.append(f"Video Name: {ticket_details.get('video_name')}")
            body_lines.append(f"Creation Date/Time: {ticket_details.get('creation_dt')}")
        else:
            body_lines.append(f"Description: {description}")

        print("DEBUG: after ticket_details")
        body = "\n".join(body_lines)
        print(f"DEBUG: body: {body}")
        msg.attach(MIMEText(body, 'plain'))

        recipients = [SUPPORT_EMAIL]
        cc_email = ticket_details.get("customer_email")
        print(f"DEBUG: recipients: {recipients}, cc_email: {cc_email}")
        if cc_email:
            recipients.append(cc_email)

        try:
            print(f"DEBUG: before smtplib.SMTP call. SMTP_SERVER:{SMTP_SERVER}, SMTP_PORT:{SMTP_PORT}")
            server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
            print(f"DEBUG: server={server}")
            server.starttls()
            print(f"DEBUG: after server.starttls(): form email: {FROM_EMAIL}, Email password: {EMAIL_PASSWORD}")
            server.login(FROM_EMAIL, EMAIL_PASSWORD)
            print(f"DEBUG: after server.login, before sendmail. recipients: {recipients}, Msg: {msg.as_string()}")
            server.sendmail(FROM_EMAIL, recipients, msg.as_string())
            print("DEBUG: after sendmail, before server.quit()")
            server.quit()
            return True
        except Exception as e:
            print("Failed to send email:", e)
            traceback.print_exc()
            return False

    # In your existing on_send_support_ticket method, call the send_email function:

    def on_send_support_ticket(self):
        """
        Validate fields and send the ticket via email.
        Uses userData to identify which type was chosen.
        """
        # Retrieve the displayed and actual selected type
        displayed_text = self.ticket_type_combo.currentText()
        sr_type = self.ticket_type_combo.currentData()  # "issue", "enhancement", or "comment"
        #sr_num = self.sr_number_value.text().strip()
        sr_num = self.generate_sr_number(sr_type)

        # Get translations for potential messages
        texts = get_texts_for_current_language(self.target_language_input)
        missing_required_title = texts.get("missing_required_title", "Missing Required Fields")
        missing_required_msg = texts.get("missing_required_msg", "Please fill all required fields:\n")

        # Check required fields
        required_errors = []

        if not self.customer_name_input.text().strip():
            required_errors.append(self.customer_name_label.text())
        if not self.email_input.text().strip():
            required_errors.append(self.email_label.text())

        if sr_type == "issue":
            if not self.issue_description_input.toPlainText().strip():
                required_errors.append(self.issue_description_label.text())
            if not self.video_name_input.text().strip():
                required_errors.append(self.video_name_label.text())

            # *** Validation for QDateTimeEdit ***
            # Check if the displayed text is empty (unlikely if initialized, but safe)
            # Or check if the selected QDateTime is valid (QDateTimeEdit usually keeps it valid)
            if not self.creation_dt_input.dateTime().isValid():
                # This check is more robust if there were ways to make it invalid
                required_errors.append(self.creation_dt_label.text())
            elif not self.creation_dt_input.text().strip():
                # This check works if you haven't initialized it or allow clearing
                required_errors.append(self.creation_dt_label.text())
            # If you initialize it and it can't be cleared, the check might not be needed.
            # Let's keep the text().strip() check as it aligns with your original code's style,
            # but understand that with QDateTimeEdit, it's less likely to fail if initialized.
            if not self.creation_dt_input.text().strip():
                required_errors.append(self.creation_dt_label.text())
        else:
            if not self.desc_input.toPlainText().strip():
                required_errors.append(self.desc_label.text())

        # If missing required fields, warn the user
        if required_errors:
            QMessageBox.warning(
                self,
                missing_required_title,
                missing_required_msg + "\n".join(required_errors)
            )
            return  # <-- FIXED: previously this return was incorrectly indented

        # Gather information for the email
        customer_email = self.email_input.text().strip()
        ticket_details = {
            "sr_num": sr_num,
            "sr_type": sr_type,
            "customer_name": self.customer_name_input.text().strip(),
            "customer_email": customer_email,
        }

        if sr_type == "issue":
            ticket_details["issue_description"] = self.issue_description_input.toPlainText().strip()
            ticket_details["video_name"] = self.video_name_input.text().strip()
            ticket_details["creation_dt"] = self.creation_dt_input.text().strip()
        else:
            ticket_details["desc"] = self.desc_input.toPlainText().strip()

        # sending logic using the implemented send_email function
        print(f"Sending SR: {sr_num} of type={sr_type} to {SUPPORT_EMAIL}, CC={customer_email}")
        if self.send_email(ticket_details):  # Make sure send_email is a method on `self`
            sr_sent_title = texts.get("sr_sent_title", DEFAULT_STRINGS["sr_sent_title"])
            sr_sent_msg = texts.get("sr_sent_msg", DEFAULT_STRINGS["sr_sent_msg"])
            _save_counters()
            QMessageBox.information(self, sr_sent_title, sr_sent_msg)
        else:
            QMessageBox.critical(self, "Error", "Failed to send the support ticket. Please try again later.")

    def set_video_title(self, text):
        self.video_title = text.strip()  # Remove leading/trailing whitespace

    def refresh_texts(self):
        # optional: if you want to keep a self.texts cache for create_video()
        self.texts = get_texts_for_current_language(self.target_language_input)

    def update_media_order(self, new_media_order):
        """
        Update the underlying media clip ordering based on new_media_order.
        new_media_order is a list of media file paths read from the table.
        """
        if new_media_order:
            self.media_clips = new_media_order
            print("DEBUG: Updated media clip order:", self.media_clips)

    def recalcMediaTimings(self):
        """
        Recalculate the cumulative timing for media clips.
        For each row (assumed to correspond to a media clip), update the
        "Start Time" (column 2) and "End Time" (column 3) cells.
        Videos use get_video_duration(media_path); images default to 5 seconds.
        """
        cumulative = 0.0
        row_count = self.clip_table.rowCount()
        for row in range(row_count):
            # Retrieve media file from column 0 UserRole.
            item = self.clip_table.item(row, 0)
            if item is None:
                continue
            media_path = item.data(Qt.UserRole)
            if media_path:
                # Check file extension for duration.
                if media_path.lower().endswith((".mp4", ".avi", ".mov", ".mkv")):
                    try:
                        duration = get_video_duration(media_path)
                    except Exception as e:
                        print(f" Error getting duration for {media_path}: {e}")
                        duration = 0.0
                else:
                    duration = 5.0  # default duration for images
                start_time = cumulative
                cumulative += duration
                end_time = cumulative
                startItem = QTableWidgetItem(format_seconds(start_time))
                startItem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 2, startItem)
                endItem = QTableWidgetItem(format_seconds(end_time))
                endItem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 3, endItem)

    # Method to update the video preview image
    def update_video_preview(self):
        video_title = self.video_title_input.text().strip()
        platform = self.platform_input.currentText().strip()
        out_dir = self.output_directory_path
        final_video_file = os.path.normpath(os.path.join(out_dir, f"{video_title}_{platform}.mp4"))

        # Load a thumbnail or still image from the final video
        if os.path.exists(final_video_file):
            # Here you can use a method to extract a frame or use a static image
            thumbnail = self.get_video_thumbnail(final_video_file)  # Assuming this method exists
            if thumbnail and not thumbnail.isNull():
                # Scale the thumbnail to fit the entire preview area
                self.video_preview_label.setPixmap(
                    thumbnail.scaled(self.video_preview_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation))
                self.video_preview_label.setVisible(True)  # Show the preview label
                self.video_stack.setCurrentWidget(self.video_preview_label)  # Show the preview label
            else:
                self.video_preview_label.setText("No preview available.")
                self.video_preview_label.setVisible(True)  # Show the preview label
                self.video_stack.setCurrentWidget(self.video_preview_label)  # Show the preview label
        else:
            self.video_preview_label.setText("Final video not found.")
            self.video_preview_label.setVisible(True)  # Show the preview label
            self.video_stack.setCurrentWidget(self.video_preview_label)  # Show the preview label

    # Modify the playVideoVLC method to hide the preview label when playing the video
    def playVideoVLC(self):
        print("DEBUG: Inside playVideoVLC....")
        if hasattr(self, "uploading") and self.uploading:
            print("DEBUG: Upload in progress, skipping playback.")
            return
        video_title = self.video_title_input.text().strip()
        print(f"DEBUG: Video title: {video_title}")
        if not video_title:
            QMessageBox.warning(self, " Warning", "Please enter a video title.")
            return
        platform = self.platform_input.currentText().strip()
        print(f"DEBUG: platform: {platform}")
        out_dir = self.output_directory_path  # use the updated global string
        print(f"DEBUG: out_dir: {out_dir}")
        final_video_file = os.path.normpath(os.path.join(out_dir, f"{video_title}_{platform}.mp4"))
        print(f"DEBUG: final_video_file: {final_video_file}")
        if not os.path.exists(final_video_file):
            QMessageBox.warning(self, " Warning", f"Video file not found: {final_video_file}")
            return
        print("DEBUG: final_video_file Exist:", final_video_file)

        # Hide the preview label when playing the video
        self.video_preview_label.setVisible(False)
        self.video_stack.setCurrentWidget(self.vlcWidget)  # Switch to VLC widget

        try:
            print("Playing via VLC fallback:", final_video_file)
            self.vlcWidget.play(final_video_file)  # Ensure this method exists in your VLCVideoWidget
            print("DEBUG: After call to vlcWidget.play:", final_video_file)
        except Exception as e:
            print(f" Error during playback: {e}")
            QMessageBox.critical(self, " Playback Error", f" An error occurred while trying to play the video: {e}")

    def pauseVideo(self):
        print("DEBUG: Pausing video.")
        try:
            self.vlcWidget.pause()  # Call the pause method on the VLCVideoWidget
        except Exception as e:
            print(f" Error during pause: {e}")
            QMessageBox.critical(self, " Pause Error", f" An error occurred while trying to pause the video: {e}")

    def forwardVideo(self):
        print("DEBUG: Forwarding video.")
        try:
            current_position = self.vlcWidget.get_time()  # Get current position in milliseconds
            self.vlcWidget.set_time(current_position + 10000)  # Forward 10 seconds
        except Exception as e:
            print(f" Error during forward: {e}")
            QMessageBox.critical(self, " Forward Error", f" An error occurred while trying to forward the video: {e}")

    def backwardVideo(self):
        print("DEBUG: Backwarding video.")
        try:
            current_position = self.vlcWidget.get_time()  # Get current position in milliseconds
            self.vlcWidget.set_time(current_position - 10000)  # Backward 10 seconds
        except Exception as e:
            print(f" Error during backward: {e}")
            QMessageBox.critical(self, " Backward Error",
                                 f" An error occurred while trying to backward the video: {e}")

    def playVideoEmbedded(self):
        print("DEBUG: Inside playVideoEmbedded")
        video_title = self.video_title_input.text().strip()
        print(f"DEBUG: video_title: {video_title}")
        if not video_title:
            QMessageBox.warning(self, " Warning", "Please enter a video title.")
            return

        platform = self.platform_input.currentText().strip()
        print(f"DEBUG: platform: {platform}")

        # Use the global (instance) string variable instead of the widget.
        try:
            print("DEBUG: Using output_directory_path:", self.output_directory_path)
            out_dir = self.output_directory_path  # already a stripped string.
            final_video_file = os.path.normpath(os.path.join(out_dir, f"{video_title}_{platform}.mp4"))
            print(f"DEBUG: final_video_file: {final_video_file}")
        except Exception as e:
            print("DEBUG: Exception constructing file path:", e)
            QMessageBox.critical(self, " Error", f" Error constructing file path: {e}")
            return

        if not os.path.exists(final_video_file):
            QMessageBox.warning(self, " Warning", f"Video file not found: {final_video_file}")
            return

        # Construct the media object.
        media_url = QUrl.fromLocalFile(final_video_file)
        print(f"DEBUG: media_url: {media_url}")
        media = QMediaContent(media_url)
        print(f"DEBUG: media: {media}")

        # Prepare the player for playback.
        print("DEBUG: Preparing previewPlayer.")
        if not self.previewPlayer:
            print("DEBUG:  ERROR: previewPlayer is not properly set up!")
            return
        self.previewPlayer.stop()
        self.previewPlayer.setMedia(QMediaContent())  # Clear any existing media.

        self.switchTab("final_video")  # Show the video widget
        QTimer.singleShot(1000, lambda: self._startEmbeddedPlayback(media, final_video_file))
        print("DEBUG: Playback scheduled via QTimer.singleShot.")

    def _startEmbeddedPlayback(self, media, final_video_file):
        try:
            self.previewPlayer.setMedia(media)
            self.previewPlayer.setVolume(50)

            # Ensure the video preview widget is visible and updated.
            self.videoPreviewWidget.show()
            self.videoPreviewWidget.raise_()
            self.videoPreviewWidget.update()

            self.previewPlayer.play()
            self.status_text.appendPlainText(f"Playing video: {final_video_file}")
            print("DEBUG: Playback started successfully.")
        except Exception as e:
            print("DEBUG: Exception in _startEmbeddedPlayback:", e)
            QMessageBox.critical(self, " Error", f" Playback error: {e}")

    def authenticate_youtube_user(self, switch_account=False):
        """Authenticate the user via OAuth2 and return valid credentials.
        If switch_account is True, any stored token is ignored (deleted) so the user can switch accounts."""
        import os, pickle
        from google.auth.transport.requests import Request
        from google_auth_oauthlib.flow import InstalledAppFlow

        token_file = "token_youtube.pickle"
        creds = None
        print("DEBUG: Starting YouTube authentication; token file:", token_file)

        # If switching account, remove existing token file.
        if switch_account and os.path.exists(token_file):
            try:
                os.remove(token_file)
                print("DEBUG: switch_account enabled; removed existing token file.")
            except Exception as e:
                print(" WARNING: Could not remove token file for switch_account:", e)

        try:
            if os.path.exists(token_file):
                print("DEBUG: Token file found. Loading credentials from file.")
                with open(token_file, "rb") as token:
                    creds = pickle.load(token)
            else:
                print("DEBUG: Token file NOT found.")
            if not creds or not creds.valid:
                if creds and creds.expired and creds.refresh_token:
                    try:
                        print("DEBUG: Credentials expired. Refreshing credentials.")
                        creds.refresh(Request())
                    except Exception as e:
                        print("DEBUG: Token refresh failed:", e)
                        try:
                            os.remove(token_file)
                            print("DEBUG: Removed invalid token file.")
                        except Exception as del_err:
                            print(" WARNING: Could not delete token file:", del_err)
                        creds = None
                if not creds:
                    print("DEBUG: No valid credentials available; starting OAuth2 flow.")
                    flow = InstalledAppFlow.from_client_secrets_file(CLIENT_SECRETS_FILE, YOUTUBE_SCOPES)
                    creds = flow.run_local_server(port=8080)
                with open(token_file, "wb") as token:
                    pickle.dump(creds, token)
                    print("DEBUG: Credentials saved to token file.")
        except Exception as e:
            print(" Error during YouTube authentication:", e)
            raise
        print("DEBUG: YouTube authentication finished. creds type:", type(creds))
        return creds


    def upload_video_to_platform(self, final_video_file, platform):
        platform = platform.lower()
        print("DEBUG: In upload_video_to_platform. Platform:", platform)
        if platform in ["youtube", "youtube_shorts"]:
            # Get default upload details from GUI.
            default_description = ""
            if hasattr(self, "script_editor"):
                default_description = self.script_editor.toPlainText()
            default_tags = ["Video", "Upload"]
            if hasattr(self, "modified_keywords"):
                default_tags = self.modified_keywords

            print("DEBUG: Parent for UploadDialog is:", type(self))
            print("DEBUG: Launching UploadDialog with default_description:", repr(default_description),
                  "default_tags:", repr(default_tags))

            try:
                if platform.lower() in ["youtube_shorts"]:
                    note = ("NOTE: YouTube Shorts are intended for videos of 60 seconds or less. "
                            "Please ensure that your video meets the length requirement for YouTube Shorts.")
                    #QMessageBox.information(self, self.tr("YouTube Shorts Reminder"), self.tr(note))
                    QMessageBox.information(
                        self,
                        self.youtube_shorts_reminder_title,
                        self.youtube_shorts_reminder_msg
                    )
                # For testing, pass parent=None to avoid potential parenting issues.
                dialog = UploadDialog(default_description=default_description,
                                      default_tags=default_tags,
                                      default_privacy="private",
                                      parent=None)
                print("DEBUG: UploadDialog instance created successfully.")
            except Exception as e:
                print(" ERROR: Exception while creating UploadDialog:", e)
                return False

            try:
                result = dialog.exec_()
                print("DEBUG: UploadDialog exec_() result:", result)
            except Exception as e:
                print(" ERROR: Exception while executing UploadDialog:", e)
                return False

            if result == QDialog.Accepted:
                # Fully unpack all returned values.
                (description, tags, privacyStatus, thumbnail, categoryId,
                 language, recording_date, switch_account) = dialog.getData()
                print("DEBUG: Details received from UploadDialog:")
                print("    description:", repr(description))
                print("    tags:", repr(tags))
                print("    privacyStatus:", repr(privacyStatus))
                print("    categoryId:", repr(categoryId))
                print("    language:", repr(language))
                print("    recording_date:", repr(recording_date))
                print("    switch_account:", repr(switch_account))

                # Ensure YouTube description is no more than 4500 characters.
                max_length = 5000
                if len(description) > max_length:
                    print(f"WARNING: Description is {len(description)} chars, exceeding {max_length}, truncating.")
                    description = description[:max_length]

                # Pass all required parameters to upload_to_youtube.
                return self.upload_to_youtube(
                    final_video_file,
                    self.video_title_input.text().strip(),
                    description,
                    tags,
                    privacyStatus,
                    categoryId,
                    language,
                    recording_date,
                    switch_account
                )
            else:
                print("DEBUG: UploadDialog was cancelled by user.")
                return False

        elif platform.lower() in ["facebook", "instagram", "tiktok", "720p"]:
            normalized_path = final_video_file.replace("/", "\\")
            #QMessageBox.information(
            #    self,
            #    self.tr("Coming Soon"),
            #    self.tr(
            #        "The integration for {} is coming soon.\n\nPlease manually upload the final video.\nVideo path: {}"
            #    ).format(platform.capitalize(), normalized_path)
            #)
            QMessageBox.information(
                self,
                self.coming_soon_title,
                self.coming_soon_msg.format(platform.capitalize(),
                                            final_path.replace("/", "\\"))
            )
            self.uploading = False
            return
        else:
            print("Manual Upload:", platform)
            return False

    # Definition of upload_to_youtube (for reference):
    def upload_to_youtube(self, final_video_file, title, description, tags, privacyStatus,
                          categoryId, language, recording_date, switch_account=False):
        """
        Upload video to YouTube using the users credentials.
        Extended to include extra fields such as Category, Video Language, and Recording Date.
        """
        texts = get_texts_for_current_language(self.target_language_input)

        max_length = 5000
        if len(description) > max_length:
            print(f"WARNING: Description is {len(description)} chars, exceeding {max_length}, truncating.")
            description = description[:max_length]

        print("DEBUG: Starting upload_to_youtube")
        print("DEBUG: final_video_file:", repr(final_video_file))
        print("DEBUG: title:", repr(title))
        print("DEBUG: description:", repr(description))
        print("DEBUG: tags:", repr(tags))
        print("DEBUG: privacyStatus:", repr(privacyStatus))
        print("DEBUG: categoryId:", repr(categoryId))
        print("DEBUG: language:", repr(language))
        print("DEBUG: recording_date:", repr(recording_date))

        try:
            creds = self.authenticate_youtube_user(switch_account=switch_account)
            self.last_youtube_credentials = creds
        except Exception as e:
            print("Authentication failed:", e)
            return False, None

        try:
            print("DEBUG: Building YouTube service...")
            from googleapiclient.discovery import build
            youtube = build("youtube", "v3", credentials=creds)
        except Exception as e:
            print(" Error building YouTube service:", e)
            return False, None

        body = {
            "snippet": {
                "title": title,
                "description": description,
                "tags": tags,
                "categoryId": categoryId,
                "defaultLanguage": language,
                "defaultAudioLanguage": language,
            },
            "status": {
                "privacyStatus": privacyStatus
            },
            "recordingDetails": {
                "recordingDate": recording_date,
            }
        }

        print("DEBUG: Final request body:", body)

        try:
            print("DEBUG: Creating MediaFileUpload object...")
            from googleapiclient.http import MediaFileUpload
            media = MediaFileUpload(final_video_file, chunksize=-1, resumable=True)
        except Exception as e:
            print(" Error creating MediaFileUpload object:", e)
            return False, None

        try:
            print("DEBUG: Creating upload request...")
            request = youtube.videos().insert(
                part="snippet,status,recordingDetails",
                body=body,
                media_body=media
            )
        except Exception as e:
            print(" Error creating upload request:", e)
            return False, None

        #progress_dialog = self.
        # (self.tr("Uploading Video to YouTube... Please wait."))
        progress_dialog = self.show_progress(texts.get("uploading_video", DEFAULT_STRINGS["uploading_video"]))

        progress_dialog.setRange(0, 100)
        progress_dialog.show()

        response = None
        print("Uploading video to YouTube...")
        try:
            while response is None:
                status, response = request.next_chunk()
                if status:
                    prog_val = int(status.progress() * 100)
                    print("Upload progress: {}%".format(prog_val))
                    progress_dialog.setValue(prog_val)
                    QApplication.processEvents()  # Keep UI responsive.
                    if progress_dialog.wasCanceled():
                        print("Upload canceled by user.")
                        progress_dialog.close()
                        return False, None
            progress_dialog.setValue(100)
            progress_dialog.close()
            video_id = response.get("id")
            print("Upload complete! Video ID:", video_id)
            QMessageBox.information(self, texts.get("info", DEFAULT_STRINGS["info"]),
                                    texts.get("upload_success", DEFAULT_STRINGS["upload_success"]))
            return True, video_id
        except Exception as e:
            progress_dialog.close()
            print(" Error during upload:", e)
            return False, None

    def get_output_filename(title, platform, output_dir, ext=".mp4"):
        """
        Create a filename such as "Singing Birds_youtube.mp4".
        Ensures a consistent naming and joining of paths.
        """
        return os.path.join(output_dir, f"{title}_{platform}{ext}")

    def ensure_platform_file(title, desired_platform, output_dir):
        """
        Checks for an existing file for the desired platform.
        If the file does not exist, it searches for any alternative file from the supported platforms.
        If found, a copy is created for the desired platform.
        Returns the file path (existing or newly copied) or None if not found.
        """
        desired_file = get_output_filename(title, desired_platform, output_dir)

        if os.path.exists(desired_file):
            print(f"[INFO] {desired_platform} file already exists: {desired_file}")
            return desired_file

        # Look for an existing video from one of the alternative platforms
        for alt_platform in PLATFORMS:
            if alt_platform == desired_platform:
                continue
            alt_file = get_output_filename(title, alt_platform, output_dir)
            if os.path.exists(alt_file):
                try:
                    shutil.copy(alt_file, desired_file)
                    print(f"[INFO] Copied {alt_platform} file to {desired_platform}: {desired_file}")
                except Exception as e:
                    print(f"[ ERROR] Could not copy file from {alt_platform} to {desired_platform}: {e}")
                return desired_file

        print(f"[INFO] No alternative file found for {desired_platform}.")
        return None

    # ---------------------
    # In your class:
    # ---------------------
    def on_upload_video(self):


        texts = get_texts_for_current_language(self.target_language_input)
        print("DEBUG: on_upload_video: start")

        # Prevent double-clicks
        if getattr(self, "_uploading", False):
            print("DEBUG: already uploading  returning")
            return
        self._uploading = True
        self.upload_video_btn.setEnabled(False)

        try:
            # Step 1: Normalize output directory
            print("DEBUG: Step 1  normalize output_directory")

            # Safely read raw_output_path from either a QLineEdit or a str
            if hasattr(self.output_directory, "text"):
                raw_output_path = self.output_directory.text().strip()
            else:
                raw_output_path = str(self.output_directory).strip()

            # remember it
            self.last_output_path = raw_output_path

            # normalize for OS
            out_dir = os.path.normpath(raw_output_path)

            # Step 2: Choose platform
            print("DEBUG: Step 2  choose platform")
            platform = choose_social_media_platform(self)
            print(f"DEBUG: platform = {platform}")

            # Step 3: Get video title
            print("DEBUG: Step 3  get video_title")
            video_title = self.video_title_input.text().strip()

            # Step 4: Ensure final video file exists
            print("DEBUG: Step 4  ensure_platform_file")
            final_video_file = ensure_platform_file(
                video_title,
                platform.lower(),
                out_dir
            )
            if not final_video_file:
                print("DEBUG: Step 4a  final_video_file missing, warning user")
                #QMessageBox.warning(
                #    self,
                #    texts.get("file_not_found_title", " WARNING: File Not Found"),
                #    texts.get(
                #        "file_not_found_msg",
                #        f"Final video file for {platform.capitalize()} not found."
                #    )
                #)
                QMessageBox.warning(
                    self,
                    self.file_not_found_title,
                    self.file_not_found_msg.format(platform.capitalize())
                )
                return

            final_video_file = os.path.normpath(final_video_file)
            print(f"DEBUG: Step 4b  final_video_file = {final_video_file}")

            # Step 5: Early-exit for non-YouTube
            print("DEBUG: Step 5  non-YouTube early exit check")
            if platform.lower() in ("facebook", "instagram", "tiktok", "720p"):
                msg = texts.get(
                    "coming_soon_msg",
                    "The integration for {} is coming soon.\n\n"
                    "Please manually upload the final video.\nVideo path: {}"
                ).format(
                    platform.capitalize(),
                    final_video_file.replace("/", "\\")
                )
                #QMessageBox.information(
                #    self,
                #    texts.get("coming_soon_title", "Coming Soon"),
                #    msg
                #)
                QMessageBox.information(
                    self,
                    self.coming_soon_title,
                    self.coming_soon_msg.format(
                        platform.capitalize(),
                        final_video_file.replace("/", "\\")
                    )
                )
                return

            # Step 6: Build default_tags
            print("DEBUG: Step 6  build default_tags")
            if hasattr(self, "modified_keywords") and self.modified_keywords:
                mk = self.modified_keywords
                if isinstance(mk, str):
                    default_tags = [
                        t.strip()
                        for t in mk.replace("\n", ",").split(",")
                        if t.strip()
                    ]
                else:
                    default_tags = list(mk)
            else:
                extracted = seo_extract_keywords(video_title)
                default_tags = [
                    kw.strip()
                    for kw in extracted.replace("\n", ",").split(",")
                    if kw.strip()
                ]

            # Step 7: Load default_description
            print("DEBUG: Step 7  load default_description")
            srt_txt = os.path.join(
                out_dir,
                f"{video_title}_subtitles.txt"
            )
            if os.path.exists(srt_txt):
                with open(srt_txt, "r", encoding="utf-8") as f:
                    default_description = f.read()
            else:
                default_description = ""
            print("DEBUG: default_description loaded")

            # Step 8: Prompt Modify Keywords?
            print("DEBUG: Step 8  optional modify keywords")
            if self.modify_yes.isChecked():
                new_str, ok = QInputDialog.getText(
                    self,
                    texts.get(
                        "modify_label",
                        DEFAULT_STRINGS["modify_label"]
                    ),
                    texts.get(
                        "enter_keywords",
                        DEFAULT_STRINGS["enter_keywords"]
                    ),
                    QLineEdit.Normal,
                    ", ".join(default_tags)
                )
                if ok:
                    default_tags = [
                        kw.strip()
                        for kw in new_str.replace("\n", ",").split(",")
                        if kw.strip()
                    ]
                    print("DEBUG: Modified Keywords:", default_tags)

            # Step 9: Auto-translate/combine keywords
            print("DEBUG: Step 9  translate_and_combine_keywords")
            combined = translate_and_combine_keywords(default_tags)
            default_tags = [
                t.strip()
                for t in combined.split(",")
                if t.strip()
            ]
            print("DEBUG: Final default_tags:", default_tags)

            # Step 10: Show UploadDialog
            print("DEBUG: Step 10  launch UploadDialog")
            dialog = UploadDialog(
                default_description=default_description,
                default_tags=default_tags,
                default_privacy="private",
                default_thumbnail="",
                parent=self
            )
            if dialog.exec_() == QDialog.Accepted:
                print("DEBUG: Step 10a  dialog accepted")
                (description, tags, privacyStatus,
                 thumbnail, categoryId, language,
                 recording_date, switch_account) = dialog.getData()
                print("DEBUG: switch_account =", switch_account)
                self.switch_youtube_account = switch_account

                # Step 11: Clean tags
                print("DEBUG: Step 11  clean tags")
                cleaned_tags = []
                for tag in tags:
                    ct = tag.replace(".", "").strip()
                    if 0 < len(ct) <= 50:
                        cleaned_tags.append(ct)
                tags = cleaned_tags
                print("DEBUG: Cleaned tags:", tags)

                # Step 12: Upload to YouTube
                print("DEBUG: Step 12  upload_to_youtube")
                result, video_id = self.upload_to_youtube(
                    final_video_file,
                    video_title,
                    description, tags, privacyStatus,
                    categoryId, language, recording_date,
                    switch_account=self.switch_youtube_account
                )
                print("DEBUG: upload_to_youtube returned", result, video_id)

                # Step 13: Thumbnail upload
                print("DEBUG: Step 13  thumbnail upload")
                if (result and video_id and thumbnail
                        and os.path.exists(thumbnail)):
                    try:
                        from googleapiclient.http import MediaFileUpload
                        from googleapiclient.discovery import build

                        progress_dialog = self.show_progress(
                            texts.get("uploading_thumbnail",
                                      DEFAULT_STRINGS["uploading_thumbnail"])
                        )
                        progress_dialog.setRange(0, 100)
                        progress_dialog.show()
                        print("DEBUG: Uploading thumbnail")

                        youtube = build('youtube', 'v3',
                                        credentials=self.last_youtube_credentials)
                        youtube.thumbnails().set(
                            videoId=video_id,
                            media_body=MediaFileUpload(thumbnail)
                        ).execute()

                        print("DEBUG: Thumbnail upload successful.")
                        progress_dialog.setValue(100)
                        progress_dialog.close()

                        QMessageBox.information(
                            self,
                            texts.get("info",DEFAULT_STRINGS["info"]),
                            texts.get("upload_success",DEFAULT_STRINGS["upload_success"])
                        )
                    except Exception as e:
                        print(" ERROR: Thumbnail upload failed:", e)
                elif not (result and video_id):
                    QMessageBox.critical(
                        self,
                        texts.get("upload_failure_title", " Upload Failure"),
                        texts.get("upload_failure",
                                  DEFAULT_STRINGS["upload_failure"])
                    )

        except Exception:
            print(" Python exception in on_upload_video:")
            traceback.print_exc()

        finally:
            # Restore UI state
            print("DEBUG: on_upload_video: finally  resetting UI")
            self._uploading = False
            self.upload_video_btn.setEnabled(True)

    def authenticate_instagram_user(self):
        """
        Pseudocode for user authentication via Instagram.
        Steps:
          - Direct the user to Instagrams OAuth URL in a web view or external browser.
          - Receive a redirect with a code.
          - Exchange the code for a user access token.
        Return the access token.
        """
        # For a production app, youll use a proper OAuth flow
        access_token = "USER_PROVIDED_INSTAGRAM_ACCESS_TOKEN"
        return access_token

    def upload_to_instagram(self, final_video_file):
        """
        Upload video to Instagram.
        Note: Instagram requires that the video be hosted at a publicly accessible URL.
        Thus, you may need to upload the final_video_file to a cloud storage or server first.
        """
        access_token = self.authenticate_instagram_user()
        ig_user_id = "USER_INSTAGRAM_ID"  # Should be obtained via OAuth
        # Step 1: Upload your video to a public host (not shown)
        video_public_url = "https://your-public-host.com/path/to/video.mp4"

        # Step 2: Create a media container
        upload_url = f"https://graph.facebook.com/v16.0/{ig_user_id}/media"
        data = {
            "media_type": "VIDEO",
            "video_url": video_public_url,
            "caption": "Your caption here",
            "access_token": access_token
        }
        r = requests.post(upload_url, data=data)
        if r.status_code != 200:
            print(" Instagram container error:", r.text)
            return False
        container_id = r.json().get("id")

        # Step 3: Publish the container
        publish_url = f"https://graph.facebook.com/v16.0/{ig_user_id}/media_publish"
        data = {
            "creation_id": container_id,
            "access_token": access_token
        }
        r = requests.post(publish_url, data=data)
        if r.status_code == 200:
            print("Instagram upload successful.")
            return True
        else:
            print(" Instagram publish error:", r.text)
            return False

    def authenticate_tiktok_user(self):
        """
        Pseudocode for TikTok authentication.
        You need to direct the user to TikToks OAuth login, obtain a code, exchange it for an access token.
        """
        access_token = "USER_TIKTOK_ACCESS_TOKEN"
        return access_token

    def upload_to_tiktok(self, final_video_file):
        """
        Upload the video to TikTok.
        Note: This outline assumes TikTok provides an endpoint for direct file upload.
        """
        access_token = self.authenticate_tiktok_user()
        upload_endpoint = "https://open-api.tiktok.com/video/upload/"
        files = {"video": open(final_video_file, "rb")}
        params = {"access_token": access_token}
        r = requests.post(upload_endpoint, params=params, files=files)
        if r.status_code != 200:
            print(" TikTok upload error:", r.text)
            return False
        # Assume a successful response returns a video_id.
        video_id = r.json().get("video_id")
        # If TikTok requires a publish step:
        publish_endpoint = "https://open-api.tiktok.com/video/publish/"
        data = {"video_id": video_id, "access_token": access_token, "caption": "Your caption here"}
        r = requests.post(publish_endpoint, data=data)
        if r.status_code == 200:
            print("TikTok upload successful.")
            return True
        else:
            print(" TikTok publish error:", r.text)
            return False

    def authenticate_facebook_user(self):
        """
        Use a Facebook OAuth flow to obtain a page access token.
        For this example, assume the user logs in and you receive a token.
        """
        access_token = "USER_FACEBOOK_PAGE_ACCESS_TOKEN"  # Retrieved via OAuth process
        return access_token

    def upload_to_facebook(self, final_video_file):
        """
        Upload a video to Facebook using the Graph Video API.
        """
        access_token = self.authenticate_facebook_user()
        page_id = "YOUR_FACEBOOK_PAGE_ID"  # You can let the user enter this or choose from a list, etc.
        upload_url = f"https://graph-video.facebook.com/v16.0/{page_id}/videos"

        files = {"source": open(final_video_file, "rb")}
        data = {
            "access_token": access_token,
            "title": "Your Video Title",
            "description": "Your video description",
            "published": "true",
        }
        response = requests.post(upload_url, files=files, data=data)
        if response.status_code == 200:
            print("Facebook upload successful.", response.json())
            return True
        else:
            print("Facebook upload failed:", response.text)
            return False

    def on_generate_final_video(self):

        texts = get_texts_for_current_language(self.target_language_input)

        # Optionally, you may want to re-use the logic from _on_review_response
        #progress = self.show_progress(self.tr("Generating Final Video... Please wait."))
        progress = self.show_progress(texts.get("generating_final_video", DEFAULT_STRINGS["generating_final_video"]))

        if self.bypass_yes.isChecked():
            self.continue_video_creation_bypass()
        else:
            self.continue_video_creation()

        #progress.close()
        self._cleanup_progress()

        # Switch automatically to the new "Final Video" tab.
        final_video_index = self.tabs.indexOf(self.final_video_tab)
        if final_video_index != -1:
            self.tabs.setCurrentIndex(final_video_index)
        # Call this method after generating the final video
        self.update_video_preview()

    def show_progress(self, message: str) -> QProgressDialog:
        self._cleanup_progress()
        texts = get_texts_for_current_language(self.target_language_input)
        dlg = QProgressDialog(message, None, 0, 0, self)
        dlg.setWindowModality(Qt.ApplicationModal)
        dlg.setWindowTitle(
            texts.get("processing_title", DEFAULT_STRINGS["processing_title"])
        )
        dlg.setCancelButton(None)
        dlg.setMinimumDuration(0)

        # Make it frameless and stay on top

        dlg.setWindowFlags(
            dlg.windowFlags()
            | Qt.FramelessWindowHint
            | Qt.WindowStaysOnTopHint
        )


        # Updated stylesheet

        dlg.setStyleSheet("""
            QProgressDialog {
                background-color: rgba(240, 240, 240, 220);
                border-radius: 10px;
                padding: 20px;
            }

            QLabel {
                color: black;
                font-size: 12px;
                font-weight: bold;
            }
        """)


        # initially set plain text

        dlg.setLabelText(message)
        dlg.show()
        dlg.setValue(0)
        QApplication.processEvents()

        #  grab the internal QLabel and allow HTML 

        lbl = dlg.findChild(QLabel)
        if lbl:
            lbl.setTextFormat(Qt.RichText)
            lbl.setWordWrap(True)
        # 

        # prepare toggle values for flashing text

        orig  = message
        flash = f'<font color="#5d8aa8">{message}</font>'
        state = [False]

        #  flash timer 

        timer = QTimer(dlg)
        timer.setInterval(500)

        def _flash():
            state[0] = not state[0]
            if lbl:
                lbl.setText(flash if state[0] else orig)

        timer.timeout.connect(_flash)
        timer.start()

        # 

        self.progress     = dlg
        self._flash_timer = timer
        return dlg



    def _cleanup_progress(self):
        """Stop & delete any existing progress dialog & its timer."""
        t = getattr(self, "_flash_timer", None)
        if t:
            t.stop()
            t.deleteLater()
            self._flash_timer = None
        d = getattr(self, "progress", None)
        if d:
            d.close()
            d.deleteLater()
            self.progress = None

    def dropEvent(self, event):
        texts = get_texts_for_current_language(self.parent.target_language_input)
        if not event.isAccepted() and event.source() == self:
            drop_row = self.rowAt(event.pos().y())
            if drop_row == -1:
                drop_row = self.rowCount() - 1

            rows = sorted(set(item.row() for item in self.selectedItems()))
            if not rows:
                return

            source_row = rows[0]

            # Prevent dropping onto itself
            if source_row == drop_row:
                event.ignore()
                return

            print(f"Moving row {source_row} to {drop_row}")

            try:
                # After you compute `texts` 
                self.progress = self.show_progress(
                    texts.get("moving_media_message",
                              DEFAULT_STRINGS["moving_media_message"])
                )
                # keep it window-modal and on-top if you like
                self.progress.setWindowModality(Qt.WindowModal)
                self.progress.setWindowFlags(
                    self.progress.windowFlags() | Qt.WindowStaysOnTopHint
                )
                # prevent wrapping
                self.progress.setMinimumWidth(250)
                QApplication.processEvents()

                self.last_scroll_position = self.verticalScrollBar().value()

                if hasattr(self.parent, 'media_clips'):
                    media_clips = self.parent.media_clips
                    if source_row < len(media_clips):
                        final_drop_row = drop_row
                        if drop_row > source_row:
                            final_drop_row -= 1

                        clip = media_clips.pop(source_row)
                        insert_pos = min(final_drop_row, len(media_clips))
                        media_clips.insert(insert_pos, clip)

                        event.accept()
                        self.dragging = False

                        # Use timer to close progress dialog after refresh
                        QTimer.singleShot(1, lambda: self._refresh_after_drop(final_drop_row))

                        print(f"Drop completed successfully")
                    else:
                        self._cleanup_progress()
                        #progress.close()
                        event.ignore()
                else:
                    #progress.close()
                    self._cleanup_progress()
                    event.ignore()

            except Exception as e:
                print(f"Error during drop operation: {e}")
                self._cleanup_progress()
                #progress.close()
                event.ignore()
                self.dragging = False

    def translate_text(text, target_lang, source_lang="en"):
        try:
            model_name = f"Helsinki-NLP/opus-mt-{source_lang}-{target_lang}"
            # Check GPU availability and set device.
            if torch.cuda.is_available():
                device = 0  # Use the first GPU (you can change this if you have multiple GPUs).
                print("Using GPU for translation.")
            else:
                device = -1  # Use CPU if no GPU is available.
                print("Using CPU for translation.")
            translator = pipeline("translation", model=model_name, device=device)
            result = translator(text, max_length=512)
            return result[0]['translation_text']
        except Exception as e:
            print(f"Translation exception: {e}")
            return text

        # Update translated texts for all GUI widgets.

    def update_translated_texts(self):
        # Get the language code from the combo box's userData instead of using self.target_languages.
        texts = get_texts_for_current_language(self.target_language_input)

        # Update tab titles, labels and buttons.
        self.tabs.setTabText(0, texts.get("main_tab_title", DEFAULT_STRINGS["main_tab_title"]))
        self.voice_label.setText(texts.get("voice_label", DEFAULT_STRINGS["voice_label"]))
        self.video_title_label.setText(texts.get("video_title_label", DEFAULT_STRINGS["video_title_label"]))
        self.platform_label.setText(texts.get("platform_label", DEFAULT_STRINGS["platform_label"]))
        self.prompt_label.setText(texts.get("prompt_label", DEFAULT_STRINGS["prompt_label"]))
        self.genre_label.setText(texts.get("genre_label", DEFAULT_STRINGS["genre_label"]))
        self.modify_label.setText(texts.get("modify_label", DEFAULT_STRINGS["modify_label"]))
        self.bypass_label.setText(texts.get("bypass_label", DEFAULT_STRINGS["bypass_label"]))
        self.start_button.setText(texts.get("start_video_btn", DEFAULT_STRINGS["start_video_btn"]))
        self.save_button.setText(texts.get("save_subtitles_btn", DEFAULT_STRINGS["save_subtitles_btn"]))
        self.replace_clip_btn.setText(texts.get("replace_clip_btn", DEFAULT_STRINGS["replace_clip_btn"]))
        self.delete_clip_btn.setText(texts.get("delete_clip_btn", DEFAULT_STRINGS["delete_clip_btn"]))
        self.generate_final_video_btn.setText(
            texts.get("generate_final_video_btn", DEFAULT_STRINGS["generate_final_video_btn"]))
        self.upload_video_btn.setText(texts.get("upload_video_btn", DEFAULT_STRINGS["upload_video_btn"]))
        self.play_video_btn_final.setText(texts.get("play_video_btn_final", DEFAULT_STRINGS["play_video_btn_final"]))

        # Update directory labels.
        self.base_directory_label.setText(texts.get("base_directory_label", DEFAULT_STRINGS["base_directory_label"]))
        self.base_browse_button.setText(texts.get("base_browse_btn", DEFAULT_STRINGS["base_browse_btn"]))
        self.video_image_folder_label.setText(
            texts.get("video_image_folder_label", DEFAULT_STRINGS["video_image_folder_label"]))
        self.output_directory_label.setText(
            texts.get("output_directory_label", DEFAULT_STRINGS["output_directory_label"]))
        self.music_folder_label.setText(texts.get("music_folder_label", DEFAULT_STRINGS["music_folder_label"]))
        self.voiceover_directory_label.setText(
            texts.get("voiceover_directory_label", DEFAULT_STRINGS["voiceover_directory_label"]))

        # Update Status label.
        self.status_label.setText(texts.get("status_label", DEFAULT_STRINGS["status_label"]))

        # Update target language label widget.
        if hasattr(self, "target_language_label_widget"):
            self.target_language_label_widget.setText(
                texts.get("target_language_label", DEFAULT_STRINGS["target_language_label"]))
        else:
            print("target_language_label_widget not defined.")

        # Finally, update the test voice button text.
        self.test_voice_button.setText(texts.get("test_voice_button", DEFAULT_STRINGS["test_voice_button"]))

        # Update tab titles for other tabs.
        self.tabs.setTabText(1, texts.get("review_script_tab", DEFAULT_STRINGS["review_script_tab"]))
        self.tabs.setTabText(2, texts.get("review_clips_tab", DEFAULT_STRINGS["review_clips_tab"]))
        self.tabs.setTabText(3, texts.get("final_video_tab", DEFAULT_STRINGS["final_video_tab"]))

        # Final-Video tab title
        idx = self.tabs.indexOf(self.final_video_tab)
        if idx != -1:
            self.tabs.setTabText(idx,
                                 texts.get("final_video_tab", DEFAULT_STRINGS["final_video_tab"])
                                 )

        # VLC control buttons
        self.play_button.setText(texts.get("play_button", DEFAULT_STRINGS["play_button"]))
        self.pause_button.setText(texts.get("pause_button", DEFAULT_STRINGS["pause_button"]))
        self.forward_button.setText(texts.get("forward_button", DEFAULT_STRINGS["forward_button"]))
        self.backward_button.setText(texts.get("backward_button", DEFAULT_STRINGS["backward_button"]))

        # The big Play Video button
        self.play_video_btn_final.setText(
            texts.get("play_video_btn_final", DEFAULT_STRINGS["play_video_btn_final"])
        )

        # The Upload button
        self.upload_video_btn.setText(
            texts.get("upload_video_btn", DEFAULT_STRINGS["upload_video_btn"])
        )

        # Now update your Yes/No radio buttons

        self.modify_yes.setText(texts.get("yes", DEFAULT_STRINGS["yes"]))
        self.modify_no.setText(texts.get("no", DEFAULT_STRINGS["no"]))
        self.bypass_yes.setText(texts.get("yes", DEFAULT_STRINGS["yes"]))
        self.bypass_no.setText(texts.get("no", DEFAULT_STRINGS["no"]))

        # Store dialog templates for later calls:

        self.coming_soon_title = texts["coming_soon_title"]
        self.coming_soon_msg = texts["coming_soon_msg"]
        self.youtube_shorts_reminder_title = texts["youtube_shorts_reminder_title"]
        self.youtube_shorts_reminder_msg = texts["youtube_shorts_reminder_msg"]
        self.file_not_found_title = texts["file_not_found_title"]
        self.file_not_found_msg = texts["file_not_found_msg"]

        # Now the 5th tab: Support
        support_tab_index = self.tabs.indexOf(self.support_tab)
        if support_tab_index != -1:
            self.tabs.setTabText(support_tab_index, texts.get("support_tab", DEFAULT_STRINGS["support_tab"]))

        self.sr_number_label.setText(texts.get("sr_number_label", DEFAULT_STRINGS["sr_number_label"]))
        self.customer_name_label.setText(
            texts.get("customer_name_label", DEFAULT_STRINGS["customer_name_label"]) + " *")
        self.email_label.setText(texts.get("email_label", DEFAULT_STRINGS["email_label"]) + " *")
        self.phone_label.setText(texts.get("phone_label", DEFAULT_STRINGS["phone_label"]))
        self.ticket_type_label.setText(texts.get("ticket_type_label", DEFAULT_STRINGS["ticket_type_label"]) + " *")
        self.issue_description_label.setText(
            texts.get("issue_description_label", DEFAULT_STRINGS["issue_description_label"]) + " *")
        self.video_name_label.setText(texts.get("video_name_label", DEFAULT_STRINGS["video_name_label"]) + " *")
        self.creation_dt_label.setText(texts.get("creation_dt_label", DEFAULT_STRINGS["creation_dt_label"]) + " *")
        self.desc_label.setText(texts.get("desc_label", DEFAULT_STRINGS["desc_label"]) + " *")
        self.send_button.setText(texts.get("send_button", DEFAULT_STRINGS["send_button"]))

        check_faq_text = texts.get("check_faq_label", DEFAULT_STRINGS["check_faq_label"])
        self.check_faq_label.setText(check_faq_text)

        faq_link = texts.get("faq_link_text", DEFAULT_STRINGS["faq_link_text"])
        self.faq_link_label.setText(f'<a href="{FAQ_LINK}" style="color:blue;">{faq_link}</a>')

        # 1) Retrieve the localized strings for Issue / Enhancement / Comment
        issue_str = texts.get("issue_option", DEFAULT_STRINGS["issue_option"])
        enh_str = texts.get("enh_option", DEFAULT_STRINGS["enh_option"])
        comment_str = texts.get("comment_option", DEFAULT_STRINGS["comment_option"])

        # 2) Remember the current userData or index, so you can preserve selection
        current_data = self.ticket_type_combo.currentData()

        # 3) Clear and re-add items with userData
        self.ticket_type_combo.clear()
        self.ticket_type_combo.addItem(issue_str, userData="issue")
        self.ticket_type_combo.addItem(enh_str, userData="enhancement")
        self.ticket_type_combo.addItem(comment_str, userData="comment")
        # Then connect on_ticket_type_changed
        self.ticket_type_combo.currentIndexChanged.connect(self.on_ticket_type_changed)
        # 4) Restore the previous selection if you like:
        for i in range(self.ticket_type_combo.count()):
            if self.ticket_type_combo.itemData(i) == current_data:
                self.ticket_type_combo.setCurrentIndex(i)
                break
        # 5) For the missing-fields dialog
        #    you can store them if you prefer:
        self.missing_required_title = texts.get("missing_required_title", DEFAULT_STRINGS["missing_required_title"])
        self.missing_required_msg = texts.get("missing_required_msg", DEFAULT_STRINGS["missing_required_msg"])

    def set_video_title(self, text):
        self.video_title = text.strip()

    def update_output_directory(self):
        base_dir = self.base_directory.text().strip()
        if base_dir:
            self.output_directory = os.path.join(base_dir, "OutFiles")
        else:
            self.output_directory = ""

    def on_tab_changed(self, index):
        texts = get_texts_for_current_language(self.target_language_input)

        # Get the current widget and its "tabFunction" property.
        current_widget = self.tabs.widget(index)
        tab_function = current_widget.property("tabFunction")
        print(f"Switching to tab with tabFunction: {tab_function}")

        #  Full-screen / Windowed toggle 
        if tab_function in ("clips", "final_video"):
            # True full-screen:
            #self.showFullScreen()
            # Or, if you prefer maximized with titlebar, uncomment this instead:
            self.showMaximized()
        else:
            # restore to normal window
            self.showNormal()
        # 

        #  Per-tab processing 
        if tab_function == "script":
            # 1) Show the flashing progress dialog
            progress = self.show_progress(
                texts.get("processing_subtitles_message",
                          DEFAULT_STRINGS["processing_subtitles_message"])
            )
            # 2) Optionally override its title
            progress.setWindowTitle(
                texts.get("processing_title",
                          DEFAULT_STRINGS["processing_title"])
            )
            QApplication.processEvents()

            # 3) Do your work
            print("Before load_subtitles")
            self.load_subtitles()
            print("After load_subtitles")

            # 4) Close and clean up
            self._cleanup_progress()

        elif tab_function == "clips":
            # 1) Show the flashing progress dialog
            progress = self.show_progress(
                texts.get("loading_clips_message",
                          DEFAULT_STRINGS["loading_clips_message"])
            )

            # 2) Override the window title if you like
            progress.setWindowTitle(
                texts.get("loading_title",
                          DEFAULT_STRINGS["loading_title"])
            )

            QApplication.processEvents()
            # 3) Do the work
            print("Before load_clips_and_subtitles")
            #self.load_subtitles()
            self.load_clips_and_subtitles()
            print("After load_clips_and_subtitles")

            # 4) Close and clean up the progress UI
            self._cleanup_progress()

        elif tab_function == "final_video":
            # full-screen is already applied above; no extra loading step
            pass

        elif tab_function == "main":
            # now back to windowed, user can build a new video
            print("Main tab selected. (No additional processing required.)")

        else:
            # any other custom tabs
            pass
        # 

    def load_subtitles(self, srt_file_path=None):
        """
        Load subtitles safely when switching tabs.
        If srt_file_path is provided, it is used; else the default is built.
        """
        if not hasattr(self, "subtitles_editor") or self.subtitles_editor is None:
            print(" subtitles_editor is not initialized yet. Skipping load_subtitles().")
            return None  # Prevent crash

        # Ensure video_title is set
        if not hasattr(self, "video_title") or not self.video_title or self.video_title.strip() == "default_video":
            self.video_title = self.video_title_input.text().strip() if self.video_title_input.text().strip() else "default_video"

        # Ensure output_directory is a string (extract text if its a QLineEdit)
        if isinstance(self.output_directory, QLineEdit):
            self.output_directory = self.output_directory.text().strip()
        if not self.output_directory:
            self.output_directory = os.getcwd()  # Default to current directory
            print(f" Warning: output_directory not set, using {self.output_directory}")

        # Build default subtitles file path if not provided
        if srt_file_path is None:
            srt_file_path = os.path.join(self.output_directory, f"{self.video_title}_subtitles.txt")

        print(f" Looking for subtitle file at: {srt_file_path}")

        try:
            if os.path.exists(srt_file_path):
                with open(srt_file_path, "r", encoding="utf-8") as file:
                    subtitle_text = file.read()
                self.subtitles_editor.setText(subtitle_text)
                print(" Subtitles loaded successfully!")
                return subtitle_text.splitlines()  # Return list of lines or however you expect subtitles
            else:
                self.subtitles_editor.setText(f"Subtitle file not found: {srt_file_path}")
                print(" Subtitle file missing!")
                return None
        except Exception as e:
            print(f" Error in load_subtitles(): {e}")
            return None

    def on_voiceover_complete(self):
        print(" Voiceover generation completed! Reloading subtitles...")
        self.load_clips_and_subtitles()

    from PyQt5.QtWidgets import QComboBox, QMessageBox

    def save_and_regenerate(self):
        texts = get_texts_for_current_language(self.target_language_input)
        progress = self.show_progress(
            texts.get("saving_subtitles",
                      DEFAULT_STRINGS["saving_subtitles"])
        )

        try:
            # 1) Ensure output dir
            if not self.output_directory:
                print(" Output directory not set. Cannot save subtitles.")
                return

            # 2) Save the .txt
            subtitles_file = os.path.join(
                self.output_directory,
                f"{self.video_title}_subtitles.txt"
            )
            try:
                with open(subtitles_file, "w", encoding="utf-8") as file:
                    file.write(self.subtitles_editor.toPlainText())
                print(f" Subtitle file successfully saved to: {subtitles_file}")
            except Exception as e:
                print(f" Error saving subtitles: {e}")
                return

            # 3) Pick the voice
            if hasattr(self, "voice_selector") and hasattr(self.voice_selector, "voice_input"):
                vi = self.voice_selector.voice_input
                if isinstance(vi, QComboBox):
                    selected_voice = vi.currentText().strip()
                else:
                    selected_voice = vi.text().strip()
            else:
                print(" Error: Voice selection not initialized!")
                return

            if not selected_voice:
                print(" Error: No voice selected! Please choose a valid voice.")
                return

            print(f" Using voice: {selected_voice} for text-to-speech.")

            # 4) Launch TTS thread
            voice_path = os.path.join(
                self.output_directory,
                f"{self.video_title}_voiceover.mp3"
            )
            self.voiceover_thread = VoiceoverThread(
                self.subtitles_editor.toPlainText(),
                voice_path,
                selected_voice
            )
            # when done, regenerate SRT & reload table
            self.voiceover_thread.finished.connect(
                self._on_voiceover_finished
            )
            self.voiceover_thread.start()

            # 5) Switch tabs immediately (voice is async)
            self.subtitles_tab.setEnabled(False)
            self.clip_sub_tab.setEnabled(True)
            self.tabs.setCurrentIndex(2)  # Clips tab

        except Exception as e:
            QMessageBox.critical(
                self, " Error",
                f" An error occurred during subtitle processing: {e}"
            )
        finally:
            self._cleanup_progress()

    def _on_voiceover_finished(self):
        """
        Called when the voiceover MP3 has finished generating.
        Now the MP3 exists, so we can generate a correct SRT
        and reload the clip/subtitle table.
        """
        print(" Voiceover generation completed!")

        try:
            # regenerate SRT with correct durations
            self.generate_srt()
        except Exception as e:
            print(f" WARNING: generate_srt() failed: {e}")

        try:
            # now parse that new SRT and repopulate the table
            self.load_clips_and_subtitles()
        except Exception as e:
            print(f" WARNING: load_clips_and_subtitles() failed: {e}")


    def load_clips_and_subtitles(self):
        """
        Reloads the clips and subtitles (if available) for the review tab.
        Uses safe_str to avoid calling .text() on a string in bypass mode.
        """
        print("DEBUG: Inside load_clips_and_subtitles.")
        if getattr(self, 'bypass_mode', False):
            print("Bypass mode active; populating review tab with downloaded media only.")
            try:
                # Convert the folder widgets/strings safely to str and strip whitespace
                media_folder = safe_str(self.video_image_folder).strip()
                print(f"Media folder from safe_str: {media_folder}")
                if media_folder and os.path.exists(media_folder):
                    media_files = []
                    try:
                        for f in os.listdir(media_folder):
                            if f.lower().endswith(('.mp4', '.avi', '.mov', '.jpg', '.jpeg', '.png')):
                                media_files.append(os.path.join(media_folder, f))
                    except Exception as list_e:
                        print(f" Error reading media folder: {list_e}")
                else:
                    media_files = []

                # Convert the music folder safely
                music_folder = safe_str(self.music_folder).strip()
                print(f"Music folder from safe_str: {music_folder}")
                if music_folder and os.path.exists(music_folder):
                    music_files = []
                    try:
                        for f in os.listdir(music_folder):
                            if f.lower().endswith('.mp3'):
                                music_files.append(os.path.join(music_folder, f))
                    except Exception as list_e:
                        print(f" Error reading music folder: {list_e}")
                else:
                    music_files = []

                print(f"Found {len(media_files)} media files and {len(music_files)} music files in bypass mode.")

                # Create a placeholder subtitles list (one empty string per media file).
                subtitles = [''] * len(media_files)

                # Store lists as attributes
                self.media_clips = media_files
                self.music_clips = music_files
                self.wip_subtitles = subtitles  # Store subtitles as an instance variable

                # Populate the clips table.
                self.populate_clip_table()  # Use self.media_clips and self.music_clips
                self.clip_table.viewport().update()  # Force UI refresh
                print(" Clips table populated in bypass mode!")
            except Exception as e:
                print(f" Exception while populating clips table in bypass mode: {e}")
            return

        # Normal (non-bypass) branch.
        srt_file = os.path.join(self.output_directory, f"{self.video_title}_subtitles.srt")
        if not os.path.exists(srt_file):
            print(f" Subtitle SRT file not found: {srt_file}")
            return

        try:

            with open(srt_file, "r", encoding="utf-8") as file:
                srt_content = file.readlines()
            subtitles = self.parse_srt(srt_content)
            self.wip_subtitles = subtitles  # Store subtitles as an instance variable

            # Populate the clips table.
            self.populate_clip_table()  # Use self.media_clips and self.music_clips
            self.clip_table.viewport().update()  # Force UI refresh
            print(" Clips and subtitles table updated!")
        except Exception as e:
            print(f" Error loading subtitles: {e}")

    def parse_srt(self, srt_content):
        """ Parses SRT content into subtitle entries for the table. """
        subtitles = []
        index = 0

        while index < len(srt_content):
            try:
                if "-->" in srt_content[index]:  # Timestamp line
                    start_time, end_time = srt_content[index].strip().split(" --> ")
                    subtitle_text = []
                    index += 1

                    # Collect all subtitle lines (handle multi-line subtitles properly)
                    while index < len(srt_content) and srt_content[index].strip():
                        subtitle_text.append(srt_content[index].strip())
                        index += 1

                    # Ensure multi-line subtitles are combined correctly
                    subtitle_text = " ".join(subtitle_text)

                    #  Ensure timestamps are properly formatted as float
                    start_time_seconds = self.convert_srt_timestamp_to_seconds(start_time)
                    end_time_seconds = self.convert_srt_timestamp_to_seconds(end_time)

                    subtitles.append((start_time_seconds, end_time_seconds, subtitle_text))

                index += 1  # Move to the next block
            except IndexError:
                break
            except ValueError as e:
                print(f" Error parsing subtitle at index {index}: {e}")

        print(f" Parsed {len(subtitles)} subtitles from SRT file")
        return subtitles

    def convert_srt_timestamp_to_seconds(self, timestamp):
        """ Convert SRT timestamp format to total seconds (float). Handles both hh:mm:ss,ms and decimal seconds formats. """
        try:
            if ":" in timestamp:  # If it contains ":", it's in hh:mm:ss,ms format
                h, m, s = timestamp.replace(",", ".").split(":")
                return int(h) * 3600 + int(m) * 60 + float(s)
            else:  # It's already in decimal seconds format
                return float(timestamp)
        except Exception as e:
            print(f" Error converting timestamp '{timestamp}': {e}")
            return 0.0


    def generate_srt(self):
        if not self.output_directory:
            print(" Output directory not set. Cannot generate SRT.")
            return

        # 1) Get the script text
        script = self.subtitles_editor.toPlainText().strip()
        if not script:
            print(" No script text found. Aborting SRT generation.")
            return

        # 2) Paths & voiceover duration
        subtitles_file = os.path.join(
            self.output_directory,
            f"{self.video_title}_subtitles.srt"
        )
        voiceover_file = os.path.join(
            self.output_directory,
            f"{self.video_title}_voiceover.mp3"
        )
        voiceover_duration = (
            get_audio_duration(voiceover_file)
            if os.path.exists(voiceover_file)
            else 60.0
        )
        print(f" Generating SRT ({voiceover_duration:.3f}s)  {subtitles_file}")

        try:
            # 3) Split into lines of <= max_line_len chars
            max_line_len = 45
            words = script.split()
            lines = []
            curr = []
            for w in words:
                cand = " ".join(curr + [w])
                if len(cand) <= max_line_len:
                    curr.append(w)
                else:
                    line = " ".join(curr)
                    lines.append(line)
                    print(f"DEBUG: Line {len(lines)} ({len(line)} chars): {line}")
                    curr = [w]
            if curr:
                line = " ".join(curr)
                lines.append(line)
                print(f"DEBUG: Line {len(lines)} ({len(line)} chars): {line}")

            line_count = len(lines)
            if line_count == 0:
                print(" No subtitle lines generated. Aborting.")
                return

            # 4) Evenly divide the voiceover across all lines
            dur_per_line = voiceover_duration / line_count
            print(f"DEBUG: {line_count} lines  {dur_per_line:.3f}s per line")

            # 5) Write the .srt
            with open(subtitles_file, "w", encoding="utf-8") as f:
                start = 0.0
                for idx, text in enumerate(lines):
                    end = start + dur_per_line
                    # snap last line to exact end
                    if idx == line_count - 1:
                        end = voiceover_duration

                    f.write(f"{start:.3f} --> {end:.3f}\n")
                    f.write(text + "\n\n")
                    print(f"DEBUG: wrote block {idx + 1}: {start:.3f}{end:.3f}")
                    start = end

            print(f" SRT file successfully generated: {subtitles_file}")

        except Exception as e:
            print(f" Error generating subtitles: {e}")

    def openPreview(self, file_path, media_type):
        """
        Open a preview for the given media file.
        For images, display the image in a pop-up dialog.
        For video and music, open using the system default application.
        """

        #print(f"DEBUG: Inside openPreview. file_path: {file_path}, media_type: {media_type}")

        if media_type == "Image":
            previewDialog = QDialog(self)
            previewDialog.setWindowTitle("Image Preview: " + os.path.basename(file_path))
            layout = QVBoxLayout(previewDialog)
            label = QLabel(previewDialog)
            pixmap = QPixmap(file_path)
            if pixmap.isNull():
                label.setText("Unable to load image.")
            else:
                label.setPixmap(pixmap.scaled(800, 600, Qt.KeepAspectRatio, Qt.SmoothTransformation))
            layout.addWidget(label)
            previewDialog.resize(800, 600)
            previewDialog.exec_()
        else:
            print(f"DEBUG: Inside openPreview. Before QDesktopServices.openUrl. file_path: {file_path}")
            # For video and music, use the system default application.
            QDesktopServices.openUrl(QUrl.fromLocalFile(file_path))
            #self._player = QMediaPlayer(self)  # keep a reference!
            #self._player.setMedia(QMediaContent(QUrl.fromLocalFile(file_path)))
            #self._player.play()

    # ---------------------------------------------------------------------------
    # Helper method to add directory input.
    def add_directory_input(self, layout, label_text, line_edit, row, browse_action):

        texts = get_texts_for_current_language(self.target_language_input)

        label = QLabel(label_text)
        layout.addWidget(label, row, 0)
        layout.addWidget(line_edit, row, 1)
        if browse_action:
            #browse_button = QPushButton("Browse")
            browse_button = QPushButton(texts.get("browse_button", DEFAULT_STRINGS["browse_button"]))

            browse_button.btn.setStyleSheet(BTN_STYLE)
            browse_button.clicked.connect(browse_action)
            layout.addWidget(browse_button, row, 2)

    # ---------------------------------------------------------------------------
    # Directory browser.
    def browse_base_directory(self):
        folder = QFileDialog.getExistingDirectory(self, "Select Base Directory")
        self.base_directory.setText(folder)

        pass

    # ---------------------------------------------------------------------------

    def update_derived_directories(self):
        # Get the base directory from the base_directory widget.
        base_dir = self.base_directory.text().strip()

        # If base_dir is provided, derive out_dir; otherwise, use a previously stored value or a hard-coded default.
        if base_dir:
            out_dir = f"{base_dir}/OutFiles"
        else:
            stored = getattr(self, "output_directory_path", "").strip()
            if stored:
                out_dir = stored
            else:
                out_dir = "C:/Default/OutFiles"  # Fallback default

        # Force update the output_directory widget to use the derived out_dir.
        try:
            self.output_directory.setText(out_dir)
        except Exception as e:
            # If for some reason self.output_directory is not a widget, log a warning.
            print(" WARNING: Could not call setText on output_directory:", e)

        # Also update the voiceover_directory widget (they should be identical).
        try:
            self.voiceover_directory.setText(out_dir)
        except Exception as e:
            print(" WARNING: Could not call setText on voiceover_directory:", e)

        # Update other related directories if base_dir is provided.
        if base_dir:
            try:
                self.video_image_folder.setText(f"{base_dir}/InVidFiles")
            except Exception as e:
                print(" WARNING: Could not update video_image_folder:", e)
            try:
                self.music_folder.setText(f"{base_dir}/InMusicFiles")
            except Exception as e:
                print(" WARNING: Could not update music_folder:", e)

        # Save the derived out_dir in a separate attribute so it persists.
        self.output_directory_path = out_dir

        print("DEBUG: Derived output_directory:", out_dir)
        print("DEBUG: voiceover_directory:",
              self.voiceover_directory.text() if hasattr(self.voiceover_directory,
                                                         "text") else self.voiceover_directory)

        # Retrieve the video title.
        video_title = self.video_title_input.text().strip() if hasattr(self, "video_title_input") else ""
        update_log_file(out_dir, video_title)

    # ---------------------------------------------------------------------------
    # Test selected voice.
    def test_selected_voice(self, voice_name):
        selected_voice = self.voice_selector.get_selected_voice()
        print(f"Voice name type: {type(voice_name)}")  # Debugging line

        # Ensure voice_name is a string
        if isinstance(voice_name, bool):
            print(" Error: voice_name is a boolean, expected a string.")
            return

        if not isinstance(voice_name, str):
            print(" Error: voice_name is not a string.")
            return

        try:
            communicator = Communicate(text="Hello! This is a voice test. How do I sound?", voice=voice_name)
            print(f"Testing voice: {voice_name}")
            communicator.save("test_voice.mp3")  # Save to file
            os.system("test_voice.mp3")  # Play the audio file
        except Exception as e:
            print(f" Error during voice test: {e}")

    def update_table_row(self, row, new_file, media_type):
        """
        Updates only the specified row in the table after a media file is replaced.
        For Video/Image (columns 06): updates the preview (col 1), media type (col 2),
        file name (col 3), and duration (col 4).
        For Music (columns 712): updates the preview (col 8), file name (col 9),
        and duration (col 10). (The select checkboxes and cumulative timings in columns 7 and 1112
        are handled elsewhere.)
        """
        print(f"DEBUG: Inside update_table_row for row {row} with file: {new_file} and media_type: {media_type}")
        ext = os.path.splitext(new_file)[1].lower()
        video_extensions = {".mp4", ".avi", ".mov", ".mkv"}

        if media_type == "Music":
            # Update Music media type row:
            # (Assuming column 7 holds the Music select checkbox, so leave it as is.)
            # Update preview in column 8.
            old_widget = self.clip_table.cellWidget(row, 8)
            if old_widget is not None:
                self.clip_table.removeCellWidget(row, 8)
                old_widget.deleteLater()
            # Use a music-specific icon. Assume you've loaded it and stored on self.music_icon.
            if hasattr(self, "music_icon"):
                thumbnail = self.music_icon.scaled(100, 75, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            else:
                thumbnail = QPixmap(100, 75)
                thumbnail.fill(Qt.gray)
            prevLabel = ClickablePreviewLabel(new_file, "Music", self)
            prevLabel.setPixmap(thumbnail)
            prevLabel.setToolTip(os.path.basename(new_file))
            self.clip_table.setCellWidget(row, 8, prevLabel)

            # Update music file name in column 9.
            self.clip_table.setItem(row, 9, QTableWidgetItem(os.path.basename(new_file)))
            # Update duration in column 10 using get_audio_duration.
            try:
                m_duration = get_audio_duration(new_file)
            except Exception as e:
                print(f"DEBUG:  Error extracting music duration from {new_file}: {e}")
                m_duration = 0.0
            self.clip_table.setItem(row, 10, QTableWidgetItem(format_seconds(m_duration)))

        else:
            # Process Video or Image update (columns 06).
            is_video = ext in video_extensions
            # Remove any old widget in the media preview cell (column 1).
            old_widget = self.clip_table.cellWidget(row, 1)
            if old_widget is not None:
                self.clip_table.removeCellWidget(row, 1)
                old_widget.deleteLater()

            if is_video:
                thumbnail = self.get_video_thumbnail(new_file)
                if thumbnail is None or thumbnail.isNull():
                    print(f" Error: Could not generate thumbnail for {new_file}. Using default icon.")
                    thumbnail = QPixmap(100, 75)
                    thumbnail.fill(Qt.gray)
                else:
                    # Ensure the thumbnail is scaled correctly
                    thumbnail = thumbnail.scaled(100, 75, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            else:
                thumbnail = QPixmap(new_file)
                if thumbnail.isNull():
                    print(f" Error: Could not load image {new_file}. Using default placeholder.")
                    thumbnail = QPixmap(100, 75)
                    thumbnail.fill(Qt.gray)
                else:
                    thumbnail = thumbnail.scaled(100, 75, Qt.KeepAspectRatio, Qt.SmoothTransformation)

            prevLabel = ClickablePreviewLabel(new_file, media_type, self)
            prevLabel.setPixmap(thumbnail)
            prevLabel.setToolTip(os.path.basename(new_file))
            self.clip_table.setCellWidget(row, 1, prevLabel)

            # Update media type (col 2) and media file (col 3).
            self.clip_table.setItem(row, 2, QTableWidgetItem(media_type))
            self.clip_table.setItem(row, 3, QTableWidgetItem(os.path.basename(new_file)))

            # Update duration: if Video, extract real duration; if Image, use default 5 s.
            if is_video:
                try:
                    with VideoFileClip(new_file) as video_clip:
                        duration = video_clip.duration
                    print(f"DEBUG: Extracted video duration: {duration}s")
                except Exception as e:
                    print(f"DEBUG:  Error extracting duration from video: {e}")
                    duration = 0.0
            else:
                duration = 5.0
            self.clip_table.setItem(row, 4, QTableWidgetItem(format_seconds(duration)))

        print(f"DEBUG: Row {row} updated successfully.")

    def get_video_thumbnail(self, video_path):
        """
        Extracts a frame from the video using ffmpeg to generate a temporary JPEG thumbnail.
        Loads the thumbnail as a QPixmap scaled to 800x450.
        Returns a QPixmap on success or None upon failure.
        """


        try:
            #print(f"DEBUG: Extracting thumbnail via ffmpeg from: {video_path}")

            # Ensure video file exists
            if not os.path.exists(video_path):
                print(f" Error: File does not exist: {video_path}")
                return None

            # Create a temporary file that will hold the JPEG thumbnail
            temp_file = tempfile.NamedTemporaryFile(suffix='.jpg', delete=False)
            temp_path = temp_file.name
            temp_file.close()  # Close the file so ffmpeg can write to it

            # Run ffmpeg to extract the first frame at a higher resolution
            command = ["ffmpeg", "-y", "-i", video_path, "-ss", "00:00:01", "-vframes", "1", "-s", "1280x720",
                       temp_path]
            subprocess.check_call(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

            # Load the temporary JPEG into a QPixmap.
            pixmap = QPixmap(temp_path)
            os.remove(temp_path)  # Clean up temporary file immediately.

            if pixmap.isNull():
                print(f" Error: QPixmap could not load the thumbnail from {video_path}.")
                return None

            # Scale the image to the desired size (800x450). Adjust flags as desired.
            scaled_pix = pixmap.scaled(800, 450, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            #print(f"DEBUG: ffmpeg thumbnail successfully created (size: {scaled_pix.size()}).")
            return scaled_pix

        except subprocess.CalledProcessError as cpe:
            print(f" Error: ffmpeg failed for {video_path} with error: {cpe}")
            return None
        except Exception as e:
            print(f" Exception generating thumbnail for {video_path}: {e}")
            return None

    def update_media_preview(self, row, file_path, media_type):
        """
        Update the preview for the given row in the table.
        """
        try:
            preview_label = ClickablePreviewLabel(file_path, media_type, self)

            if media_type == "Video":
                thumbnail = self.get_video_thumbnail(file_path)
                if thumbnail is None or thumbnail.isNull():
                    print(f" Error: Could not generate thumbnail for {file_path}. Using default icon.")
                    thumbnail = QPixmap(100, 75)
                    thumbnail.fill(Qt.gray)
            else:
                thumbnail = QPixmap(file_path)
                if thumbnail.isNull():
                    print(f" Error: Could not load image {file_path}. Using default placeholder.")
                    thumbnail = QPixmap(100, 75)
                    thumbnail.fill(Qt.gray)
                else:
                    thumbnail = thumbnail.scaled(100, 75, Qt.KeepAspectRatio, Qt.SmoothTransformation)

            preview_label.setPixmap(thumbnail)
            preview_label.setToolTip(os.path.basename(file_path))
            # Force the GUI widget to refresh.
            preview_label.update()
            self.clip_table.setCellWidget(row, 1, preview_label)
            print(f" Successfully updated preview for row {row}: {file_path}")

        except Exception as e:
            print(f" Exception in update_media_preview: {e}")

    # Slot to replace a selected clip.

    def replace_selected_clip(self):
        """
        Replaces a media/image or music file for the selected row.
        Deletes the old file (if under our managed folders), copies the new one in,
        updates lists and UI.
        """
        texts = get_texts_for_current_language(self.target_language_input)
        progress = self.show_progress(
            texts.get("replacing_media", DEFAULT_STRINGS["replacing_media"])
        )
        try:
            row = self.clip_table.currentRow()
            if row < 0:
                QMessageBox.warning(
                    self,
                    texts.get("warning_title", " Warning"),
                    texts.get("select_cell_warning", "Please select a media cell to replace.")
                )
                return

            # Determine if we're replacing music or media
            music_chk = self.clip_table.cellWidget(row, 7)
            is_music = bool(music_chk and music_chk.isChecked())

            # Grab the old path from the correct list
            old_path = None
            if is_music:
                if hasattr(self, "music_clips") and row < len(self.music_clips):
                    old_path = self.music_clips[row]
            else:
                if hasattr(self, "media_clips") and row < len(self.media_clips):
                    old_path = self.media_clips[row]

            # Ask user for new file
            file_filter = (
                "Music Files (*.mp3 *.wav *.flac *.aac *.ogg)"
                if is_music else
                "Media Files (*.mp4 *.avi *.mov *.mkv *.jpg *.jpeg *.png)"
            )
            src, _ = QFileDialog.getOpenFileName(
                self,
                texts.get("select_new_media", "Select New Media File"),
                "",
                file_filter
            )
            if not src:
                return
            src = os.path.normpath(src)

            # Resolve and normalize target folder
            folder = self.music_folder if is_music else self.video_image_folder
            if not isinstance(folder, str) and hasattr(folder, "text"):
                folder = folder.text()
            folder = os.path.normpath(folder)
            os.makedirs(folder, exist_ok=True)

            # Build a unique destination path for the new file
            base, ext = os.path.splitext(os.path.basename(src))
            dest = os.path.join(folder, base + ext)
            count = 1
            while os.path.exists(dest):
                dest = os.path.join(folder, f"{base}_{count}{ext}")
                count += 1

            # ---- NEW: delete the old file from disk if it lives under our folder ----
            if isinstance(old_path, str):
                old_norm = os.path.normpath(old_path)
                # check via commonpath that old_norm is inside folder
                try:
                    if os.path.commonpath([folder, old_norm]) == folder and os.path.isfile(old_norm):
                        os.remove(old_norm)
                except Exception as e:
                    print(f"DEBUG: could not delete old file {old_norm}: {e}")
            # -------------------------------------------------------------------------

            # Copy the new file into place
            shutil.copy2(src, dest)

            # Update the internal lists
            if is_music:
                # ensure list is long enough
                if not hasattr(self, "music_clips") or self.music_clips is None:
                    self.music_clips = [None] * self.clip_table.rowCount()
                self.music_clips[row] = dest
            else:
                if not hasattr(self, "media_clips") or self.media_clips is None:
                    self.media_clips = [None] * self.clip_table.rowCount()
                self.media_clips[row] = dest

                # If its a video, recalc duration
                if ext.lower() in (".mp4", ".avi", ".mov", ".mkv"):
                    try:
                        dur = get_video_duration(dest)
                    except:
                        dur = 0.0
                    if not hasattr(self, "media_durations") or self.media_durations is None:
                        self.media_durations = [0.0] * self.clip_table.rowCount()
                    self.media_durations[row] = dur
                    self.clip_table.setItem(row, 4, QTableWidgetItem(format_seconds(dur)))

            # Refresh the row and UI
            self.update_table_row(row, dest, "Music" if is_music else "Video")
            if music_chk:
                music_chk.setChecked(False)
            vid_chk = self.clip_table.cellWidget(row, 0)
            if vid_chk:
                vid_chk.setChecked(False)

            self.update_table_timings()
            self.update_all_thumbnails()
            self.populate_clip_table()

        except Exception as e:
            QMessageBox.critical(
                self,
                texts.get("error_title", " Error"),
                texts.get("error_replacing_media",
                          "An error occurred while replacing media: {}").format(e)
            )
        finally:
            #progress.close()
            self._cleanup_progress()

    def unload_media_player(self):
        if getattr(self, "player", None) is not None:
            # if you're currently playing a preview or have any loaded media:
            if self.player.state() != QMediaPlayer.StoppedState:
                self.player.stop()
            # Now remove references so the OS frees the file lock
            self.player.setMedia(None)
            self.player.deleteLater()
            self.player = None

    def delete_selected_items(self):
        """
        Deletes any checkedoff media or music files from disk (if in our managed folders),
        removes them from the underlying lists, removes those rows from the table
        (so thumbnails go away!), then refreshes timings/thumbnails for any remainder.
        """
        self.unload_media_player()  # Make sure no active MediaPlayer locks these files

        texts = get_texts_for_current_language(self.target_language_input)
        progress = self.show_progress(texts.get("deleting_clips", DEFAULT_STRINGS["deleting_clips"]))

        try:
            vf = self.video_image_folder
            if not isinstance(vf, str) and hasattr(vf, "text"):
                vf = vf.text()
            vf = os.path.normpath(vf)

            mf = self.music_folder
            if not isinstance(mf, str) and hasattr(mf, "text"):
                mf = mf.text()
            mf = os.path.normpath(mf)

            # 1) Gather rows + store the paths
            media_rows = []
            music_rows = []
            media_paths = []
            music_paths = []

            for r in range(self.clip_table.rowCount()):
                # If media checkbox is checked
                widget0 = self.clip_table.cellWidget(r, 0)
                if widget0 and hasattr(widget0, "isChecked") and widget0.isChecked():
                    media_rows.append(r)
                    if r < len(self.media_clips):
                        media_paths.append(self.media_clips[r])
                    else:
                        media_paths.append(None)

                # If music checkbox is checked
                widget7 = self.clip_table.cellWidget(r, 7)
                if widget7 and hasattr(widget7, "isChecked") and widget7.isChecked():
                    music_rows.append(r)
                    if r < len(self.music_clips):
                        music_paths.append(self.music_clips[r])
                    else:
                        music_paths.append(None)

            if not media_rows and not music_rows:
                QMessageBox.information(
                    self,
                    texts.get("delete_title", "Delete Items"),
                    texts.get("nothing_to_delete", "No media or music selected for deletion.")
                )
                return

            # 2) Remove table rows & internal list entries
            all_rows = sorted(media_rows + music_rows, reverse=True)
            for row_index in all_rows:
                if 0 <= row_index < self.clip_table.rowCount():
                    self.clip_table.removeRow(row_index)

            for r in sorted(media_rows, reverse=True):
                if 0 <= r < len(self.media_clips):
                    del self.media_clips[r]

            for r in sorted(music_rows, reverse=True):
                if 0 <= r < len(self.music_clips):
                    del self.music_clips[r]

            # Give the GUI a moment to finish any ongoing thumbnail generation
            QCoreApplication.processEvents()

            # 3) Delete files on disk (after they are removed from UI references)
            for i, row_index in enumerate(media_rows):
                path = media_paths[i]
                if path and os.path.exists(path):
                    try_delete_file(path, attempts=3, delay=1)

            for i, row_index in enumerate(music_rows):
                path = music_paths[i]
                if path and os.path.exists(path):
                    try_delete_file(path, attempts=3, delay=1)

            # 4) Now re-populate the table for any remaining entries
            self.populate_clip_table()
            self.rebuild_durations_cache_and_update_timings()
            self.update_all_thumbnails()

        except Exception as e:
            QMessageBox.critical(
                self,
                texts.get("error_title", " Error"),
                texts.get("error_deleting_clips", "Error deleting clips: {}").format(e)
            )
        finally:
            self._cleanup_progress()

    def rebuild_durations_cache_and_update_timings(self):
        """Rebuilds durations for media, updates the timing columns."""
        if hasattr(self, "media_clips") and self.media_clips is not None:
            self.media_durations = []
            row_count = self.clip_table.rowCount()
            for row in range(row_count):
                # For video rows, try to get the duration, otherwise default to 0.
                type_item = self.clip_table.item(row, 2)
                media_type = type_item.text().strip().lower() if type_item else ""
                if media_type == "video":
                    if row < len(self.media_clips) and self.media_clips[row]:
                        file_path = (self.media_clips[row] if isinstance(self.media_clips[row], str)
                                     else getattr(self.media_clips[row], "filename", str(self.media_clips[row])))
                        try:
                            duration = get_video_duration(file_path)
                        except Exception as e:
                            print(f" Error recalculating duration for row {row}: {e}")
                            duration = 0.0
                        self.media_durations.append(duration)
                    else:
                        self.media_durations.append(0.0)
                else:
                    item = self.clip_table.item(row, 4)
                    m_dur_text = item.text().strip() if item else "0:00"
                    parts = m_dur_text.split(":")
                    if len(parts) == 2:
                        try:
                            mmin, msec = map(int, parts)
                            duration = mmin * 60 + msec
                        except Exception as e:
                            print(f" Duration parsing error for row {row}: {e}")
                            duration = 0.0
                    else:
                        duration = 0.0
                    self.media_durations.append(duration)
        self.update_table_timings()

    def shift_and_clear_rows(self, rows_to_delete, columns, is_media=False):
        """
        Shift and clear specified columns for the given rows.
        """
        for row in sorted(rows_to_delete):
            for r in range(row, self.clip_table.rowCount() - 1):
                for col in columns:
                    next_item = self.clip_table.item(r + 1, col)
                    if next_item:
                        self.clip_table.setItem(r, col, QTableWidgetItem(next_item.text()))
                    else:
                        self.clip_table.setItem(r, col, QTableWidgetItem(""))

                # Handle widgets separately if needed
                if is_media and 1 in columns:  # Media Preview
                    next_widget = self.clip_table.cellWidget(r + 1, 1)
                    if next_widget:
                        self.clip_table.setCellWidget(r, 1, next_widget)
                    else:
                        self.clip_table.setItem(r, 1, QTableWidgetItem(""))

                if 8 in columns:  # Music Preview
                    next_widget = self.clip_table.cellWidget(r + 1, 8)
                    if next_widget:
                        self.clip_table.setCellWidget(r, 8, next_widget)
                    else:
                        self.clip_table.setItem(r, 8, QTableWidgetItem(""))

            # Clear the last row's specified columns
            for col in columns:
                self.clip_table.setItem(self.clip_table.rowCount() - 1, col, QTableWidgetItem(""))

            # Remove widgets from the last row if needed
            if is_media and 1 in columns:
                self.clip_table.removeCellWidget(self.clip_table.rowCount() - 1, 1)
            if 8 in columns:
                self.clip_table.removeCellWidget(self.clip_table.rowCount() - 1, 8)

    def get_pixmap_from_base64(base64_string):
        """Convert a base64 string to a QPixmap."""
        image_data = base64.b64decode(base64_string)
        pixmap = QPixmap()
        pixmap.loadFromData(image_data)
        return pixmap

    def populate_clip_table_Prev(self):
        """
        Populates the clip table with 16 columns:
          0: Select(Media)  composite widget (checkbox + drag icon)
          1: Media Preview
          2: Media Type
          3: Media File
          4: Media Dur
          5: Media Start
          6: Media End
          7: Select(Music)
          8: Music Preview
          9: Music File
         10: Music Dur
         11: Music Start
         12: Music End
         13: Subtitle
         14: SubStart
         15: SubEnd
        """
        print("DEBUG: Inside populate_clip_table()")

        # Forcibly convert folder references to strings, no matter what they are:
        try:
            self.video_image_folder = safe_str(self.video_image_folder)
            self.music_folder = safe_str(self.music_folder)
        except Exception as e:
            print(f" Exception converting folder references to string in populate_clip_table: {e}")

        texts = get_texts_for_current_language(self.target_language_input)

        # 1) Setup headers
        headers = texts.get("clip_table_headers", DEFAULT_STRINGS["clip_table_headers"])
        self.clip_table.setColumnCount(len(headers))
        self.clip_table.setHorizontalHeaderLabels(headers)
        for col in range(len(headers)):
            hdr_item = self.clip_table.horizontalHeaderItem(col)
            if col in (0, 1, 7, 8):
                hdr_item.setBackground(QBrush(QColor("lightgreen")))
                hdr_item.setToolTip(
                    texts.get("editable_field_tooltip", DEFAULT_STRINGS["editable_field_tooltip"])
                )
            else:
                hdr_item.setBackground(QBrush(QColor("lightgrey")))
                hdr_item.setToolTip(
                    texts.get("readonly_field_tooltip", DEFAULT_STRINGS["readonly_field_tooltip"])
                )

        # 2) Prepare source lists
        media_clips = list(self.media_clips)
        music_clips = list(self.music_clips)
        subtitles = list(self.wip_subtitles)

        max_rows = max(len(media_clips), len(music_clips), len(subtitles))

        # Add 5 extra rows for potential "Add Media/Music" usage
        EXTRA_ROWS = 5
        max_rows += EXTRA_ROWS
        self.clip_table.setRowCount(max_rows)

        # Pad out lists so they match row count
        media_clips += [""] * (max_rows - len(media_clips))
        music_clips += [""] * (max_rows - len(music_clips))
        subtitles += [""] * (max_rows - len(subtitles))

        # 3) Double the row height
        vhdr = self.clip_table.verticalHeader()
        if not hasattr(self, "_base_row_height"):
            self._base_row_height = vhdr.defaultSectionSize()
        vhdr.setDefaultSectionSize(self._base_row_height * 2)

        # 4) Icons & durations
        video_exts = (".mp4", ".avi", ".mov", ".mkv")
        video_icon = get_pixmap_from_base64(video_icon_base64)
        music_icon = get_pixmap_from_base64(music_icon_base64)
        media_durations = []
        music_durations = []

        for row in range(max_rows):
            #  MEDIA (cols 06)
            clip = media_clips[row]
            if clip:
                is_video = clip.lower().endswith(video_exts)
                mtype = "Video" if is_video else "Image"

                # col 0: checkbox + draggable
                self.clip_table.setCellWidget(row, 0, MediaDraggableWidget(clip))

                # col 1: preview thumbnail
                if is_video:
                    thumb = self.get_video_thumbnail(clip) or video_icon
                else:
                    pix = QPixmap(clip)
                    thumb = pix if not pix.isNull() else QPixmap(100, 75)

                thumb = thumb.scaled(100, 75, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                lbl = ClickablePreviewLabel(clip, mtype, self.clip_table)
                lbl.setPixmap(thumb)
                lbl.setToolTip(os.path.basename(clip))
                self.clip_table.setCellWidget(row, 1, lbl)

                # col 2: translated type
                trans = texts.get(mtype.lower(), mtype)
                item = QTableWidgetItem(trans)
                item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 2, item)

                # col 3: filename
                fname = os.path.basename(clip)
                item = QTableWidgetItem(fname)
                item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 3, item)

                # col 4: duration
                if is_video:
                    try:
                        dur = get_video_duration(clip)
                    except:
                        dur = 0.0
                else:
                    dur = 5.0  # default for images
                media_durations.append(dur)
                di = QTableWidgetItem(format_seconds(dur))
                di.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 4, di)

            else:
                # empty slot  Add Media button
                btn = QPushButton(texts.get("add_media_btn", DEFAULT_STRINGS["add_media_btn"]))
                btn.setStyleSheet(BTN_STYLE)
                btn.clicked.connect(lambda _, r=row: self.insert_media_file(r))
                self.clip_table.setCellWidget(row, 0, btn)

                ph = QTableWidgetItem(texts.get("no_file_placeholder", DEFAULT_STRINGS["no_file_placeholder"]))
                ph.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 1, ph)
                for c in (2, 3, 4):
                    txt = "" if c != 3 else texts.get("none_text", DEFAULT_STRINGS["none_text"])
                    it = QTableWidgetItem(txt)
                    it.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                    self.clip_table.setItem(row, c, it)
                media_durations.append(0.0)

            #  MUSIC (cols 712)
            mclip = music_clips[row]
            if mclip:
                # col 7: checkbox
                chk = QCheckBox()
                self.clip_table.setCellWidget(row, 7, chk)

                # col 8: preview
                thumb = music_icon.scaled(100, 75, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                lbl = ClickablePreviewLabel(mclip, "Music", self.clip_table)
                lbl.setPixmap(thumb)
                lbl.setToolTip(os.path.basename(mclip))
                self.clip_table.setCellWidget(row, 8, lbl)

                # col 9: filename
                item = QTableWidgetItem(os.path.basename(mclip))
                item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 9, item)

                # col 10: duration
                try:
                    md = get_audio_duration(mclip)
                except:
                    md = 0.0
                music_durations.append(md)
                di = QTableWidgetItem(format_seconds(md))
                di.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 10, di)
            else:
                btn = QPushButton(texts.get("add_music_btn", DEFAULT_STRINGS["add_music_btn"]))
                btn.setStyleSheet(BTN_STYLE)
                btn.clicked.connect(lambda _, r=row: self.insert_music_file(r))
                self.clip_table.setCellWidget(row, 7, btn)

                ph = QTableWidgetItem(texts.get("no_file_placeholder", DEFAULT_STRINGS["no_file_placeholder"]))
                ph.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 8, ph)
                for c in (9, 10):
                    txt = "" if c != 10 else "0:00"
                    it = QTableWidgetItem(txt)
                    it.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                    self.clip_table.setItem(row, c, it)
                music_durations.append(0.0)

        # 5) Cumulative media times (cols 56)
        cum = 0.0
        for r in range(max_rows):
            si = QTableWidgetItem(format_seconds(cum))
            si.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 5, si)
            cum += media_durations[r]
            ei = QTableWidgetItem(format_seconds(cum))
            ei.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 6, ei)

        # 6) Cumulative music times (cols 1112)
        cum = 0.0
        for r in range(max_rows):
            si = QTableWidgetItem(format_seconds(cum))
            si.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 11, si)
            cum += music_durations[r]
            ei = QTableWidgetItem(format_seconds(cum))
            ei.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 12, ei)

        # 7) Subtitles (cols 1315)
        for r in range(max_rows):
            if r < len(subtitles):
                ent = subtitles[r]
                if isinstance(ent, (list, tuple)) and len(ent) == 3:
                    st, et, txt = ent
                else:
                    st, et, txt = (0.0, 0.0, "")
            else:
                st, et, txt = (0.0, 0.0, "")
            it_txt = QTableWidgetItem(txt)
            it_txt.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 13, it_txt)
            it_st = QTableWidgetItem(format_seconds(st))
            it_st.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 14, it_st)
            it_et = QTableWidgetItem(format_seconds(et))
            it_et.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 15, it_et)

        # 8) Adjust header & column widths
        header = self.clip_table.horizontalHeader()
        header.setStretchLastSection(False)
        for c in range(self.clip_table.columnCount()):
            if c not in (3, 9):
                header.setSectionResizeMode(c, QHeaderView.ResizeToContents)

        # Fixed width for cols 3 & 9: ~40 characters + padding
        fm = self.clip_table.fontMetrics()
        avg_char_w = fm.averageCharWidth()
        MAX_CHARS = 20
        padding = 5
        fixed_w = int(avg_char_w * MAX_CHARS + padding)

        self.clip_table.setColumnWidth(3, fixed_w)
        self.clip_table.setColumnWidth(9, fixed_w)
        header.setSectionResizeMode(3, QHeaderView.Fixed)
        header.setSectionResizeMode(9, QHeaderView.Fixed)

        print("DEBUG: Finished populate_clip_table()")

    def populate_clip_table(self):
        """
        Populates the clip table with 16 columns:
          0: Select(Media)  composite widget (checkbox + drag icon)
          1: Media Preview
          2: Media Type
          3: Media File
          4: Media Dur
          5: Media Start
          6: Media End
          7: Select(Music)
          8: Music Preview
          9: Music File
         10: Music Dur
         11: Music Start
         12: Music End
         13: Subtitle
         14: SubStart
         15: SubEnd
        """
        print("DEBUG: Inside populate_clip_table()")

        # Forcibly convert folder references to strings, no matter what they are:
        try:
            self.video_image_folder = safe_str(self.video_image_folder)
            self.music_folder = safe_str(self.music_folder)
        except Exception as e:
            print(f" Exception converting folder references to string in populate_clip_table: {e}")

        texts = get_texts_for_current_language(self.target_language_input)

        # 1) Setup headers
        headers = texts.get("clip_table_headers", DEFAULT_STRINGS["clip_table_headers"])
        self.clip_table.setColumnCount(len(headers))
        self.clip_table.setHorizontalHeaderLabels(headers)
        for col in range(len(headers)):
            hdr_item = self.clip_table.horizontalHeaderItem(col)
            if col in (0, 1, 7, 8):
                hdr_item.setBackground(QBrush(QColor("lightgreen")))
                hdr_item.setToolTip(
                    texts.get("editable_field_tooltip", DEFAULT_STRINGS["editable_field_tooltip"])
                )
            else:
                hdr_item.setBackground(QBrush(QColor("lightgrey")))
                hdr_item.setToolTip(
                    texts.get("readonly_field_tooltip", DEFAULT_STRINGS["readonly_field_tooltip"])
                )

        # 2) Prepare source lists
        media_clips = list(self.media_clips)
        music_clips = list(self.music_clips)
        subtitles = list(self.wip_subtitles)

        max_rows = max(len(media_clips), len(music_clips), len(subtitles))

        # Add 5 extra rows for potential "Add Media/Music" usage
        EXTRA_ROWS = 5
        max_rows += EXTRA_ROWS
        self.clip_table.setRowCount(max_rows)

        # Pad out lists so they match row count
        media_clips += [""] * (max_rows - len(media_clips))
        music_clips += [""] * (max_rows - len(music_clips))
        subtitles += [""] * (max_rows - len(subtitles))

        # 3) Double the row height
        vhdr = self.clip_table.verticalHeader()
        if not hasattr(self, "_base_row_height"):
            self._base_row_height = vhdr.defaultSectionSize()
        vhdr.setDefaultSectionSize(self._base_row_height * 2)

        # 4) Icons & durations
        video_exts = (".mp4", ".avi", ".mov", ".mkv")
        video_icon = get_pixmap_from_base64(video_icon_base64)
        music_icon = get_pixmap_from_base64(music_icon_base64)
        media_durations = []
        music_durations = []

        for row in range(max_rows):
            #  MEDIA (cols 06)
            clip = media_clips[row]
            if clip:
                is_video = clip.lower().endswith(video_exts)
                mtype = "Video" if is_video else "Image"

                # col 0: checkbox + draggable
                self.clip_table.setCellWidget(row, 0, MediaDraggableWidget(clip))

                # col 1: preview thumbnail
                if is_video:
                    thumb = self.get_video_thumbnail(clip) or video_icon
                else:
                    pix = QPixmap(clip)
                    thumb = pix if not pix.isNull() else QPixmap(100, 75)

                thumb = thumb.scaled(100, 75, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                lbl = ClickablePreviewLabel(clip, mtype, self.clip_table)
                lbl.setPixmap(thumb)
                lbl.setToolTip(os.path.basename(clip))
                self.clip_table.setCellWidget(row, 1, lbl)

                # col 2: translated type
                trans = texts.get(mtype.lower(), mtype)
                item = QTableWidgetItem(trans)
                item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 2, item)

                # col 3: filename
                fname = os.path.basename(clip)
                item = QTableWidgetItem(fname)
                item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 3, item)

                # col 4: duration
                if is_video:
                    try:
                        dur = get_video_duration(clip)
                    except:
                        dur = 0.0
                else:
                    dur = 5.0  # default for images
                media_durations.append(dur)
                di = QTableWidgetItem(format_seconds(dur))
                di.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 4, di)

            else:
                # empty slot  Add Media button
                btn = QPushButton(texts.get("add_media_btn", DEFAULT_STRINGS["add_media_btn"]))
                btn.setStyleSheet(BTN_STYLE)
                btn.clicked.connect(lambda _, r=row: self.insert_media_file(r))
                self.clip_table.setCellWidget(row, 0, btn)

                ph = QTableWidgetItem(texts.get("no_file_placeholder", DEFAULT_STRINGS["no_file_placeholder"]))
                ph.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 1, ph)
                for c in (2, 3, 4):
                    txt = "" if c != 3 else texts.get("none_text", DEFAULT_STRINGS["none_text"])
                    it = QTableWidgetItem(txt)
                    it.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                    self.clip_table.setItem(row, c, it)
                media_durations.append(0.0)

            #  MUSIC (cols 712)
            mclip = music_clips[row]
            if mclip:
                # col 7: checkbox
                chk = QCheckBox()
                self.clip_table.setCellWidget(row, 7, chk)

                # col 8: preview
                thumb = music_icon.scaled(100, 75, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                lbl = ClickablePreviewLabel(mclip, "Music", self.clip_table)
                lbl.setPixmap(thumb)
                lbl.setToolTip(os.path.basename(mclip))
                self.clip_table.setCellWidget(row, 8, lbl)

                # col 9: filename
                item = QTableWidgetItem(os.path.basename(mclip))
                item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 9, item)

                # col 10: duration
                try:
                    md = get_audio_duration(mclip)
                except:
                    md = 0.0
                music_durations.append(md)
                di = QTableWidgetItem(format_seconds(md))
                di.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 10, di)
            else:
                btn = QPushButton(texts.get("add_music_btn", DEFAULT_STRINGS["add_music_btn"]))
                btn.setStyleSheet(BTN_STYLE)
                btn.clicked.connect(lambda _, r=row: self.insert_music_file(r))
                self.clip_table.setCellWidget(row, 7, btn)

                ph = QTableWidgetItem(texts.get("no_file_placeholder", DEFAULT_STRINGS["no_file_placeholder"]))
                ph.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.clip_table.setItem(row, 8, ph)
                for c in (9, 10):
                    txt = "" if c != 10 else "0:00"
                    it = QTableWidgetItem(txt)
                    it.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                    self.clip_table.setItem(row, c, it)
                music_durations.append(0.0)

        # 5) Cumulative media times (cols 56)
        cum = 0.0
        for r in range(max_rows):
            si = QTableWidgetItem(format_seconds(cum))
            si.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 5, si)
            cum += media_durations[r]
            ei = QTableWidgetItem(format_seconds(cum))
            ei.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 6, ei)

        # 6) Cumulative music times (cols 1112)
        cum = 0.0
        for r in range(max_rows):
            si = QTableWidgetItem(format_seconds(cum))
            si.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 11, si)
            cum += music_durations[r]
            ei = QTableWidgetItem(format_seconds(cum))
            ei.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 12, ei)

        # 7) Subtitles (cols 1315)
        for r in range(max_rows):
            if r < len(subtitles):
                ent = subtitles[r]
                if isinstance(ent, (list, tuple)) and len(ent) == 3:
                    st, et, txt = ent
                else:
                    st, et, txt = (0.0, 0.0, "")
            else:
                st, et, txt = (0.0, 0.0, "")
            it_txt = QTableWidgetItem(txt)
            it_txt.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 13, it_txt)
            it_st = QTableWidgetItem(format_seconds(st))
            it_st.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 14, it_st)
            it_et = QTableWidgetItem(format_seconds(et))
            it_et.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.clip_table.setItem(r, 15, it_et)

        # 8) Adjust header & column widths
        header = self.clip_table.horizontalHeader()
        header.setStretchLastSection(False)
        for c in range(self.clip_table.columnCount()):
            if c not in (3, 9):
                header.setSectionResizeMode(c, QHeaderView.ResizeToContents)

        # Fixed width for cols 3 & 9: ~40 characters + padding
        fm = self.clip_table.fontMetrics()
        avg_char_w = fm.averageCharWidth()
        MAX_CHARS = 20
        padding = 5
        fixed_w = int(avg_char_w * MAX_CHARS + padding)

        self.clip_table.setColumnWidth(3, fixed_w)
        self.clip_table.setColumnWidth(9, fixed_w)
        header.setSectionResizeMode(3, QHeaderView.Fixed)
        header.setSectionResizeMode(9, QHeaderView.Fixed)


        header = self.clip_table.horizontalHeader()
        for col in range(self.clip_table.columnCount()):
            if col in (3, 9, 13):  # Columns likely to contain long text
                header.setSectionResizeMode(col, QHeaderView.Stretch)
            else:
                header.setSectionResizeMode(col, QHeaderView.ResizeToContents)

        print("DEBUG: Finished populate_clip_table()")


    def update_all_thumbnails(self):
        """
        Updates thumbnails for all media files in the media_clips list.
        """
        for row, file_path in enumerate(self.media_clips):
            if file_path:  # Ensure the file path is valid
                thumbnail = self.get_video_thumbnail(file_path) if file_path.endswith(
                    ('.mp4', '.avi', '.mov', '.mkv')) else QPixmap(file_path)
                if thumbnail is None or thumbnail.isNull():
                    print(f" Error: Could not generate thumbnail for {file_path}. Using default icon.")
                    thumbnail = QPixmap(100, 75)
                    thumbnail.fill(Qt.gray)
                else:
                    thumbnail = thumbnail.scaled(100, 75, Qt.KeepAspectRatio, Qt.SmoothTransformation)

                # Update the preview label in the table
                preview_label = ClickablePreviewLabel(file_path, "Video" if file_path.endswith(
                    ('.mp4', '.avi', '.mov', '.mkv')) else "Image", self)
                preview_label.setPixmap(thumbnail)
                preview_label.setToolTip(os.path.basename(file_path))
                self.clip_table.setCellWidget(row, 1, preview_label)

        print(" All thumbnails updated.")

    def insert_media_file(self, row):
        """
        Opens a dialog to pick a video/image, copies it into the normalized
        self.video_image_folder, and updates self.media_clips.
        """
        texts = get_texts_for_current_language(self.target_language_input)
        progress = self.show_progress(texts.get("inserting_media", DEFAULT_STRINGS["inserting_media"]))
        try:
            # 1) Figure out where to store media
            vf = self.video_image_folder
            if not isinstance(vf, str) and hasattr(vf, "text"):
                vf = vf.text()
            vf = os.path.normpath(vf)
            os.makedirs(vf, exist_ok=True)

            # 2) Pick source file
            file_filter = "Media Files (*.mp4 *.avi *.mov *.mkv *.jpg *.jpeg *.png)"
            src, _ = QFileDialog.getOpenFileName(self,
                                                 texts.get("select_media", "Select Media File"),
                                                 "", file_filter
                                                 )
            if not src:
                return
            src = os.path.normpath(src)

            # 3) Build unique destination path
            base, ext = os.path.splitext(os.path.basename(src))
            dest = os.path.join(vf, f"{base}{ext}")
            count = 1
            while os.path.exists(dest):
                dest = os.path.join(vf, f"{base}_{count}{ext}")
                count += 1

            # 4) Copy and record
            shutil.copy2(src, dest)
            if not hasattr(self, "media_clips") or self.media_clips is None:
                self.media_clips = []
            while len(self.media_clips) <= row:
                self.media_clips.append(None)
            self.media_clips[row] = dest

            # 5) Refresh UI
            self.populate_clip_table()
            self.update_all_thumbnails()

        except Exception as e:
            QMessageBox.critical(
                self,
                texts.get("error_title", " Error"),
                texts.get("error_inserting_media", "Error inserting media: {}").format(e)
            )
        finally:
            #progress.close()
            self._cleanup_progress()

    def insert_music_file(self, row):
        """
        Opens a dialog to pick a music file, copies it into the normalized
        self.music_folder, and updates self.music_clips.
        """
        texts = get_texts_for_current_language(self.target_language_input)
        progress = self.show_progress(texts.get("inserting_music", DEFAULT_STRINGS["inserting_music"]))
        try:
            # 1) Resolve music folder
            mf = self.music_folder
            if not isinstance(mf, str) and hasattr(mf, "text"):
                mf = mf.text()
            mf = os.path.normpath(mf)
            os.makedirs(mf, exist_ok=True)

            # 2) Pick source file
            file_filter = "Music Files (*.mp3 *.wav *.flac *.aac *.ogg)"
            src, _ = QFileDialog.getOpenFileName(self,
                                                 texts.get("select_music", "Select Music File"),
                                                 "", file_filter
                                                 )
            if not src:
                return
            src = os.path.normpath(src)

            # 3) Unique destination
            base, ext = os.path.splitext(os.path.basename(src))
            dest = os.path.join(mf, f"{base}{ext}")
            count = 1
            while os.path.exists(dest):
                dest = os.path.join(mf, f"{base}_{count}{ext}")
                count += 1

            # 4) Copy and record
            shutil.copy2(src, dest)
            if not hasattr(self, "music_clips") or self.music_clips is None:
                self.music_clips = []
            while len(self.music_clips) <= row:
                self.music_clips.append(None)
            self.music_clips[row] = dest

            # 5) Refresh UI
            self.populate_clip_table()

        except Exception as e:
            QMessageBox.critical(
                self,
                texts.get("error_title", " Error"),
                texts.get("error_inserting_music", "Error inserting music: {}").format(e)
            )
        finally:
            #progress.close()
            self._cleanup_progress()

    def get_audio_duration(file_path):
        """
        Returns the duration of an audio file in seconds.
        """
        try:
            audio = AudioFileClip(file_path)
            return audio.duration
        except Exception as e:
            print(f" Error getting audio duration: {e}")
            return 0.0

    def update_table_timings(self):
        """
        Recalculates cumulative timings for Media (columns 56) and Music (columns 1112)
        based on the durations in the table.
        For video rows (from Column 2), this function first checks for a cached duration in self.media_durations.
        If the cached duration is zero, it attempts to re-read it from the underlying media_clips list.
        Falls back on the current Column 4 value if needed.
        """
        row_count = self.clip_table.rowCount()
        media_durations = []
        music_durations = []

        for row in range(row_count):
            # Determine media type from Column 2.
            type_item = self.clip_table.item(row, 2)
            media_type = type_item.text().strip().lower() if type_item is not None else ""
            duration = 0.0

            if media_type == "video" and hasattr(self, "media_clips") and row < len(self.media_clips) and \
                    self.media_clips[row]:
                # Prefer cached duration for replaced videos.
                if hasattr(self, "media_durations") and row < len(self.media_durations) and self.media_durations[row]:
                    duration = self.media_durations[row]
                else:
                    # Fall back on computing from the file.
                    media_entry = self.media_clips[row]
                    file_path = media_entry if isinstance(media_entry, str) else getattr(media_entry, "filename",
                                                                                         str(media_entry))
                    try:
                        duration = get_video_duration(file_path)
                    except Exception as e:
                        print(f" Error getting video duration for row {row}: {e}")
                        duration = 0.0
                    # Optionally cache this result.
                    if not hasattr(self, "media_durations") or self.media_durations is None:
                        self.media_durations = [0.0] * row_count
                    if row < len(self.media_durations):
                        self.media_durations[row] = duration
            else:
                # For non-video rows or if duration isnt available, use Column 4.
                item = self.clip_table.item(row, 4)
                m_dur_text = item.text() if item is not None else "0:00"
                try:
                    mmin, msec = map(int, m_dur_text.split(":"))
                    duration = mmin * 60 + msec
                except Exception:
                    duration = 0.0

            media_durations.append(duration)

            # Read Music duration (from Column 10).
            item = self.clip_table.item(row, 10)
            mus_dur_text = item.text() if item is not None else "0:00"
            try:
                mmin, msec = map(int, mus_dur_text.split(":"))
                music_dur = mmin * 60 + msec
            except Exception:
                music_dur = 0.0
            music_durations.append(music_dur)

        # Update cumulative media timings (columns 5 and 6).
        cum_media = 0.0
        for row in range(row_count):
            self.clip_table.setItem(row, 5, QTableWidgetItem(format_seconds(cum_media)))
            cum_media += media_durations[row]
            self.clip_table.setItem(row, 6, QTableWidgetItem(format_seconds(cum_media)))

        # Update cumulative music timings (columns 11 and 12).
        cum_music = 0.0
        for row in range(row_count):
            self.clip_table.setItem(row, 11, QTableWidgetItem(format_seconds(cum_music)))
            cum_music += music_durations[row]
            self.clip_table.setItem(row, 12, QTableWidgetItem(format_seconds(cum_music)))

    # --- Modified workflow methods to store instance variables ---
    def create_video_with_audio_and_subtitles(self, video_title, subtitles, platform, video_image_folder, music_folder,
                                              output_directory):

        # Store relevant file paths as instance attributes.
        self.voiceover_file = os.path.join(output_directory, f"{video_title}_voiceover.mp3")
        self.subtitles_file = os.path.join(output_directory, f"{video_title}_subtitles.srt")
        self.final_video_file = os.path.join(output_directory, f"{video_title}_{platform}.mp4")

        video_files = sorted([os.path.join(video_image_folder, f) for f in os.listdir(video_image_folder)
                              if f.endswith(('.mp4', '.avi', '.mov'))])
        image_files = sorted([os.path.join(video_image_folder, f) for f in os.listdir(video_image_folder)
                              if f.endswith(('.jpg', '.jpeg', '.png'))])
        if not video_files and not image_files:
            self.status_text.appendPlainText(f" No video or image files found in {video_image_folder}")
            return


        self.platform_settings = output_settings.get(platform, output_settings['youtube'])
        if not self.platform_settings or 'resolution' not in self.platform_settings:
            raise ValueError(f" Invalid platform settings for {platform}.")
        self.resolution = self.platform_settings['resolution']

        # Process video files into clips.
        self.video_clips = []  # store media clips
        for video_file in video_files:
            try:
                video_clip = VideoFileClip(video_file)
                video_clip_resized = resize_clip(video_clip, self.resolution)
                if video_clip_resized is not None:
                    # For video clips, the filename attribute is assumed to be part of the clip
                    video_clip_resized.filename = video_file
                    self.video_clips.append(video_clip_resized)
                # IMPORTANT: close the original clip after resizing
                video_clip.close()
            except Exception as e:
                self.status_text.appendPlainText(f" Error processing video file {video_file}: {e}")

        # Process image files into clips.
        for image_file in image_files:
            try:
                from PIL import Image
                with Image.open(image_file) as img:
                    img_aspect_ratio = img.width / img.height
                    target_aspect_ratio = self.resolution[0] / self.resolution[1]
                    if img_aspect_ratio > target_aspect_ratio:
                        new_width = int(self.resolution[1] * img_aspect_ratio)
                        new_height = self.resolution[1]
                    else:
                        new_width = self.resolution[0]
                        new_height = int(self.resolution[0] / img_aspect_ratio)
                    img_resized = img.resize((new_width, new_height), Image.ANTIALIAS)
                    # Save the resized image to a temporary file.
                    temp_image_path = f"{image_file}_resized.png"
                    img_resized.save(temp_image_path)
                # Create an ImageClip using the temporary file.
                image_clip = ImageClip(temp_image_path, duration=5).resize(newsize=self.resolution)
                # IMPORTANT: assign the original image file's name (or the temp image path) to an attribute.
                image_clip.filename = image_file
                self.video_clips.append(image_clip)
            except Exception as e:
                self.status_text.appendPlainText(f" Error processing image file {image_file}: {e}")

        if not self.video_clips:
            self.status_text.appendPlainText(" No valid clips could be processed.")
            return

        # Read script and determine voiceover duration.
        script_file = os.path.join(output_directory, f"{video_title}_subtitles.txt")
        script = read_script_file(script_file)
        self.voiceover_duration = get_audio_duration(self.voiceover_file)
        if self.voiceover_duration <= 0:
            self.status_text.appendPlainText(" Invalid voiceover duration. Aborting.")
            return

        self.wip_subtitles = generate_subtitles_local(script, self.subtitles_file, self.voiceover_duration)
        self.subtitle_clips = []
        fontsize = 70 if self.resolution[0] >= 1280 else 48
        video_height = self.resolution[1]
        y_position = video_height * 0.75

        print(f"Inside create_video_with_audio_and_subtitles font: {font}")

        for sub in self.wip_subtitles:
            text_clip = (TextClip(sub[2], fontsize=fontsize, color='white', font=font,
                                  stroke_color='black', stroke_width=2)
                         .set_position(('center', y_position))
                         .set_duration(sub[1] - sub[0])
                         .set_start(sub[0]))
            self.subtitle_clips.append(text_clip)

        # Process Music: get music files from the folder and assign to self.music_clips.
        music_files = sorted([os.path.join(music_folder, f) for f in os.listdir(music_folder)
                              if f.endswith('.mp3')])
        if not music_files:
            self.status_text.appendPlainText(" No music files found; setting music clips as empty list.")
            self.music_clips = []
        else:
            self.music_clips = music_files  # For the table, we'll use the file paths

        # Populate the table with media clips, music clips, and subtitles.

        print("Before Review Content....")
        # Close any references.
        for clip in self.video_clips:
            # If it's a real video clip with a .reader
            if hasattr(clip, 'reader') and clip.reader is not None:
                if hasattr(clip.reader, 'close') and callable(clip.reader.close):
                    clip.reader.close()

            # If it has an audio reader
            if hasattr(clip, 'audio') and clip.audio and hasattr(clip.audio, 'reader'):
                if clip.audio.reader and hasattr(clip.audio.reader, 'close') and callable(clip.audio.reader.close):
                    clip.audio.reader.close()

        # Show the review notice, as before
        self.request_review_notice(callback=self.continue_video_creation)
        return

    def load_srt_file(self, srt_file):
        """ Ensures we always load the latest SRT file. """
        try:
            with open(srt_file, "r", encoding="utf-8") as file:
                return file.readlines()
        except FileNotFoundError:
            print(f" SRT file not found: {srt_file}")
            return None

    def continue_video_creation_bypass(self):
        """
        Callback invoked after the user reviews the downloaded media in bypass mode.
        This method converts the instance media lists into lists of file paths (filtering out empty placeholders),
        then loads and concatenates those clips to create the final video.
        """
        texts = get_texts_for_current_language(self.target_language_input)
        try:
            # Convert self.media_clips to a list of valid file paths.
            media_file_paths = []
            for clip in self.media_clips:
                if isinstance(clip, str):
                    cp = clip.strip()
                    if cp:
                        media_file_paths.append(cp)
                elif hasattr(clip, "filename"):
                    cp = clip.filename
                    if cp and cp.strip():
                        media_file_paths.append(cp)
                else:
                    print(" Warning: Cannot determine file path for a media clip; skipping.")

            # Do the same for self.music_clips.
            music_file_paths = []
            for mf in self.music_clips:
                if isinstance(mf, str):
                    mp = mf.strip()
                    if mp:
                        music_file_paths.append(mp)
                elif hasattr(mf, "filename"):
                    mp = mf.filename
                    if mp and mp.strip():
                        music_file_paths.append(mp)
                else:
                    print(" Warning: Cannot determine file path for a music clip; skipping.")

            print("Final media list:", media_file_paths)
            print("Final music list:", music_file_paths)

            # Continue using the file paths for the final video creation.
            base_directory = self.base_directory.text()
            video_title = self.video_title_input.text() if hasattr(self, "video_title_input") else "video"
            video_image_folder = os.path.join(base_directory, "InVidFiles")
            music_folder = os.path.join(base_directory, "InMusicFiles")
            output_directory = os.path.join(base_directory, "OutFiles")

            default_platform = next(iter(output_settings))
            platform = self.platform_input.currentText().strip()
            platform_settings = output_settings.get(platform, output_settings[default_platform])
            resolution = platform_settings['resolution']
            final_video_file = os.path.join(output_directory, f"{video_title}_{platform}.mp4")

            # Build a list of video clips from media_file_paths.
            video_clips = []
            videoExtensions = {".mp4", ".avi", ".mov", ".mkv"}
            for file_path in media_file_paths:
                ext = os.path.splitext(file_path)[1].lower()
                if ext in videoExtensions:
                    try:
                        print(f"Loading video file: {file_path}")
                        clip = VideoFileClip(file_path)
                        clip_resized = resize_clip(clip, resolution)
                        if clip_resized is not None:
                            video_clips.append(clip_resized)
                        else:
                            print(f"Clip {file_path} could not be resized.")
                    except Exception as e:
                        print(f" Error processing video file {file_path}: {e}")
                else:
                    # For image files, load via PIL and convert to a clip.
                    try:
                        from PIL import Image
                        with Image.open(file_path) as img:
                            img_aspect_ratio = img.width / img.height
                            target_aspect_ratio = resolution[0] / resolution[1]
                            if img_aspect_ratio > target_aspect_ratio:
                                new_width = int(resolution[1] * img_aspect_ratio)
                                new_height = resolution[1]
                            else:
                                new_width = resolution[0]
                                new_height = int(resolution[0] / img_aspect_ratio)
                            img_resized = img.resize((new_width, new_height), Image.ANTIALIAS)
                            # Save a temporary file
                            temp_image_path = file_path + "_resized.png"
                            img_resized.save(temp_image_path)
                        from moviepy.editor import ImageClip
                        clip = ImageClip(temp_image_path, duration=5).resize(newsize=resolution)
                        video_clips.append(clip)
                    except Exception as e:
                        print(f" Error processing image file {file_path}: {e}")

            if not video_clips:
                print("No valid video or image clips could be processed.")
                return

            # Similarly, process music files to create a list of AudioFileClip objects:
            music_clips = []
            from moviepy.editor import AudioFileClip, concatenate_audioclips
            for file_path in music_file_paths:
                try:
                    audio_clip = AudioFileClip(file_path)
                    music_clips.append(audio_clip)
                except Exception as e:
                    print(f" Error loading audio file {file_path}: {e}")

            # Concatenate video clips.
            from moviepy.editor import concatenate_videoclips, CompositeAudioClip
            final_video = concatenate_videoclips(video_clips, method="compose")
            total_duration = sum(clip.duration for clip in video_clips)
            final_video = final_video.set_duration(total_duration)

            # For music, concatenate audio clips if any. (You may wish to adjust volume etc.)
            if music_clips:
                background_music = concatenate_audioclips(music_clips)
                background_music = background_music.volumex(0.2)
                final_audio = CompositeAudioClip([background_music.set_duration(final_video.duration)])
                final_audio = final_audio.set_duration(final_video.duration)
                final_video = final_video.set_audio(final_audio)

            final_video.write_videofile(final_video_file, codec=platform_settings['codec'],
                                        audio_codec='aac', fps=platform_settings['fps'])
            self._cleanup_progress()
            #QMessageBox.information(self, "Success", "Video creation completed successfully (bypass mode).")
            QMessageBox.information(self, texts.get("success_text", DEFAULT_STRINGS["success_text"]),
                                    texts.get("video_success_bypass", DEFAULT_STRINGS["video_success_bypass"]))

            texts.get("video_success_bypass", DEFAULT_STRINGS["video_success_bypass"])

        except Exception as e:
            print(f" Error in bypass finalization: {e}")

    def continue_video_creation(self):

        texts = get_texts_for_current_language(self.target_language_input)
        print("Inside continue_video_creation and Before update_table_timings.")
        self.update_table_timings()  # refresh timings from the table
        print("After update_table_timings.")
        #self.status_text.appendPlainText("User confirmed review; continuing video creation...")
        print("User confirmed review; continuing video creation...")

        import time
        time.sleep(1)  # slight delay

        # Use self.subtitles_file if available; otherwise, build a default SRT file path.
        if hasattr(self, "subtitles_file") and self.subtitles_file:
            srt_file_path = self.subtitles_file
        else:
            # Ensure you are getting the text from QLineEdit
            output_directory_text = self.output_directory.text().strip()  # Correctly retrieve the text
            srt_file_path = os.path.join(output_directory_text,
                                         f"{self.video_title_input.text().strip()}_subtitles.srt")
        print(f" Loading latest subtitles from {srt_file_path}")
        try:
            subtitles = self.load_subtitles(srt_file_path)
        except Exception as e:
            print(f" Exception loading subtitles: {e}")
            return
        if not subtitles:
            print(" Error: No subtitles found.")
            return

        # Convert self.media_clips into a list of file paths.
        media_file_paths = []
        for clip in self.media_clips:
            if isinstance(clip, str):
                media_file_paths.append(clip)
            elif hasattr(clip, "filename"):
                media_file_paths.append(clip.filename)
            else:
                print(" Warning: Cannot determine file path for a media clip; skipping.")

        # Do the same for self.music_clips.
        music_file_paths = []
        for mf in self.music_clips:
            if isinstance(mf, str):
                music_file_paths.append(mf)
            elif hasattr(mf, "filename"):
                music_file_paths.append(mf.filename)
            else:
                print(" Warning: Cannot determine file path for a music clip; skipping.")

        # Prepare arguments for the child process.
        from multiprocessing import Process
        args = (
            media_file_paths,  # list of media file paths (strings)
            srt_file_path,  # subtitle file path (string)
            self.voiceover_file,  # Voiceover file
            music_file_paths,  # list of music file paths (strings)
            self.final_video_file,
            self.platform_settings
        )
        p = Process(target=encode_video, args=args)
        p.start()
        p.join()
        if p.exitcode == 0:
            #  after you append to your log 
            self._cleanup_progress()
            self.status_text.appendPlainText(
                texts.get("video_success", DEFAULT_STRINGS["video_success"])
            )

            # Build the two strings

            msg = texts.get("video_success", DEFAULT_STRINGS["video_success"])
            title = texts.get("success_text", DEFAULT_STRINGS["success_text"])

            # 1) Show your custom progress dialog
            progress = self.show_progress(msg)

            # 2) Override the title to Success
            progress.setWindowTitle(title)

            # 3) Autoclose it after, say, 1.5 seconds
            QTimer.singleShot(1500, self._cleanup_progress)
            final_text = f"{texts.get('video_success', DEFAULT_STRINGS['video_success'])}: {self.final_video_file}"
            self.status_text.appendPlainText(final_text)
        else:
            self.status_text.appendPlainText(" Error encoding video in separate process.")
            from PyQt5.QtWidgets import QMessageBox
            QMessageBox.critical(self, " Error", " Error encoding video in separate process.")

    def on_encoding_finished(self, success, message):
        texts = get_texts_for_current_language(self.target_language_input)
        self.status_text.appendPlainText(message)
        from PyQt5.QtWidgets import QMessageBox
        texts = get_texts_for_current_language(self.target_language_input)

        if success:

            # Pick your localized video created message
            msg = texts.get(
                "video_success",
                DEFAULT_STRINGS["video_success"]
            )
            final_text = f"{texts.get('video_success', DEFAULT_STRINGS['video_success'])}: {final_video_file}"
            self.status_text.appendPlainText(final_text)
        else:
            # Use the raw error text (you could also localize this)
            msg = message

        # 1) show a styled, flashingtext dialog
        progress = self.show_progress(msg)

        # 2) optionally override the window title
        title_key = "success_text" if success else "error_text"
        title = texts.get(title_key, DEFAULT_STRINGS.get(title_key, title_key))
        progress.setWindowTitle(title)

        # 3) close it automatically after 1.5s
        QTimer.singleShot(1500, self._cleanup_progress)


    def request_review_notice(self, callback=None):
        """
        Show an info message telling the user to review the content.
        Both in bypass and non-bypass mode, this is purely informational.
        No final video creation is triggered here.
        """
        print("DEBUG: Inside request_review_notice.")

        # If desired, short delay to let the UI render first.
        if not getattr(self, 'bypass_mode', False):
            QTimer.singleShot(150, self._show_review_dialog)
        else:
            self._show_review_dialog()

    def _show_review_dialog(self):
        """
        Actually build & show the QMessageBox. In all modes, "OK" just dismisses.
        No final video creation is triggered here.
        """
        print("DEBUG: Inside _show_review_dialog.")
        texts = get_texts_for_current_language(self.target_language_input)

        msg = QMessageBox(self)
        msg.setWindowTitle(texts.get("review_content_title", DEFAULT_STRINGS["review_content_title"]))

        if getattr(self, 'bypass_mode', False):
            msg.setText(texts.get("bypass_mode_message", DEFAULT_STRINGS["bypass_mode_message"]))
        else:
            msg.setText(texts.get("normal_mode_message", DEFAULT_STRINGS["normal_mode_message"]))

        msg.setStandardButtons(QMessageBox.Ok)
        msg.setWindowModality(Qt.NonModal)

        # Pressing OK just closes the dialog (info-only):
        msg.buttonClicked.connect(msg.close)
        msg.show()

    def _on_review_response(self, msg, button, callback):
        """
        Called ONLY in bypass mode if user hits OK. Proceeds with final video creation.
        """
        texts = get_texts_for_current_language(self.target_language_input)
        if msg.standardButton(button) == QMessageBox.Ok:
            progress = self.show_progress(
                texts.get("generating_final_video", DEFAULT_STRINGS["generating_final_video"])
            )
            if callback:
                callback()
            progress.close()
            self._cleanup_progress()
        else:
            print("[INFO:] Review aborted by user. Skipping final creation.")
            self.status_text.appendPlainText(texts.get("review_aborted", DEFAULT_STRINGS["review_aborted"]))

        msg.close()

    # ---------------------------------------------------------------------------
    # Start video creation.
    def start_video_creation(self):
        texts = get_texts_for_current_language(self.target_language_input)

        # Validate user input.
        video_title = self.video_title_input.text().strip()
        if not video_title:
            QMessageBox.warning(self, " Warning", texts.get("title_required", DEFAULT_STRINGS["title_required"]))
            return

        platform = self.platform_input.currentText().strip()
        if not platform:
            QMessageBox.warning(self, " Warning", texts.get("platform_required", DEFAULT_STRINGS["platform_required"]))
            return

        prompt = self.prompt_input.toPlainText().strip()
        if not prompt and not self.bypass_yes.isChecked():
            QMessageBox.warning(self, " Warning", texts.get("prompt_required", DEFAULT_STRINGS["prompt_required"]))
            return

        voice = self.voice_input.currentText().strip()
        modify_keywords = self.modify_yes.isChecked()
        bypass_text_subtitles_voiceover = self.bypass_yes.isChecked()
        selected_genre = self.genre_input.currentText()
        print(f"Selected Genre: {selected_genre}")


        try:
            self.create_video(video_title, prompt, voice, modify_keywords,
                              bypass_text_subtitles_voiceover, selected_genre)

        except Exception as e:
            QMessageBox.critical(self, " Error", f" An error occurred: {e}")
            self.status_text.appendPlainText(f" An error occurred: {e}")
        finally:
            pass


    # ---------------------------------------------------------------------------
    # Stub for create_video.
    def create_video(
            self,
            video_title,
            prompt,
            voice,
            modify_keywords,
            bypass_text_subtitles_voiceover,
            selected_genre
    ):
        # 1) Get or derive text from your GUI input fields as Python strings
        texts = get_texts_for_current_language(self.target_language_input)
        platform = self.platform_input.currentText().strip()

        # This is your QLineEdit for the base directory. .text() returns a string.
        base_directory_str = self.base_directory.text().strip()

        # Store the video title as a plain string on self.
        self.video_title_str = str(video_title).strip()

        # 2) Define (and store) your directories as strings, not widgets
        self.video_image_folder = os.path.join(base_directory_str, "InVidFiles")
        self.music_folder = os.path.join(base_directory_str, "InMusicFiles")
        self.output_directory = os.path.join(base_directory_str, "OutFiles")

        # Just for reference if needed
        srt_file = os.path.join(self.output_directory, f"{self.video_title_str}_subtitles.srt")

        # Make sure these folders exist
        os.makedirs(self.video_image_folder, exist_ok=True)
        os.makedirs(self.music_folder, exist_ok=True)
        os.makedirs(self.output_directory, exist_ok=True)

        # 3) Diagnostic prints or messages
        print(f"Creating video with title: {self.video_title_str}")
        print(f"Platform: {platform}")
        print(f"Prompt: {prompt}")
        print(f"Voice: {voice}")
        print(f"Modify Keywords: {'Yes' if modify_keywords else 'No'}")
        print(f"Bypass Text/Subtitles/Voiceover: {'Yes' if bypass_text_subtitles_voiceover else 'No'}")
        self.status_text.appendPlainText(f"{texts['creating_video']} {self.video_title_str}")

        try:
            default_platform = next(iter(output_settings))
            platform_settings = output_settings.get(platform, output_settings[default_platform])
            resolution = platform_settings['resolution']

            self.status_text.appendPlainText(f"{texts['video_in_progress']} {self.video_title_str}")

            # 4) Bypass mode
            if bypass_text_subtitles_voiceover:
                self.bypass_mode = True
                self.subtitles_tab.setEnabled(False)
                self.clip_sub_tab.setEnabled(True)

                # (Optional) Clear out older media from prior sessions
                self.media_clips = []
                self.music_clips = []

                # Example keyword extraction
                keywords = seo_extract_keywords(self.video_title_str)
                print("Extracted Keywords:", keywords)
                keywords = keywords.replace("\n", ",")
                keywords_list = [kw.strip() for kw in keywords.split(",") if kw.strip()]

                if modify_keywords:
                    new_val, ok = QInputDialog.getText(
                        None,
                        texts['modify_label'],
                        texts['enter_keywords'],
                        text=", ".join(keywords_list)
                    )
                    if ok:
                        new_val = new_val.replace("\n", ",")
                        keywords_list = [kw.strip() for kw in new_val.split(",") if kw.strip()]
                        print("Modified Keywords:", keywords_list)

                progress = self.show_progress(texts.get("starting_video", DEFAULT_STRINGS["starting_video"]))
                keywords_str = translate_and_combine_keywords(keywords_list)
                keywords_list = [kw.strip() for kw in keywords_str.split(",") if kw.strip()]

                downloaded_source_names = set()
                downloaded_music_urls = set()

                # Download logic
                for keyword in keywords_list:
                    print("Processing Keyword:", keyword)

                    # Download images
                    image_urls = search_pixabay_images(keyword, platform)
                    for i, url in enumerate(image_urls):
                        parsed = urlparse(url)
                        source_filename = os.path.basename(parsed.path)
                        if source_filename in downloaded_source_names:
                            continue
                        filename = f"{keyword}_image_{self.video_title_str}_{i + 1}.jpg"
                        download_file(url, self.video_image_folder, filename)
                        downloaded_source_names.add(source_filename)

                    # Download videos
                    video_urls = search_pixabay_videos(keyword, platform)
                    for i, url in enumerate(video_urls):
                        parsed = urlparse(url)
                        source_filename = os.path.basename(parsed.path)
                        if source_filename in downloaded_source_names:
                            continue
                        filename = f"{keyword}_video_{self.video_title_str}_{i + 1}.mp4"
                        download_file(url, self.video_image_folder, filename)
                        downloaded_source_names.add(source_filename)

                    # Download music
                    print(f"Selected Genre: {selected_genre}")
                    music_urls = search_jamendo_music(keyword, selected_genre)
                    for i, url in enumerate(music_urls):
                        if url in downloaded_music_urls:
                            continue
                        filename = f"{keyword}_music_{self.video_title_str}_{i + 1}.mp3"
                        download_file(url, self.music_folder, filename)
                        downloaded_music_urls.add(url)

                # NEW: Rebuild media/music lists from the downloaded files
                self.media_clips = self.get_downloaded_clips(self.video_image_folder)
                # If you have a separate method or want a quick approach for music:
                # self.music_clips = self.get_downloaded_clips(self.music_folder)
                # or, if your table expects .mp3 in self.music_clips, do:
                self.music_clips = [
                    os.path.join(self.music_folder, f)
                    for f in os.listdir(self.music_folder)
                    if f.lower().endswith(".mp3")
                ]

                # Refresh the table so user can see (and delete if desired)
                self.load_clips_and_subtitles()

                # Switch to the Clips tab
                self.tabs.setCurrentWidget(self.clip_sub_tab)

                # Let the user review, then continue
                self.request_review_notice(callback=self.continue_video_creation_bypass)
                return

            # 5) Non-bypass mode
            else:
                self.bypass_mode = False
                self.clip_sub_tab.setEnabled(False)
                self.subtitles_tab.setEnabled(True)

                # Kick off your async pipeline (script generation, etc.)
                asyncio.run(main(
                    video_title=self.video_title_str,
                    platform=platform,
                    prompt=prompt,
                    voice=voice,
                    modify_keywords=modify_keywords,
                    video_image_folder=self.video_image_folder,
                    output_directory=self.output_directory,
                    music_folder=self.music_folder,
                    selected_genre=selected_genre,
                    gui=self,
                    texts=texts
                ))

                # After the async flow, gather your downloaded clips
                self.media_clips = self.get_downloaded_clips(self.video_image_folder)
                # If your table also expects music clips:
                self.music_clips = [
                    os.path.join(self.music_folder, f)
                    for f in os.listdir(self.music_folder)
                    if f.lower().endswith(".mp3")
                ]

                # Example path for subtitles
                subtitles_txt = os.path.join(self.output_directory, f"{self.video_title_str}_subtitles.txt")
                print(f"DEBUG:  subtitles_txt: {subtitles_txt}")

                # Populate the table with newly downloaded items
                self.load_clips_and_subtitles()

                if os.path.exists(subtitles_txt):
                    self.tabs.setCurrentWidget(self.subtitles_tab)
                    print("Script generated; waiting for user to click 'Save and Regenerate Subtitles'.")
                else:
                    print("Script file was not generated. Please check the generation process.")

        except Exception as e:
            import traceback
            traceback.print_exc()
            self.status_text.appendPlainText(f" Error in main execution: {e}")

    def get_downloaded_clips(self, directory):
        """Retrieve downloaded video clips from the specified directory."""
        clips = []
        try:
            print(f"directory: {directory}")  # Debugging output
            for f in os.listdir(directory):
                if f.lower().endswith(('.mp4', '.avi', '.mov')):
                    clips.append(os.path.join(directory, f))
        except Exception as e:
            print(f" Error retrieving downloaded clips: {e}")
        print(f"clips: {clips}")  # Debugging output
        return clips

    # ---------------------------------------------------------------------------
    # Play video.
    def play_video(self):
        print(f"DEBUG: Inside play_video.")
        # at the very top of create_video:
        texts = get_texts_for_current_language(self.target_language_input)
        video_title = self.video_title_input.text().strip()
        print(f"DEBUG: Inside play_video. video_title: {video_title}")
        if not video_title:
            #QMessageBox.warning(self, " Warning", "Please enter a video title.")
            QMessageBox.warning(self, " Warning", texts.get("title_required", DEFAULT_STRINGS["title_required"]))

            return
        platform = self.platform_input.currentText().strip()
        final_video_file = os.path.join(self.output_directory.text(), f"{video_title}_{platform}.mp4")
        print(f"DEBUG:  final_video_file: {final_video_file}, platform: {platform}")
        if not os.path.exists(final_video_file):
            QMessageBox.warning(
                self,
                " Warning",
                texts.get("video_not_found",
                          DEFAULT_STRINGS["video_not_found"]
                          ).format(final_video_file)
            )

            return
        try:
            print(f"DEBUG:  Before openPreview final_video_file: {final_video_file}")
            # Instead of using os.startfile or webbrowser.open,
            # we call openPreview which is known to work.
            self.openPreview(final_video_file, "Video")
            #self.status_text.appendPlainText(f"Playing video: {final_video_file}")
            print(f"Playing video: {final_video_file}")
        except Exception as e:
            QMessageBox.critical(self, " Error", f" An error occurred while playing the video: {e}")
        pass

    def on_app_quit(self):
        """Runs just before QApplication quits."""
        # 1. close the global log so Windows will unlock OutFiles/log.txt
        close_log_file()

        # 2. archive the working sub-directories
        base_dir       = self.base_directory.text().strip()
        video_filename = self.video_title_input.text().strip()
        archive_subdirs(base_dir, video_filename)

async def list_voices():
    voices = await edge_tts.list_voices()
    #filtered_voices = [voice for voice in voices if voice['Locale'] in ['en-GB', 'en-US', 'Neural', 'ar', 'es', 'fr', 'pt', 'de', 'hi', 'zh' ]]
    filtered_voices = [voice for voice in voices if voice['Locale']]
    return filtered_voices


def clean_subtitles(video_title, output_directory):
    # Define file paths
    original_file = os.path.join(output_directory, f"{video_title}_subtitles.txt")
    backup_file = os.path.join(output_directory, f"{video_title}_subtitles_orig.txt")
    cleaned_file = os.path.join(output_directory, f"{video_title}_subtitles_cleaned.txt")

    # Create a backup of the original file
    shutil.copyfile(original_file, backup_file)

    # Define replacements for abbreviated text and special characters
    replacements = {
        "Article": "Video",
        "article": "video",
        "Its": "It is",
        "its": "it is",
        "it's": "it is",
        "Ill": "I will",
        "ill": "i will",
        "Ill": "I will",
        "Well": "We will",
        "well": "we will",
        "Were": "We are",
        "were": "we are",
        "Im": "I am",
        "im": "i am",
        "Im": "I am",
        "youre": "you are",
        "Youre": "You are",
        "You're": "You are",
        "you're": "you are",
        "'re": " are",
        "Weve": "We have",
        "weve": "we have",
        "Dont": "Do not",
        "dont": "do not",
        "don't": "do not",
        "Don't": "Do not",
        "n't": " not",
        "Youll": "You will",
        "youll": "you will",
        "Theres": "There is",
        "theres": "there is",
        "There is": "There is",
        "There's": "There is",
        "there's": "there is",
        "***": " ",
        "** *": " ",
        "* **": " ",
        "**": " ",
        "*": " ",
        "###": " ",
        "## #": " ",
        "# ##": " ",
        "##": " ",
        "#": " ",
        "-": " ",
        "": "'",
        "": "'",
        "": "\"",
        "": "\"",
        "": "...",
        "&": "and",
        "*": " "  # Additional replacement for any missed asterisks
    }

    # Sort replacements by length in descending order so longer matches get replaced first
    replacements = dict(sorted(replacements.items(), key=lambda item: len(item[0]), reverse=True))

    # Regex pattern to remove emojis/icons from text
    emoji_pattern = re.compile(
        "["                           # Start of character class
        u"\U0001F600-\U0001F64F"      # Emoticons
        u"\U0001F300-\U0001F5FF"      # Symbols & pictographs
        u"\U0001F680-\U0001F6FF"      # Transport & map symbols
        u"\U0001F700-\U0001F77F"      # Alchemical symbols
        u"\U0001F780-\U0001F7FF"      # Geometric Shapes Extended
        u"\U0001F800-\U0001F8FF"      # Supplemental Arrows-C
        u"\U0001F900-\U0001F9FF"      # Supplemental Symbols & Pictographs
        u"\U0001FA00-\U0001FA6F"      # Chess Symbols
        u"\U0001FA70-\U0001FAFF"      # Symbols & Pictographs Extended-A
        u"\U00002702-\U000027B0"      # Dingbats
        u"\U000024C2-\U0001F251"      # Enclosed characters
        "]+",
        flags=re.UNICODE
    )

    # Read the original file
    with open(original_file, 'r', encoding='utf-8') as file:
        lines = file.readlines()

    cleaned_lines = []
    for line in lines:
        # Apply dictionary-based replacements first
        for old, new in replacements.items():
            line = line.replace(old, new)
        # Remove any emojis/icons
        line = emoji_pattern.sub('', line)
        cleaned_lines.append(line)

    # Write the cleaned lines to the temporary cleaned file
    with open(cleaned_file, 'w', encoding='utf-8') as file:
        file.writelines(cleaned_lines)

    # Replace the original file with the cleaned file
    shutil.move(cleaned_file, original_file)

    print(f"Cleaned subtitles saved to {original_file}")



def generate_text_chatgpt(prompt):
    try:
        # Use the new OpenAI client for chat completion
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.7,
            max_tokens=800
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        print(f" Error occurred with OpenAI API: {e}")
        return f" An error occurred with OpenAI: {e}"


def generate_text(prompt):
    """
    Wrapper around the ChatGPT call and Gemini fallback, plus font selection.
    """
    global font

    # ChatGPT
    text = generate_text_chatgpt(prompt)

    # Choose Arabic font if we detect Arabic characters:
    if text and re.search(r'[\u0600-\u06FF]', text):
        font = arabic_font
    else:
        font = english_font

    print(f"from generate_text() returning font: {font}")
    # Return either the API response or an error placeholder
    return text or " Error: Could not generate text from any API."


def seo_extract_keywords(video_title):
    # Create a prompt that instructs ChatGPT to extract the top 5 SEO keywords
    prompt = (f"Please provide the top 5 SEO optimized keywords and tags for the video title: '{video_title}'. "
              "Return only clear multi-word relevant keywords as a comma-separated string.")
    # Call the ChatGPT API via our generate_text_chatgpt function
    #result = generate_text_chatgpt(prompt)
    result = generate_text(prompt)
    return result


def extract_keywords(text):
    stop_words = set(stopwords.words('english'))
    words = re.findall(r'\w+', text.lower())
    filtered_words = [word for word in words if word not in stop_words and len(word) > 3]
    common_words = Counter(filtered_words).most_common()
    keywords = [word for word, count in common_words]
    return keywords[:5]  # Limit to top 10 keywords


def search_jamendo_music(query, genre):
    try:
        response = requests.get(
            'https://api.jamendo.com/v3.0/tracks/',
            params={
                'client_id': 'c2b0a654',
                'format': 'json',
                'limit': 5,
                'search': query,
                'tags': genre
            }
        )
        data = response.json()
        print("Jamendo Music data:", data)
        if 'results' in data and data['results']:
            return [track['audio'] for track in data['results']]
        else:
            print("No Jamendo music found")
            return []
    except requests.RequestException as e:
        return [f" An error occurred: {e}"]


def search_pixabay_images(query, platform):
    try:
        response = requests.get(
            'https://pixabay.com/api/',
            params={'key': PIXABAY_API_KEY, 'q': query, 'image_type': 'photo', 'per_page': 5}
        )
        data = response.json()
        if 'hits' not in data or not data['hits']:
            return []

        # Get the exact target resolution for the platform.
        target_width, target_height = get_platform_resolution(platform)

        matching_images = []
        for hit in data['hits']:
            # Pixabay API provides image dimensions under 'imageWidth' and 'imageHeight'
            img_width = hit.get('imageWidth', 0)
            img_height = hit.get('imageHeight', 0)
            if img_width == target_width and img_height == target_height:
                url = hit.get('largeImageURL') or hit.get('webformatURL')
                if url:
                    matching_images.append(url)
        return matching_images

    except requests.RequestException as e:
        return [f" An error occurred: {e}"]


def search_pixabay_videos(query, platform):
    try:
        response = requests.get(
            'https://pixabay.com/api/videos/',
            params={'key': PIXABAY_API_KEY, 'q': query, 'per_page': 5}
        )
        data = response.json()

        if 'hits' not in data or not data['hits']:
            return []

        target_width, target_height = get_platform_resolution(platform)
        filtered_videos = []
        for hit in data['hits']:
            video_variants = hit.get('videos', {})
            for quality, details in video_variants.items():
                vid_width = details.get('width', 0)
                vid_height = details.get('height', 0)
                # Only consider variants that exactly match the target dimensions.
                if vid_width == target_width and vid_height == target_height:
                    filtered_videos.append(details.get('url'))
                    break  # Found a match; move to next hit.
        return filtered_videos

    except requests.RequestException as e:
        return [f" An error occurred: {e}"]


def search_pexels_images(query, platform):
    try:
        response = requests.get(
            'https://api.pexels.com/v1/search',
            headers={'Authorization': PEXELS_API_KEY},
            params={'query': query, 'per_page': 10}
        )
        data = response.json()

        if 'photos' in data:
            target_width, target_height = get_platform_resolution(platform)

            filtered_images = [
                photo['src']['original']
                for photo in data['photos']
                if 'width' in photo and 'height' in photo and
                   photo['width'] == target_width and
                   photo['height'] == target_height
            ]
            return filtered_images if filtered_images else []
        else:
            return []

    except requests.RequestException as e:
        return [f" An error occurred: {e}"]


def search_pexels_videos(query, platform, per_page=3):
    url = "https://api.pexels.com/videos/search"
    headers = {"Authorization": PEXELS_API_KEY}
    params = {"query": query, "per_page": per_page}

    try:
        response = requests.get(url, headers=headers, params=params)
        response.raise_for_status()
        data = response.json()

        if 'videos' not in data:
            return []

        target_width, target_height = get_platform_resolution(platform)
        filtered_videos = []
        for video in data['videos']:
            for file in video.get('video_files', []):
                vid_width = file.get('width', 0)
                vid_height = file.get('height', 0)
                if vid_width == target_width and vid_height == target_height:
                    filtered_videos.append(file.get('link'))
                    break
        return filtered_videos

    except requests.RequestException as e:
        print(f" An error occurred while fetching videos from Pexels: {e}")
        return []


def search_unsplash_photos(query, platform, per_page=5):
    url = "https://api.unsplash.com/search/photos"
    headers = {"Authorization": f"Client-ID {UNSPLASH_API_KEY}"}
    params = {"query": query, "per_page": per_page}

    try:
        response = requests.get(url, headers=headers, params=params)
        response.raise_for_status()
        results = response.json().get("results", [])

        target_width, target_height = get_platform_resolution(platform)
        filtered_results = []
        for photo in results:
            if isinstance(photo, dict):
                photo_width = photo.get("width", 0)
                photo_height = photo.get("height", 0)
                if photo_width == target_width and photo_height == target_height:
                    filtered_results.append({
                        "id": photo.get("id", "N/A"),
                        "description": photo.get("description", "No description available"),
                        "urls": photo.get("urls", {}),
                        "download_location": photo.get("links", {}).get("download_location", ""),
                        "user": photo.get("user", {}).get("name", "Unknown")
                    })
            else:
                print(f" Skipping unexpected response format: {photo}")

        print(
            f" Found {len(filtered_results)} images for '{query}' exactly matching {platform} resolution: {(target_width, target_height)}")
        return filtered_results

    except requests.exceptions.JSONDecodeError:
        print(" Error decoding JSON response from Unsplash API.")
        return []
    except requests.exceptions.RequestException as e:
        print(f" Error fetching photos from Unsplash: {e}")
        return []


def download_file(url, folder=None, filename=None, output_path=None):
    if output_path:
        folder, filename = os.path.split(output_path)
    elif folder and filename:
        output_path = os.path.join(folder, filename)
    else:
        raise ValueError(" Either 'folder' and 'filename' or a complete 'output_path' must be provided.")
    os.makedirs(folder, exist_ok=True)
    if os.path.exists(output_path):
        print(f"File already exists: {output_path}")
        return output_path

    headers = {
        'Authorization': f'Client-ID {UNSPLASH_API_KEY}',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36'
    }
    retries = 3
    for attempt in range(1, retries + 1):
        try:
            response = requests.get(url, headers=headers, stream=True, timeout=10)
            response.raise_for_status()
            with open(output_path, 'wb') as file:
                for chunk in response.iter_content(chunk_size=8192):
                    file.write(chunk)
            print(f"Successfully downloaded: {output_path}")
            return output_path
        except requests.exceptions.RequestException as e:
            print(f" Attempt {attempt}/{retries} failed for URL: {url}. Error: {e}")
            if attempt == retries:
                raise Exception(f"Failed to download file after {retries} attempts: {url}")


# Helper function accepting a list of keywords and returning a list with translations
def translate_and_combine_keywords(keyword_list):
    """
    Given a list of keywords, for each keyword containing non-English characters,
    call generate_text_chatgpt() to translate it into English. If a translation is provided
    and is different from the original, combine them.
    Returns a comma-separated string of the combined keywords.
    """
    combined_results = []
    for kw in keyword_list:
        if any(ord(c) > 127 for c in kw):  # Check non-ASCII characters
            prompt = f"Translate the following non-English keyword to English: '{kw}'. Return only the English translation."
            #translation = generate_text_chatgpt(prompt)
            translation = generate_text(prompt)
            if translation and translation.strip() and translation.strip().lower() != kw.lower():
                combined_results.append(f"{kw} {translation.strip()}")
            else:
                combined_results.append(kw)
        else:
            combined_results.append(kw)
    return ", ".join(combined_results)


def generate_content(texts, prompt, platform, video_title, modify_keywords, video_image_folder, output_directory,
                     music_folder, selected_genre):
    def get_wide_text(parent, window_title, label, default_text,
                      chars_to_show=100):
        """
        Opens a QInputDialog whose line-edit is wide enough to display
        `chars_to_show` average characters (100 by default).
        Returns (text, accepted)
        """
        dlg = QInputDialog(parent)
        dlg.setWindowTitle(window_title)
        dlg.setLabelText(label)
        dlg.setTextValue(default_text)
        dlg.setInputMode(QInputDialog.TextInput)

        # ----------------------------------------------------------------
        # Enlarge the dialog and the internal QLineEdit
        # ----------------------------------------------------------------
        # 1.  Find the line-edit that QInputDialog creates internally

        le = dlg.findChild(QLineEdit)

        if le is not None:
            # Compute the pixel width that  `chars_to_show` characters occupy
            fm = le.fontMetrics()
            char_width = fm.horizontalAdvance('M')  # M ~ widest char
            margin = 20  # extra padding
            target_px = char_width * chars_to_show + margin
            le.setMinimumWidth(target_px)  # make the edit wide
            dlg.resize(target_px + 50, dlg.sizeHint().height())  # make dialog wide

        # Optional: limit how much the user can type
        # le.setMaxLength(chars_to_show)   # uncomment if you need a hard max

        # ----------------------------------------------------------------
        # Execute the dialog
        # ----------------------------------------------------------------
        ok = dlg.exec_() == QDialog.Accepted
        return dlg.textValue(), ok

    def show_progress_local(message: str, parent=None):
        """
        A self-contained version of show_progress that:
        1) Creates a frameless, on-top QProgressDialog with the given message.
        2) Applies a style sheet to the dialog and label.
        3) Flashes the message text every 500ms.
        4) Returns the QProgressDialog object so you can later call close().
        """

        # Create a QProgressDialog
        dlg = QProgressDialog(message, None, 0, 0, parent)
        dlg.setWindowModality(Qt.ApplicationModal)
        dlg.setWindowTitle("Processing...")
        dlg.setCancelButton(None)
        dlg.setMinimumDuration(0)
        # Frameless + always on top
        dlg.setWindowFlags(dlg.windowFlags()
                           | Qt.FramelessWindowHint
                           | Qt.WindowStaysOnTopHint)

        # Style it (adjust to your preference)
        dlg.setStyleSheet("""
            QProgressDialog {
                background-color: rgba(240, 240, 240, 220);
                border-radius: 10px;
                padding: 20px;
            }
            QLabel {
                color: black;
                font-size: 12px;
                font-weight: bold;
            }
        """)

        dlg.setLabelText(message)
        dlg.show()
        dlg.setValue(0)

        # Make sure the UI updates
        QApplication.processEvents()

        # Obtain the QLabel (for flashing text)
        lbl = dlg.findChild(QLabel)
        if lbl:
            lbl.setTextFormat(Qt.RichText)
            lbl.setWordWrap(True)

        # Prepare flashing
        orig_text = message
        flash_text = f'<font color="#5d8aa8">{message}</font>'
        state = [False]

        # Timer to alternate text color
        timer = QTimer(dlg)
        timer.setInterval(500)

        def _flash():
            state[0] = not state[0]
            if lbl:
                lbl.setText(flash_text if state[0] else orig_text)

        timer.timeout.connect(_flash)
        timer.start()

        # Return the dialog so you can close it later
        return dlg

    #texts = get_texts_for_current_language(target_language)
    script_text = generate_text(prompt)

    # Ensure script_text is a string
    if isinstance(script_text, bytes):
        script_text = script_text.decode('utf-8')
    elif not isinstance(script_text, str):
        raise TypeError(" Generated text is neither str nor bytes")

    print("Generated Text:", script_text)

    text_script_file = os.path.join(output_directory, f"{video_title}_subtitles.txt")
    with open(text_script_file, 'w', encoding='utf-8') as file:
        file.write(script_text)
    clean_subtitles(video_title, output_directory)
    print(f"Text Cleaned and saved to {text_script_file}")

    # Extract keywords from the video title (returns a commaseparated string)
    keywords = seo_extract_keywords(video_title)
    print("Extracted Keywords:", keywords)

    # Replace newlines with commas and convert the string to a list
    keywords = keywords.replace("\n", ",")
    keywords_list = [kw.strip() for kw in keywords.split(",") if kw.strip()]

    # If modify_keywords is enabled, prompt the user once to edit the keywords
    if modify_keywords:
        """
        new_keywords_str, ok = QInputDialog.getText(
            None,
            texts['modify_label'],
            texts['enter_keywords'],
            text=", ".join(keywords_list)
        )
         """
        #new_keywords_str, ok = QInputDialog.getText(
        #    None,
        #    texts.get("modify_label", DEFAULT_STRINGS["modify_label"]),
        #    texts.get("enter_keywords", DEFAULT_STRINGS["enter_keywords"]),
        #    text=", ".join(keywords_list)
        #)
        new_keywords_str, ok = get_wide_text(
            None,
            texts['modify_label'],
            texts['enter_keywords'],
            default_text=", ".join(keywords_list),
            chars_to_show=80  # show 80 chars in one line
        )
        if ok:
            new_keywords_str = new_keywords_str.replace("\n", ",")
            keywords_list = [kw.strip() for kw in new_keywords_str.split(",") if kw.strip()]
            print("Modified Keywords:", keywords_list)

    # Now translate/combine the keywords using a helper function that accepts a list,
    # not a joined string.
    keywords_list = translate_and_combine_keywords(keywords_list)

    # In case the helper returns a comma-separated string, convert it back to a list
    keywords_list = [kw.strip() for kw in keywords_list.split(",") if kw.strip()]

    print("DEBUG: inside generate_content. Before show_progress_local")
    progress = show_progress_local(texts.get("starting_video", DEFAULT_STRINGS["starting_video"]))

    # Create sets to keep track of downloaded source identifiers.
    downloaded_media_sources = set()  # For images/videos (based on filename)
    downloaded_music_sources = set()  # For music (based on full URL)

    for keyword in keywords_list:
        print("Processing Keyword:", keyword)

        # Download Pixabay images.
        image_urls = search_pixabay_images(keyword, platform)
        for i, url in enumerate(image_urls):
            # Extract source filename from URL.
            source_filename = os.path.basename(urlparse(url).path)
            if source_filename in downloaded_media_sources:
                print(f"Skipping duplicate Pixabay image with source: {source_filename}")
                continue
            output_path = os.path.join(video_image_folder, f"{keyword}_pixabay_image_{video_title}_{i + 1}.jpg")
            download_file(url, output_path=output_path)
            downloaded_media_sources.add(source_filename)

        # Download Pixabay videos.
        pixabay_video_urls = search_pixabay_videos(keyword, platform)
        for i, url in enumerate(pixabay_video_urls):
            source_filename = os.path.basename(urlparse(url).path)
            if source_filename in downloaded_media_sources:
                print(f"Skipping duplicate Pixabay video with source: {source_filename}")
                continue
            output_path = os.path.join(video_image_folder, f"{keyword}_pixabay_video_{video_title}_{i + 1}.mp4")
            download_file(url, output_path=output_path)
            downloaded_media_sources.add(source_filename)

        # Download Pexels images.
        pexels_image_urls = search_pexels_images(keyword, platform)
        for i, url in enumerate(pexels_image_urls):
            source_filename = os.path.basename(urlparse(url).path)
            if source_filename in downloaded_media_sources:
                print(f"Skipping duplicate Pexels image with source: {source_filename}")
                continue
            output_path = os.path.join(video_image_folder, f"{keyword}_pexels_image_{video_title}_{i + 1}.jpg")
            download_file(url, output_path=output_path)
            downloaded_media_sources.add(source_filename)

        # Download Pexels videos.
        pexels_video_urls = search_pexels_videos(keyword, platform)
        for i, url in enumerate(pexels_video_urls):
            source_filename = os.path.basename(urlparse(url).path)
            if source_filename in downloaded_media_sources:
                print(f"Skipping duplicate Pexels video with source: {source_filename}")
                continue
            output_path = os.path.join(video_image_folder, f"{keyword}_pexels_video_{video_title}_{i + 1}.mp4")
            download_file(url, output_path=output_path)
            downloaded_media_sources.add(source_filename)

        # Download Unsplash images.
        unsplash_photo_results = search_unsplash_photos(keyword, platform)
        if unsplash_photo_results:
            for i, photo in enumerate(unsplash_photo_results, 1):
                if not isinstance(photo, dict):
                    print(f" Skipping invalid photo data: {photo}")
                    continue
                download_location = photo.get("download_location", "")
                if not download_location:
                    print(f" No valid download location for photo: {photo.get('description', 'No description')}")
                    continue
                try:
                    headers = {"Authorization": f"Client-ID {UNSPLASH_API_KEY}"}
                    response = requests.get(download_location, headers=headers)
                    response.raise_for_status()
                    download_url = response.json().get("url", "")
                    if not download_url:
                        print(
                            f"No valid download URL retrieved for photo: {photo.get('description', 'No description')}")
                        continue
                    source_filename = os.path.basename(urlparse(download_url).path)
                    if source_filename in downloaded_media_sources:
                        print(f"Skipping duplicate Unsplash image with source: {source_filename}")
                        continue
                    print(
                        f"Downloading Unsplash photo: {photo.get('description', 'No description')} by {photo.get('user', 'Unknown')}")
                    filename = f"{keyword}_unsplash_image_{video_title}_{i}.jpg"
                    download_file(download_url, video_image_folder, filename)
                    downloaded_media_sources.add(source_filename)
                except Exception as e:
                    print(f" Error fetching or downloading photo: {e}")
        else:
            print(f" No photos found on Unsplash for keyword: {keyword}")

        # Download Jamendo music.
        print(f"Selected Genre3: {selected_genre}")
        jamendo_music_urls = search_jamendo_music(keyword, selected_genre)
        if not jamendo_music_urls:
            print("No Jamendo music found")
        else:
            for i, url in enumerate(jamendo_music_urls):
                # For music, we'll use the entire URL as the unique identifier.
                if url in downloaded_music_sources:
                    print("Skipping duplicate Jamendo music (URL already processed)")
                    continue
                filename = f"{keyword}_jamendo_music_{video_title}_{i + 1}.mp3"
                output_path = os.path.join(music_folder, filename)
                download_file(url, output_path=output_path)
                downloaded_music_sources.add(url)
                os.makedirs(output_directory, exist_ok=True)

    script_text = read_script_file(text_script_file)

    # Ensure script_text is a string
    if isinstance(script_text, bytes):
        script_text = script_text.decode('utf-8')
    elif not isinstance(script_text, str):
        raise TypeError(" Script text is neither str nor bytes after reading from file")

    print("Before writing script to file again....")
    with open(text_script_file, 'w', encoding='utf-8') as file:
        file.write(script_text)
    clean_subtitles(video_title, output_directory)
    print(f"Text Cleaned Again and saved to {text_script_file}")

    #progress.close()

    return script_text, keywords, text_script_file


def read_script_file(text_script_file):
    try:
        with open(text_script_file, 'r', encoding='utf-8') as file:
            text = file.read()
        return text
    except UnicodeDecodeError:
        try:
            with open(text_script_file, 'r', encoding='latin-1') as file:
                text = file.read()
            return text
        except UnicodeDecodeError:
            try:
                with open(text_script_file, 'r', encoding='cp1252') as file:
                    text = file.read()
                return text
            except Exception as e:
                print(f" Error reading file {text_script_file} with various encodings: {e}")
                return None
    except Exception as e:
        print(f" Error reading file {text_script_file}: {e}")
        return None


async def convert_text_to_speech(text, voice, output_file):
    communicate = edge_tts.Communicate(text, voice)
    await communicate.save(output_file)
    print(f"Voiceover saved to {output_file}")


def get_audio_duration(file_path):
    try:
        audio = AudioSegment.from_file(file_path)
        return len(audio) / 1000.0  # Convert milliseconds to seconds
    except FileNotFoundError as e:
        print(f"Audio file not found: {e}")
        return 0
    except Exception as e:
        print(f" Error getting audio duration: {e}")
        return 0


def resize_clip(clip, target_resolution):
    try:
        if not isinstance(target_resolution, tuple) or len(target_resolution) != 2:
            raise ValueError(" target_resolution should be a tuple of (width, height)")

        clip_resolution = (int(clip.w), int(clip.h))  # Get clip's current resolution
        print(f" Clip resolution: {clip_resolution}, Target resolution: {target_resolution}")

        #  Only resize if resolutions don't match
        if clip_resolution == target_resolution:
            print(" No resizing needed. Clip resolution matches the target platform.")
            return clip  # Return the original clip if it already matches

        print(f" Resizing clip to: {target_resolution}")
        resized_clip = resize(clip, newsize=target_resolution)

        if resized_clip is None:
            print(" Error: Resized clip is None.")
            return None
        else:
            print(f" Resized clip resolution: {resized_clip.size}")
            return resized_clip

    except Exception as e:
        print(f" Error resizing video: {e}")
        return None


async def generate_voiceover(text, output_file, voice):
    try:
        await convert_text_to_speech(text, voice, output_file)
    except ValueError as e:
        print(f" Value error: {e}")
    except Exception as e:
        print(f" An unexpected error occurred: {e}")


def generate_subtitles_local(script, subtitles_file, voiceover_duration):
    try:
        subtitles = []
        words = script.split()
        with open(subtitles_file, 'w', encoding='utf-8') as f:
            start_time = 0
            line = []
            for word in words:
                if len(' '.join(line + [word])) <= 45:
                    line.append(word)
                else:
                    duration = len(' '.join(line).split()) / len(script.split()) * voiceover_duration
                    end_time = start_time + duration
                    subtitle_line = ' '.join(line)
                    subtitles.append((start_time, end_time, subtitle_line))
                    f.write(f"{start_time:.3f} --> {end_time:.3f}\n{subtitle_line}\n\n")
                    start_time = end_time
                    line = [word]
            if line:
                duration = len(' '.join(line).split()) / len(script.split()) * voiceover_duration
                end_time = start_time + duration
                subtitle_line = ' '.join(line)
                subtitles.append((start_time, end_time, subtitle_line))
                f.write(f"{start_time:.3f} --> {end_time:.3f}\n{subtitle_line}\n\n")
        return subtitles
    except Exception as e:
        print(f" Error generating subtitles: {e}")
        return None


async def main(video_title,
               platform,
               prompt,
               voice,
               modify_keywords,
               video_image_folder,
               output_directory,
               music_folder,
               selected_genre,
               gui,        # instance of VideoCreatorGUI
               texts):     # dict returned by get_texts_for_current_language


    # 1) Log the "creating video" message
    msg = texts.get('creating_video', DEFAULT_STRINGS['creating_video'])
    print(f"{msg} {video_title}")

    # 2) Generate the script, keywords, etc.
    text, keywords, script_file = generate_content(
        texts,
        prompt,
        platform,
        video_title,
        modify_keywords,
        video_image_folder,
        output_directory,
        music_folder,
        selected_genre
    )

    # 3) Prepare for voice-over + subtitles
    warnings.filterwarnings("ignore", category=SyntaxWarning, module='pydub')

    # Where ChatGPT saved the .txt
    script_path = os.path.join(output_directory,
                               f"{video_title}_subtitles.txt")
    # Read it back if present
    script = text
    if os.path.exists(script_path):
        try:
            with open(script_path, 'r', encoding='utf-8') as f:
                script = f.read()
        except Exception as e:
            print(f"  Could not read {script_path}: {e}; using generated text.")

    # 4) Generate the voice-over
    voiceover_file = os.path.join(output_directory,
                                  f"{video_title}_voiceover.mp3")
    await generate_voiceover(script, voiceover_file, voice)

    # 5) Build SRT subtitles
    subtitles_file = os.path.join(output_directory,
                                  f"{video_title}_subtitles.srt")
    voiceover_duration = get_audio_duration(voiceover_file)
    if voiceover_duration <= 0:
        print(" Invalid voiceover duration; aborting.")
        return

    wip_subtitles = generate_subtitles_local(
        script, subtitles_file, voiceover_duration
    )

    # 6) Final check that our .srt exists
    if not os.path.exists(subtitles_file):
        print(f" Subtitles not found at {subtitles_file}; aborting.")
        return

    # 7) Hand back to GUI to do the final video+audio merge
    gui.create_video_with_audio_and_subtitles(
        video_title,
        subtitles_file,
        platform,
        video_image_folder,
        music_folder,
        output_directory
    )

def show_animated_splash():

    splash = QSplashScreen()
    # Make it frameless if desired
    splash.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint)

    # Force a fixed size so the splash won't resize automatically
    splash.setFixedSize(600, 400)

    # Create a QLabel that covers the entire splash
    splash_label = QLabel(splash)
    splash_label.setAlignment(Qt.AlignCenter)
    splash_label.setGeometry(0, 0, 600, 400)
    splash_label.setScaledContents(True)  # Scale GIF to fill label if needed

    # Load and set the GIF
    movie = QMovie(SPLASH_GIF)
    # Optionally force the GIF itself to 600400 if you want it stretched:
    movie.setScaledSize(QSize(600, 400))
    splash_label.setMovie(movie)
    movie.start()

    # Center the splash on the screen
    screen_rect = QApplication.primaryScreen().availableGeometry()
    x = (screen_rect.width() - 600) // 2
    y = (screen_rect.height() - 400) // 2
    splash.move(x, y)

    splash.show()
    return splash


if __name__ == "__main__":



    _set_imagemagick_path()
    app = QApplication(sys.argv)
    # 1. Show splash
    splash_screen = show_animated_splash()

    # 2. Instantiate GUI but do not show it immediately
    gui = VideoCreatorGUI()

    # 3. Hide splash and show GUI after a short delay or once init is done
    QTimer.singleShot(2500, lambda: (splash_screen.close(), gui.show()))

    app.aboutToQuit.connect(close_log_file)  # Connect cleanup function

    gui.show()
    sys.exit(app.exec_())


